{"ast":null,"code":"import Circle from 'ol/style/Circle.js';\nimport Fill from 'ol/style/Fill.js';\nimport Icon from 'ol/style/Icon.js';\nimport RenderFeature from 'ol/render/Feature.js';\nimport Stroke from 'ol/style/Stroke.js';\nimport Style from 'ol/style/Style.js';\nimport Text from 'ol/style/Text.js';\nimport { registerFont, checkedFonts } from 'ol/render/canvas.js';\nimport { expandUrl } from 'ol/tileurlfunction.js';\nimport GeoJSON from 'ol/format/GeoJSON.js';\nimport ImageLayer from 'ol/layer/Image.js';\nimport Layer from 'ol/layer/Layer.js';\nimport LayerGroup from 'ol/layer/Group.js';\nimport MVT from 'ol/format/MVT.js';\nimport Map from 'ol/Map.js';\nimport Raster from 'ol/source/Raster.js';\nimport Source from 'ol/source/Source.js';\nimport TileGrid from 'ol/tilegrid/TileGrid.js';\nimport TileJSON from 'ol/source/TileJSON.js';\nimport TileLayer from 'ol/layer/Tile.js';\nimport VectorLayer from 'ol/layer/Vector.js';\nimport VectorSource from 'ol/source/Vector.js';\nimport VectorTileLayer from 'ol/layer/VectorTile.js';\nimport VectorTileSource, { defaultLoadFunction } from 'ol/source/VectorTile.js';\nimport View from 'ol/View.js';\nimport { get as get$1, METERS_PER_UNIT, fromLonLat, equivalent, getUserProjection } from 'ol/proj.js';\nimport { bbox } from 'ol/loadingstrategy.js';\nimport { createXYZ } from 'ol/tilegrid.js';\nimport { getTopLeft } from 'ol/extent.js';\nvar csscolorparser = {};\nvar parseCSSColor_1;\n// (c) Dean McNamee <dean@gmail.com>, 2012.\n//\n// https://github.com/deanm/css-color-parser-js\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n// http://www.w3.org/TR/css3-color/\nvar kCSSColorTable = {\n  'transparent': [0, 0, 0, 0],\n  'aliceblue': [240, 248, 255, 1],\n  'antiquewhite': [250, 235, 215, 1],\n  'aqua': [0, 255, 255, 1],\n  'aquamarine': [127, 255, 212, 1],\n  'azure': [240, 255, 255, 1],\n  'beige': [245, 245, 220, 1],\n  'bisque': [255, 228, 196, 1],\n  'black': [0, 0, 0, 1],\n  'blanchedalmond': [255, 235, 205, 1],\n  'blue': [0, 0, 255, 1],\n  'blueviolet': [138, 43, 226, 1],\n  'brown': [165, 42, 42, 1],\n  'burlywood': [222, 184, 135, 1],\n  'cadetblue': [95, 158, 160, 1],\n  'chartreuse': [127, 255, 0, 1],\n  'chocolate': [210, 105, 30, 1],\n  'coral': [255, 127, 80, 1],\n  'cornflowerblue': [100, 149, 237, 1],\n  'cornsilk': [255, 248, 220, 1],\n  'crimson': [220, 20, 60, 1],\n  'cyan': [0, 255, 255, 1],\n  'darkblue': [0, 0, 139, 1],\n  'darkcyan': [0, 139, 139, 1],\n  'darkgoldenrod': [184, 134, 11, 1],\n  'darkgray': [169, 169, 169, 1],\n  'darkgreen': [0, 100, 0, 1],\n  'darkgrey': [169, 169, 169, 1],\n  'darkkhaki': [189, 183, 107, 1],\n  'darkmagenta': [139, 0, 139, 1],\n  'darkolivegreen': [85, 107, 47, 1],\n  'darkorange': [255, 140, 0, 1],\n  'darkorchid': [153, 50, 204, 1],\n  'darkred': [139, 0, 0, 1],\n  'darksalmon': [233, 150, 122, 1],\n  'darkseagreen': [143, 188, 143, 1],\n  'darkslateblue': [72, 61, 139, 1],\n  'darkslategray': [47, 79, 79, 1],\n  'darkslategrey': [47, 79, 79, 1],\n  'darkturquoise': [0, 206, 209, 1],\n  'darkviolet': [148, 0, 211, 1],\n  'deeppink': [255, 20, 147, 1],\n  'deepskyblue': [0, 191, 255, 1],\n  'dimgray': [105, 105, 105, 1],\n  'dimgrey': [105, 105, 105, 1],\n  'dodgerblue': [30, 144, 255, 1],\n  'firebrick': [178, 34, 34, 1],\n  'floralwhite': [255, 250, 240, 1],\n  'forestgreen': [34, 139, 34, 1],\n  'fuchsia': [255, 0, 255, 1],\n  'gainsboro': [220, 220, 220, 1],\n  'ghostwhite': [248, 248, 255, 1],\n  'gold': [255, 215, 0, 1],\n  'goldenrod': [218, 165, 32, 1],\n  'gray': [128, 128, 128, 1],\n  'green': [0, 128, 0, 1],\n  'greenyellow': [173, 255, 47, 1],\n  'grey': [128, 128, 128, 1],\n  'honeydew': [240, 255, 240, 1],\n  'hotpink': [255, 105, 180, 1],\n  'indianred': [205, 92, 92, 1],\n  'indigo': [75, 0, 130, 1],\n  'ivory': [255, 255, 240, 1],\n  'khaki': [240, 230, 140, 1],\n  'lavender': [230, 230, 250, 1],\n  'lavenderblush': [255, 240, 245, 1],\n  'lawngreen': [124, 252, 0, 1],\n  'lemonchiffon': [255, 250, 205, 1],\n  'lightblue': [173, 216, 230, 1],\n  'lightcoral': [240, 128, 128, 1],\n  'lightcyan': [224, 255, 255, 1],\n  'lightgoldenrodyellow': [250, 250, 210, 1],\n  'lightgray': [211, 211, 211, 1],\n  'lightgreen': [144, 238, 144, 1],\n  'lightgrey': [211, 211, 211, 1],\n  'lightpink': [255, 182, 193, 1],\n  'lightsalmon': [255, 160, 122, 1],\n  'lightseagreen': [32, 178, 170, 1],\n  'lightskyblue': [135, 206, 250, 1],\n  'lightslategray': [119, 136, 153, 1],\n  'lightslategrey': [119, 136, 153, 1],\n  'lightsteelblue': [176, 196, 222, 1],\n  'lightyellow': [255, 255, 224, 1],\n  'lime': [0, 255, 0, 1],\n  'limegreen': [50, 205, 50, 1],\n  'linen': [250, 240, 230, 1],\n  'magenta': [255, 0, 255, 1],\n  'maroon': [128, 0, 0, 1],\n  'mediumaquamarine': [102, 205, 170, 1],\n  'mediumblue': [0, 0, 205, 1],\n  'mediumorchid': [186, 85, 211, 1],\n  'mediumpurple': [147, 112, 219, 1],\n  'mediumseagreen': [60, 179, 113, 1],\n  'mediumslateblue': [123, 104, 238, 1],\n  'mediumspringgreen': [0, 250, 154, 1],\n  'mediumturquoise': [72, 209, 204, 1],\n  'mediumvioletred': [199, 21, 133, 1],\n  'midnightblue': [25, 25, 112, 1],\n  'mintcream': [245, 255, 250, 1],\n  'mistyrose': [255, 228, 225, 1],\n  'moccasin': [255, 228, 181, 1],\n  'navajowhite': [255, 222, 173, 1],\n  'navy': [0, 0, 128, 1],\n  'oldlace': [253, 245, 230, 1],\n  'olive': [128, 128, 0, 1],\n  'olivedrab': [107, 142, 35, 1],\n  'orange': [255, 165, 0, 1],\n  'orangered': [255, 69, 0, 1],\n  'orchid': [218, 112, 214, 1],\n  'palegoldenrod': [238, 232, 170, 1],\n  'palegreen': [152, 251, 152, 1],\n  'paleturquoise': [175, 238, 238, 1],\n  'palevioletred': [219, 112, 147, 1],\n  'papayawhip': [255, 239, 213, 1],\n  'peachpuff': [255, 218, 185, 1],\n  'peru': [205, 133, 63, 1],\n  'pink': [255, 192, 203, 1],\n  'plum': [221, 160, 221, 1],\n  'powderblue': [176, 224, 230, 1],\n  'purple': [128, 0, 128, 1],\n  'rebeccapurple': [102, 51, 153, 1],\n  'red': [255, 0, 0, 1],\n  'rosybrown': [188, 143, 143, 1],\n  'royalblue': [65, 105, 225, 1],\n  'saddlebrown': [139, 69, 19, 1],\n  'salmon': [250, 128, 114, 1],\n  'sandybrown': [244, 164, 96, 1],\n  'seagreen': [46, 139, 87, 1],\n  'seashell': [255, 245, 238, 1],\n  'sienna': [160, 82, 45, 1],\n  'silver': [192, 192, 192, 1],\n  'skyblue': [135, 206, 235, 1],\n  'slateblue': [106, 90, 205, 1],\n  'slategray': [112, 128, 144, 1],\n  'slategrey': [112, 128, 144, 1],\n  'snow': [255, 250, 250, 1],\n  'springgreen': [0, 255, 127, 1],\n  'steelblue': [70, 130, 180, 1],\n  'tan': [210, 180, 140, 1],\n  'teal': [0, 128, 128, 1],\n  'thistle': [216, 191, 216, 1],\n  'tomato': [255, 99, 71, 1],\n  'turquoise': [64, 224, 208, 1],\n  'violet': [238, 130, 238, 1],\n  'wheat': [245, 222, 179, 1],\n  'white': [255, 255, 255, 1],\n  'whitesmoke': [245, 245, 245, 1],\n  'yellow': [255, 255, 0, 1],\n  'yellowgreen': [154, 205, 50, 1]\n};\nfunction clamp_css_byte(i) {\n  // Clamp to integer 0 .. 255.\n  i = Math.round(i);\n  // Seems to be what Chrome does (vs truncation).\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n}\nfunction clamp_css_float(f) {\n  // Clamp to float 0.0 .. 1.0.\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\nfunction parse_css_int(str) {\n  // int or percentage.\n  if (str[str.length - 1] === '%') {\n    return clamp_css_byte(parseFloat(str) / 100 * 255);\n  }\n  return clamp_css_byte(parseInt(str));\n}\nfunction parse_css_float(str) {\n  // float or percentage.\n  if (str[str.length - 1] === '%') {\n    return clamp_css_float(parseFloat(str) / 100);\n  }\n  return clamp_css_float(parseFloat(str));\n}\nfunction css_hue_to_rgb(m1, m2, h) {\n  if (h < 0) {\n    h += 1;\n  } else if (h > 1) {\n    h -= 1;\n  }\n  if (h * 6 < 1) {\n    return m1 + (m2 - m1) * h * 6;\n  }\n  if (h * 2 < 1) {\n    return m2;\n  }\n  if (h * 3 < 2) {\n    return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n  }\n  return m1;\n}\nfunction parseCSSColor(css_str) {\n  // Remove all whitespace, not compliant, but should just be more accepting.\n  var str = css_str.replace(/ /g, '').toLowerCase();\n  // Color keywords (and transparent) lookup.\n  if (str in kCSSColorTable) {\n    return kCSSColorTable[str].slice();\n  }\n  // dup.\n  // #abc and #abc123 syntax.\n  if (str[0] === '#') {\n    if (str.length === 4) {\n      var iv = parseInt(str.substr(1), 16);\n      // TODO(deanm): Stricter parsing.\n      if (!(iv >= 0 && iv <= 4095)) {\n        return null;\n      }\n      // Covers NaN.\n      return [(iv & 3840) >> 4 | (iv & 3840) >> 8, iv & 240 | (iv & 240) >> 4, iv & 15 | (iv & 15) << 4, 1];\n    } else if (str.length === 7) {\n      var iv = parseInt(str.substr(1), 16);\n      // TODO(deanm): Stricter parsing.\n      if (!(iv >= 0 && iv <= 16777215)) {\n        return null;\n      }\n      // Covers NaN.\n      return [(iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, 1];\n    }\n    return null;\n  }\n  var op = str.indexOf('('),\n    ep = str.indexOf(')');\n  if (op !== -1 && ep + 1 === str.length) {\n    var fname = str.substr(0, op);\n    var params = str.substr(op + 1, ep - (op + 1)).split(',');\n    var alpha = 1;\n    // To allow case fallthrough.\n    switch (fname) {\n      case 'rgba':\n        if (params.length !== 4) {\n          return null;\n        }\n        alpha = parse_css_float(params.pop());\n      // Fall through.\n      case 'rgb':\n        if (params.length !== 3) {\n          return null;\n        }\n        return [parse_css_int(params[0]), parse_css_int(params[1]), parse_css_int(params[2]), alpha];\n      case 'hsla':\n        if (params.length !== 4) {\n          return null;\n        }\n        alpha = parse_css_float(params.pop());\n      // Fall through.\n      case 'hsl':\n        if (params.length !== 3) {\n          return null;\n        }\n        var h = (parseFloat(params[0]) % 360 + 360) % 360 / 360;\n        // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parse_css_float(params[1]);\n        var l = parse_css_float(params[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255), alpha];\n      default:\n        return null;\n    }\n  }\n  return null;\n}\ntry {\n  parseCSSColor_1 = csscolorparser.parseCSSColor = parseCSSColor;\n} catch (e) {}\n\n//      \n/**\n * An RGBA color value. Create instances from color strings using the static\n * method `Color.parse`. The constructor accepts RGB channel values in the range\n * `[0, 1]`, premultiplied by A.\n *\n * @param {number} r The red channel.\n * @param {number} g The green channel.\n * @param {number} b The blue channel.\n * @param {number} a The alpha channel.\n * @private\n */\nvar Color = function Color(r, g, b, a) {\n  if (a === void 0) a = 1;\n  this.r = r;\n  this.g = g;\n  this.b = b;\n  this.a = a;\n};\n/**\n * Parses valid CSS color strings and returns a `Color` instance.\n * @returns A `Color` instance, or `undefined` if the input is not a valid color string.\n */\nColor.parse = function parse(input) {\n  if (!input) {\n    return undefined;\n  }\n  if (input instanceof Color) {\n    return input;\n  }\n  if (typeof input !== 'string') {\n    return undefined;\n  }\n  var rgba = parseCSSColor_1(input);\n  if (!rgba) {\n    return undefined;\n  }\n  return new Color(rgba[0] / 255 * rgba[3], rgba[1] / 255 * rgba[3], rgba[2] / 255 * rgba[3], rgba[3]);\n};\n/**\n * Returns an RGBA string representing the color value.\n *\n * @returns An RGBA string.\n * @example\n * var purple = new Color.parse('purple');\n * purple.toString; // = \"rgba(128,0,128,1)\"\n * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');\n * translucentGreen.toString(); // = \"rgba(26,207,26,0.73)\"\n */\nColor.prototype.toString = function toString() {\n  var ref = this.toArray();\n  var r = ref[0];\n  var g = ref[1];\n  var b = ref[2];\n  var a = ref[3];\n  return \"rgba(\" + Math.round(r) + \",\" + Math.round(g) + \",\" + Math.round(b) + \",\" + a + \")\";\n};\n/**\n * Returns an RGBA array of values representing the color, unpremultiplied by A.\n *\n * @returns An array of RGBA color values in the range [0, 255].\n */\nColor.prototype.toArray = function toArray() {\n  var ref = this;\n  var r = ref.r;\n  var g = ref.g;\n  var b = ref.b;\n  var a = ref.a;\n  return a === 0 ? [0, 0, 0, 0] : [r * 255 / a, g * 255 / a, b * 255 / a, a];\n};\n/**\n * Returns a RGBA array of float values representing the color, unpremultiplied by A.\n *\n * @returns An array of RGBA color values in the range [0, 1].\n */\nColor.prototype.toArray01 = function toArray01() {\n  var ref = this;\n  var r = ref.r;\n  var g = ref.g;\n  var b = ref.b;\n  var a = ref.a;\n  return a === 0 ? [0, 0, 0, 0] : [r / a, g / a, b / a, a];\n};\n/**\n * Returns an RGBA array of values representing the color, premultiplied by A.\n *\n * @returns An array of RGBA color values in the range [0, 1].\n */\nColor.prototype.toArray01PremultipliedAlpha = function toArray01PremultipliedAlpha() {\n  var ref = this;\n  var r = ref.r;\n  var g = ref.g;\n  var b = ref.b;\n  var a = ref.a;\n  return [r, g, b, a];\n};\nColor.black = new Color(0, 0, 0, 1);\nColor.white = new Color(1, 1, 1, 1);\nColor.transparent = new Color(0, 0, 0, 0);\nColor.red = new Color(1, 0, 0, 1);\nColor.blue = new Color(0, 0, 1, 1);\nvar Color$1 = Color;\nfunction convertLiteral(value) {\n  return typeof value === 'object' ? ['literal', value] : value;\n}\nfunction convertFunction(parameters, propertySpec) {\n  var stops = parameters.stops;\n  if (!stops) {\n    // identity function\n    return convertIdentityFunction(parameters, propertySpec);\n  }\n  var zoomAndFeatureDependent = stops && typeof stops[0][0] === 'object';\n  var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;\n  var zoomDependent = zoomAndFeatureDependent || !featureDependent;\n  stops = stops.map(function (stop) {\n    if (!featureDependent && propertySpec.tokens && typeof stop[1] === 'string') {\n      return [stop[0], convertTokenString(stop[1])];\n    }\n    return [stop[0], convertLiteral(stop[1])];\n  });\n  if (zoomAndFeatureDependent) {\n    return convertZoomAndPropertyFunction(parameters, propertySpec, stops);\n  } else if (zoomDependent) {\n    return convertZoomFunction(parameters, propertySpec, stops);\n  } else {\n    return convertPropertyFunction(parameters, propertySpec, stops);\n  }\n}\nfunction convertIdentityFunction(parameters, propertySpec) {\n  var get = ['get', parameters.property];\n  if (parameters.default === undefined) {\n    // By default, expressions for string-valued properties get coerced. To preserve\n    // legacy function semantics, insert an explicit assertion instead.\n    return propertySpec.type === 'string' ? ['string', get] : get;\n  } else if (propertySpec.type === 'enum') {\n    return ['match', get, Object.keys(propertySpec.values), get, parameters.default];\n  } else {\n    var expression = [propertySpec.type === 'color' ? 'to-color' : propertySpec.type, get, convertLiteral(parameters.default)];\n    if (propertySpec.type === 'array') {\n      expression.splice(1, 0, propertySpec.value, propertySpec.length || null);\n    }\n    return expression;\n  }\n}\nfunction getInterpolateOperator(parameters) {\n  switch (parameters.colorSpace) {\n    case 'hcl':\n      return 'interpolate-hcl';\n    case 'lab':\n      return 'interpolate-lab';\n    default:\n      return 'interpolate';\n  }\n}\nfunction convertZoomAndPropertyFunction(parameters, propertySpec, stops) {\n  var featureFunctionParameters = {};\n  var featureFunctionStops = {};\n  var zoomStops = [];\n  for (var s = 0; s < stops.length; s++) {\n    var stop = stops[s];\n    var zoom = stop[0].zoom;\n    if (featureFunctionParameters[zoom] === undefined) {\n      featureFunctionParameters[zoom] = {\n        zoom: zoom,\n        type: parameters.type,\n        property: parameters.property,\n        default: parameters.default\n      };\n      featureFunctionStops[zoom] = [];\n      zoomStops.push(zoom);\n    }\n    featureFunctionStops[zoom].push([stop[0].value, stop[1]]);\n  }\n  // the interpolation type for the zoom dimension of a zoom-and-property\n  // function is determined directly from the style property specification\n  // for which it's being used: linear for interpolatable properties, step\n  // otherwise.\n  var functionType = getFunctionType({}, propertySpec);\n  if (functionType === 'exponential') {\n    var expression = [getInterpolateOperator(parameters), ['linear'], ['zoom']];\n    for (var i = 0, list = zoomStops; i < list.length; i += 1) {\n      var z = list[i];\n      var output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);\n      appendStopPair(expression, z, output, false);\n    }\n    return expression;\n  } else {\n    var expression$1 = ['step', ['zoom']];\n    for (var i$1 = 0, list$1 = zoomStops; i$1 < list$1.length; i$1 += 1) {\n      var z$1 = list$1[i$1];\n      var output$1 = convertPropertyFunction(featureFunctionParameters[z$1], propertySpec, featureFunctionStops[z$1]);\n      appendStopPair(expression$1, z$1, output$1, true);\n    }\n    fixupDegenerateStepCurve(expression$1);\n    return expression$1;\n  }\n}\nfunction coalesce(a, b) {\n  if (a !== undefined) {\n    return a;\n  }\n  if (b !== undefined) {\n    return b;\n  }\n}\nfunction getFallback(parameters, propertySpec) {\n  var defaultValue = convertLiteral(coalesce(parameters.default, propertySpec.default));\n  /*\n   * Some fields with type: resolvedImage have an undefined default.\n   * Because undefined is an invalid value for resolvedImage, set fallback to\n   * an empty string instead of undefined to ensure output\n   * passes validation.\n   */\n  if (defaultValue === undefined && propertySpec.type === 'resolvedImage') {\n    return '';\n  }\n  return defaultValue;\n}\nfunction convertPropertyFunction(parameters, propertySpec, stops) {\n  var type = getFunctionType(parameters, propertySpec);\n  var get = ['get', parameters.property];\n  if (type === 'categorical' && typeof stops[0][0] === 'boolean') {\n    var expression = ['case'];\n    for (var i = 0, list = stops; i < list.length; i += 1) {\n      var stop = list[i];\n      expression.push(['==', get, stop[0]], stop[1]);\n    }\n    expression.push(getFallback(parameters, propertySpec));\n    return expression;\n  } else if (type === 'categorical') {\n    var expression$1 = ['match', get];\n    for (var i$1 = 0, list$1 = stops; i$1 < list$1.length; i$1 += 1) {\n      var stop$1 = list$1[i$1];\n      appendStopPair(expression$1, stop$1[0], stop$1[1], false);\n    }\n    expression$1.push(getFallback(parameters, propertySpec));\n    return expression$1;\n  } else if (type === 'interval') {\n    var expression$2 = ['step', ['number', get]];\n    for (var i$2 = 0, list$2 = stops; i$2 < list$2.length; i$2 += 1) {\n      var stop$2 = list$2[i$2];\n      appendStopPair(expression$2, stop$2[0], stop$2[1], true);\n    }\n    fixupDegenerateStepCurve(expression$2);\n    return parameters.default === undefined ? expression$2 : ['case', ['==', ['typeof', get], 'number'], expression$2, convertLiteral(parameters.default)];\n  } else if (type === 'exponential') {\n    var base = parameters.base !== undefined ? parameters.base : 1;\n    var expression$3 = [getInterpolateOperator(parameters), base === 1 ? ['linear'] : ['exponential', base], ['number', get]];\n    for (var i$3 = 0, list$3 = stops; i$3 < list$3.length; i$3 += 1) {\n      var stop$3 = list$3[i$3];\n      appendStopPair(expression$3, stop$3[0], stop$3[1], false);\n    }\n    return parameters.default === undefined ? expression$3 : ['case', ['==', ['typeof', get], 'number'], expression$3, convertLiteral(parameters.default)];\n  } else {\n    throw new Error(\"Unknown property function type \" + type);\n  }\n}\nfunction convertZoomFunction(parameters, propertySpec, stops, input) {\n  if (input === void 0) input = ['zoom'];\n  var type = getFunctionType(parameters, propertySpec);\n  var expression;\n  var isStep = false;\n  if (type === 'interval') {\n    expression = ['step', input];\n    isStep = true;\n  } else if (type === 'exponential') {\n    var base = parameters.base !== undefined ? parameters.base : 1;\n    expression = [getInterpolateOperator(parameters), base === 1 ? ['linear'] : ['exponential', base], input];\n  } else {\n    throw new Error(\"Unknown zoom function type \\\"\" + type + \"\\\"\");\n  }\n  for (var i = 0, list = stops; i < list.length; i += 1) {\n    var stop = list[i];\n    appendStopPair(expression, stop[0], stop[1], isStep);\n  }\n  fixupDegenerateStepCurve(expression);\n  return expression;\n}\nfunction fixupDegenerateStepCurve(expression) {\n  // degenerate step curve (i.e. a constant function): add a noop stop\n  if (expression[0] === 'step' && expression.length === 3) {\n    expression.push(0);\n    expression.push(expression[3]);\n  }\n}\nfunction appendStopPair(curve, input, output, isStep) {\n  // Skip duplicate stop values. They were not validated for functions, but they are for expressions.\n  // https://github.com/mapbox/mapbox-gl-js/issues/4107\n  if (curve.length > 3 && input === curve[curve.length - 2]) {\n    return;\n  }\n  // step curves don't get the first input value, as it is redundant.\n  if (!(isStep && curve.length === 2)) {\n    curve.push(input);\n  }\n  curve.push(output);\n}\nfunction getFunctionType(parameters, propertySpec) {\n  if (parameters.type) {\n    return parameters.type;\n  } else {\n    return propertySpec.expression.interpolated ? 'exponential' : 'interval';\n  }\n}\n// \"String with {name} token\" => [\"concat\", \"String with \", [\"get\", \"name\"], \" token\"]\nfunction convertTokenString(s) {\n  var result = ['concat'];\n  var re = /{([^{}]+)}/g;\n  var pos = 0;\n  for (var match = re.exec(s); match !== null; match = re.exec(s)) {\n    var literal = s.slice(pos, re.lastIndex - match[0].length);\n    pos = re.lastIndex;\n    if (literal.length > 0) {\n      result.push(literal);\n    }\n    result.push(['get', match[1]]);\n  }\n  if (result.length === 1) {\n    return s;\n  }\n  if (pos < s.length) {\n    result.push(s.slice(pos));\n  } else if (result.length === 2) {\n    return ['to-string', result[1]];\n  }\n  return result;\n}\n\n//      \nvar ParsingError = /*@__PURE__*/function (Error) {\n  function ParsingError(key, message) {\n    Error.call(this, message);\n    this.message = message;\n    this.key = key;\n  }\n  if (Error) ParsingError.__proto__ = Error;\n  ParsingError.prototype = Object.create(Error && Error.prototype);\n  ParsingError.prototype.constructor = ParsingError;\n  return ParsingError;\n}(Error);\nvar ParsingError$1 = ParsingError;\n\n//      \n/**\n * Tracks `let` bindings during expression parsing.\n * @private\n */\nvar Scope = function Scope(parent, bindings) {\n  if (bindings === void 0) bindings = [];\n  this.parent = parent;\n  this.bindings = {};\n  for (var i = 0, list = bindings; i < list.length; i += 1) {\n    var ref = list[i];\n    var name = ref[0];\n    var expression = ref[1];\n    this.bindings[name] = expression;\n  }\n};\nScope.prototype.concat = function concat(bindings) {\n  return new Scope(this, bindings);\n};\nScope.prototype.get = function get(name) {\n  if (this.bindings[name]) {\n    return this.bindings[name];\n  }\n  if (this.parent) {\n    return this.parent.get(name);\n  }\n  throw new Error(name + \" not found in scope.\");\n};\nScope.prototype.has = function has(name) {\n  if (this.bindings[name]) {\n    return true;\n  }\n  return this.parent ? this.parent.has(name) : false;\n};\nvar Scope$1 = Scope;\n\n//      \nvar NullType = {\n  kind: 'null'\n};\nvar NumberType = {\n  kind: 'number'\n};\nvar StringType = {\n  kind: 'string'\n};\nvar BooleanType = {\n  kind: 'boolean'\n};\nvar ColorType = {\n  kind: 'color'\n};\nvar ObjectType = {\n  kind: 'object'\n};\nvar ValueType = {\n  kind: 'value'\n};\nvar ErrorType = {\n  kind: 'error'\n};\nvar CollatorType = {\n  kind: 'collator'\n};\nvar FormattedType = {\n  kind: 'formatted'\n};\nvar ResolvedImageType = {\n  kind: 'resolvedImage'\n};\nfunction array$1(itemType, N) {\n  return {\n    kind: 'array',\n    itemType: itemType,\n    N: N\n  };\n}\nfunction toString$1(type) {\n  if (type.kind === 'array') {\n    var itemType = toString$1(type.itemType);\n    return typeof type.N === 'number' ? \"array<\" + itemType + \", \" + type.N + \">\" : type.itemType.kind === 'value' ? 'array' : \"array<\" + itemType + \">\";\n  } else {\n    return type.kind;\n  }\n}\nvar valueMemberTypes = [NullType, NumberType, StringType, BooleanType, ColorType, FormattedType, ObjectType, array$1(ValueType), ResolvedImageType];\n/**\n * Returns null if `t` is a subtype of `expected`; otherwise returns an\n * error message.\n * @private\n */\nfunction checkSubtype(expected, t) {\n  if (t.kind === 'error') {\n    // Error is a subtype of every type\n    return null;\n  } else if (expected.kind === 'array') {\n    if (t.kind === 'array' && (t.N === 0 && t.itemType.kind === 'value' || !checkSubtype(expected.itemType, t.itemType)) && (typeof expected.N !== 'number' || expected.N === t.N)) {\n      return null;\n    }\n  } else if (expected.kind === t.kind) {\n    return null;\n  } else if (expected.kind === 'value') {\n    for (var i = 0, list = valueMemberTypes; i < list.length; i += 1) {\n      var memberType = list[i];\n      if (!checkSubtype(memberType, t)) {\n        return null;\n      }\n    }\n  }\n  return \"Expected \" + toString$1(expected) + \" but found \" + toString$1(t) + \" instead.\";\n}\nfunction isValidType(provided, allowedTypes) {\n  return allowedTypes.some(function (t) {\n    return t.kind === provided.kind;\n  });\n}\nfunction isValidNativeType(provided, allowedTypes) {\n  return allowedTypes.some(function (t) {\n    if (t === 'null') {\n      return provided === null;\n    } else if (t === 'array') {\n      return Array.isArray(provided);\n    } else if (t === 'object') {\n      return provided && !Array.isArray(provided) && typeof provided === 'object';\n    } else {\n      return t === typeof provided;\n    }\n  });\n}\n\n//      \n// Flow type declarations for Intl cribbed from\n// https://github.com/facebook/flow/issues/1270\nvar Collator = function Collator(caseSensitive, diacriticSensitive, locale) {\n  if (caseSensitive) {\n    this.sensitivity = diacriticSensitive ? 'variant' : 'case';\n  } else {\n    this.sensitivity = diacriticSensitive ? 'accent' : 'base';\n  }\n  this.locale = locale;\n  this.collator = new Intl.Collator(this.locale ? this.locale : [], {\n    sensitivity: this.sensitivity,\n    usage: 'search'\n  });\n};\nCollator.prototype.compare = function compare(lhs, rhs) {\n  return this.collator.compare(lhs, rhs);\n};\nCollator.prototype.resolvedLocale = function resolvedLocale() {\n  // We create a Collator without \"usage: search\" because we don't want\n  // the search options encoded in our result (e.g. \"en-u-co-search\")\n  return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;\n};\nvar Collator$1 = Collator;\n\n//      \nvar FormattedSection = function FormattedSection(text, image, scale, fontStack, textColor) {\n  // combine characters so that diacritic marks are not separate code points\n  this.text = text.normalize ? text.normalize() : text;\n  this.image = image;\n  this.scale = scale;\n  this.fontStack = fontStack;\n  this.textColor = textColor;\n};\nvar Formatted = function Formatted(sections) {\n  this.sections = sections;\n};\nFormatted.fromString = function fromString(unformatted) {\n  return new Formatted([new FormattedSection(unformatted, null, null, null, null)]);\n};\nFormatted.prototype.isEmpty = function isEmpty() {\n  if (this.sections.length === 0) {\n    return true;\n  }\n  return !this.sections.some(function (section) {\n    return section.text.length !== 0 || section.image && section.image.name.length !== 0;\n  });\n};\nFormatted.factory = function factory(text) {\n  if (text instanceof Formatted) {\n    return text;\n  } else {\n    return Formatted.fromString(text);\n  }\n};\nFormatted.prototype.toString = function toString() {\n  if (this.sections.length === 0) {\n    return '';\n  }\n  return this.sections.map(function (section) {\n    return section.text;\n  }).join('');\n};\nFormatted.prototype.serialize = function serialize() {\n  var serialized = ['format'];\n  for (var i = 0, list = this.sections; i < list.length; i += 1) {\n    var section = list[i];\n    if (section.image) {\n      serialized.push(['image', section.image.name]);\n      continue;\n    }\n    serialized.push(section.text);\n    var options = {};\n    if (section.fontStack) {\n      options['text-font'] = ['literal', section.fontStack.split(',')];\n    }\n    if (section.scale) {\n      options['font-scale'] = section.scale;\n    }\n    if (section.textColor) {\n      options['text-color'] = ['rgba'].concat(section.textColor.toArray());\n    }\n    serialized.push(options);\n  }\n  return serialized;\n};\nvar Formatted$1 = Formatted;\n\n//      \nvar ResolvedImage = function ResolvedImage(options) {\n  this.name = options.name;\n  this.available = options.available;\n};\nResolvedImage.prototype.toString = function toString() {\n  return this.name;\n};\nResolvedImage.fromString = function fromString(name) {\n  if (!name) {\n    return null;\n  }\n  // treat empty values as no image\n  return new ResolvedImage({\n    name: name,\n    available: false\n  });\n};\nResolvedImage.prototype.serialize = function serialize() {\n  return ['image', this.name];\n};\nvar ResolvedImage$1 = ResolvedImage;\nfunction validateRGBA(r, g, b, a) {\n  if (!(typeof r === 'number' && r >= 0 && r <= 255 && typeof g === 'number' && g >= 0 && g <= 255 && typeof b === 'number' && b >= 0 && b <= 255)) {\n    var value = typeof a === 'number' ? [r, g, b, a] : [r, g, b];\n    return \"Invalid rgba value [\" + value.join(', ') + \"]: 'r', 'g', and 'b' must be between 0 and 255.\";\n  }\n  if (!(typeof a === 'undefined' || typeof a === 'number' && a >= 0 && a <= 1)) {\n    return \"Invalid rgba value [\" + [r, g, b, a].join(', ') + \"]: 'a' must be between 0 and 1.\";\n  }\n  return null;\n}\nfunction isValue(mixed) {\n  if (mixed === null) {\n    return true;\n  } else if (typeof mixed === 'string') {\n    return true;\n  } else if (typeof mixed === 'boolean') {\n    return true;\n  } else if (typeof mixed === 'number') {\n    return true;\n  } else if (mixed instanceof Color$1) {\n    return true;\n  } else if (mixed instanceof Collator$1) {\n    return true;\n  } else if (mixed instanceof Formatted$1) {\n    return true;\n  } else if (mixed instanceof ResolvedImage$1) {\n    return true;\n  } else if (Array.isArray(mixed)) {\n    for (var i = 0, list = mixed; i < list.length; i += 1) {\n      var item = list[i];\n      if (!isValue(item)) {\n        return false;\n      }\n    }\n    return true;\n  } else if (typeof mixed === 'object') {\n    for (var key in mixed) {\n      if (!isValue(mixed[key])) {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction typeOf(value) {\n  if (value === null) {\n    return NullType;\n  } else if (typeof value === 'string') {\n    return StringType;\n  } else if (typeof value === 'boolean') {\n    return BooleanType;\n  } else if (typeof value === 'number') {\n    return NumberType;\n  } else if (value instanceof Color$1) {\n    return ColorType;\n  } else if (value instanceof Collator$1) {\n    return CollatorType;\n  } else if (value instanceof Formatted$1) {\n    return FormattedType;\n  } else if (value instanceof ResolvedImage$1) {\n    return ResolvedImageType;\n  } else if (Array.isArray(value)) {\n    var length = value.length;\n    var itemType;\n    for (var i = 0, list = value; i < list.length; i += 1) {\n      var item = list[i];\n      var t = typeOf(item);\n      if (!itemType) {\n        itemType = t;\n      } else if (itemType === t) {\n        continue;\n      } else {\n        itemType = ValueType;\n        break;\n      }\n    }\n    return array$1(itemType || ValueType, length);\n  } else {\n    return ObjectType;\n  }\n}\nfunction toString(value) {\n  var type = typeof value;\n  if (value === null) {\n    return '';\n  } else if (type === 'string' || type === 'number' || type === 'boolean') {\n    return String(value);\n  } else if (value instanceof Color$1 || value instanceof Formatted$1 || value instanceof ResolvedImage$1) {\n    return value.toString();\n  } else {\n    return JSON.stringify(value);\n  }\n}\nvar Literal = function Literal(type, value) {\n  this.type = type;\n  this.value = value;\n};\nLiteral.parse = function parse(args, context) {\n  if (args.length !== 2) {\n    return context.error(\"'literal' expression requires exactly one argument, but found \" + (args.length - 1) + \" instead.\");\n  }\n  if (!isValue(args[1])) {\n    return context.error(\"invalid value\");\n  }\n  var value = args[1];\n  var type = typeOf(value);\n  // special case: infer the item type if possible for zero-length arrays\n  var expected = context.expectedType;\n  if (type.kind === 'array' && type.N === 0 && expected && expected.kind === 'array' && (typeof expected.N !== 'number' || expected.N === 0)) {\n    type = expected;\n  }\n  return new Literal(type, value);\n};\nLiteral.prototype.evaluate = function evaluate() {\n  return this.value;\n};\nLiteral.prototype.eachChild = function eachChild() {};\nLiteral.prototype.outputDefined = function outputDefined() {\n  return true;\n};\nLiteral.prototype.serialize = function serialize() {\n  if (this.type.kind === 'array' || this.type.kind === 'object') {\n    return ['literal', this.value];\n  } else if (this.value instanceof Color$1) {\n    // Constant-folding can generate Literal expressions that you\n    // couldn't actually generate with a \"literal\" expression,\n    // so we have to implement an equivalent serialization here\n    return ['rgba'].concat(this.value.toArray());\n  } else if (this.value instanceof Formatted$1) {\n    // Same as Color\n    return this.value.serialize();\n  } else {\n    return this.value;\n  }\n};\nvar Literal$1 = Literal;\n\n//      \nvar RuntimeError = function RuntimeError(message) {\n  this.name = 'ExpressionEvaluationError';\n  this.message = message;\n};\nRuntimeError.prototype.toJSON = function toJSON() {\n  return this.message;\n};\nvar RuntimeError$1 = RuntimeError;\nvar types$2 = {\n  string: StringType,\n  number: NumberType,\n  boolean: BooleanType,\n  object: ObjectType\n};\nvar Assertion = function Assertion(type, args) {\n  this.type = type;\n  this.args = args;\n};\nAssertion.parse = function parse(args, context) {\n  if (args.length < 2) {\n    return context.error(\"Expected at least one argument.\");\n  }\n  var i = 1;\n  var type;\n  var name = args[0];\n  if (name === 'array') {\n    var itemType;\n    if (args.length > 2) {\n      var type$1 = args[1];\n      if (typeof type$1 !== 'string' || !(type$1 in types$2) || type$1 === 'object') {\n        return context.error('The item type argument of \"array\" must be one of string, number, boolean', 1);\n      }\n      itemType = types$2[type$1];\n      i++;\n    } else {\n      itemType = ValueType;\n    }\n    var N;\n    if (args.length > 3) {\n      if (args[2] !== null && (typeof args[2] !== 'number' || args[2] < 0 || args[2] !== Math.floor(args[2]))) {\n        return context.error('The length argument to \"array\" must be a positive integer literal', 2);\n      }\n      N = args[2];\n      i++;\n    }\n    type = array$1(itemType, N);\n  } else {\n    type = types$2[name];\n  }\n  var parsed = [];\n  for (; i < args.length; i++) {\n    var input = context.parse(args[i], i, ValueType);\n    if (!input) {\n      return null;\n    }\n    parsed.push(input);\n  }\n  return new Assertion(type, parsed);\n};\nAssertion.prototype.evaluate = function evaluate(ctx) {\n  for (var i = 0; i < this.args.length; i++) {\n    var value = this.args[i].evaluate(ctx);\n    var error = checkSubtype(this.type, typeOf(value));\n    if (!error) {\n      return value;\n    } else if (i === this.args.length - 1) {\n      throw new RuntimeError$1(\"Expected value to be of type \" + toString$1(this.type) + \", but found \" + toString$1(typeOf(value)) + \" instead.\");\n    }\n  }\n  return null;\n};\nAssertion.prototype.eachChild = function eachChild(fn) {\n  this.args.forEach(fn);\n};\nAssertion.prototype.outputDefined = function outputDefined() {\n  return this.args.every(function (arg) {\n    return arg.outputDefined();\n  });\n};\nAssertion.prototype.serialize = function serialize() {\n  var type = this.type;\n  var serialized = [type.kind];\n  if (type.kind === 'array') {\n    var itemType = type.itemType;\n    if (itemType.kind === 'string' || itemType.kind === 'number' || itemType.kind === 'boolean') {\n      serialized.push(itemType.kind);\n      var N = type.N;\n      if (typeof N === 'number' || this.args.length > 1) {\n        serialized.push(N);\n      }\n    }\n  }\n  return serialized.concat(this.args.map(function (arg) {\n    return arg.serialize();\n  }));\n};\nvar Assertion$1 = Assertion;\n\n//      \nvar FormatExpression = function FormatExpression(sections) {\n  this.type = FormattedType;\n  this.sections = sections;\n};\nFormatExpression.parse = function parse(args, context) {\n  if (args.length < 2) {\n    return context.error(\"Expected at least one argument.\");\n  }\n  var firstArg = args[1];\n  if (!Array.isArray(firstArg) && typeof firstArg === 'object') {\n    return context.error(\"First argument must be an image or text section.\");\n  }\n  var sections = [];\n  var nextTokenMayBeObject = false;\n  for (var i = 1; i <= args.length - 1; ++i) {\n    var arg = args[i];\n    if (nextTokenMayBeObject && typeof arg === 'object' && !Array.isArray(arg)) {\n      nextTokenMayBeObject = false;\n      var scale = null;\n      if (arg['font-scale']) {\n        scale = context.parse(arg['font-scale'], 1, NumberType);\n        if (!scale) {\n          return null;\n        }\n      }\n      var font = null;\n      if (arg['text-font']) {\n        font = context.parse(arg['text-font'], 1, array$1(StringType));\n        if (!font) {\n          return null;\n        }\n      }\n      var textColor = null;\n      if (arg['text-color']) {\n        textColor = context.parse(arg['text-color'], 1, ColorType);\n        if (!textColor) {\n          return null;\n        }\n      }\n      var lastExpression = sections[sections.length - 1];\n      lastExpression.scale = scale;\n      lastExpression.font = font;\n      lastExpression.textColor = textColor;\n    } else {\n      var content = context.parse(args[i], 1, ValueType);\n      if (!content) {\n        return null;\n      }\n      var kind = content.type.kind;\n      if (kind !== 'string' && kind !== 'value' && kind !== 'null' && kind !== 'resolvedImage') {\n        return context.error(\"Formatted text type must be 'string', 'value', 'image' or 'null'.\");\n      }\n      nextTokenMayBeObject = true;\n      sections.push({\n        content: content,\n        scale: null,\n        font: null,\n        textColor: null\n      });\n    }\n  }\n  return new FormatExpression(sections);\n};\nFormatExpression.prototype.evaluate = function evaluate(ctx) {\n  var evaluateSection = function (section) {\n    var evaluatedContent = section.content.evaluate(ctx);\n    if (typeOf(evaluatedContent) === ResolvedImageType) {\n      return new FormattedSection('', evaluatedContent, null, null, null);\n    }\n    return new FormattedSection(toString(evaluatedContent), null, section.scale ? section.scale.evaluate(ctx) : null, section.font ? section.font.evaluate(ctx).join(',') : null, section.textColor ? section.textColor.evaluate(ctx) : null);\n  };\n  return new Formatted$1(this.sections.map(evaluateSection));\n};\nFormatExpression.prototype.eachChild = function eachChild(fn) {\n  for (var i = 0, list = this.sections; i < list.length; i += 1) {\n    var section = list[i];\n    fn(section.content);\n    if (section.scale) {\n      fn(section.scale);\n    }\n    if (section.font) {\n      fn(section.font);\n    }\n    if (section.textColor) {\n      fn(section.textColor);\n    }\n  }\n};\nFormatExpression.prototype.outputDefined = function outputDefined() {\n  // Technically the combinatoric set of all children\n  // Usually, this.text will be undefined anyway\n  return false;\n};\nFormatExpression.prototype.serialize = function serialize() {\n  var serialized = ['format'];\n  for (var i = 0, list = this.sections; i < list.length; i += 1) {\n    var section = list[i];\n    serialized.push(section.content.serialize());\n    var options = {};\n    if (section.scale) {\n      options['font-scale'] = section.scale.serialize();\n    }\n    if (section.font) {\n      options['text-font'] = section.font.serialize();\n    }\n    if (section.textColor) {\n      options['text-color'] = section.textColor.serialize();\n    }\n    serialized.push(options);\n  }\n  return serialized;\n};\nvar FormatExpression$1 = FormatExpression;\n\n//      \nvar ImageExpression = function ImageExpression(input) {\n  this.type = ResolvedImageType;\n  this.input = input;\n};\nImageExpression.parse = function parse(args, context) {\n  if (args.length !== 2) {\n    return context.error(\"Expected two arguments.\");\n  }\n  var name = context.parse(args[1], 1, StringType);\n  if (!name) {\n    return context.error(\"No image name provided.\");\n  }\n  return new ImageExpression(name);\n};\nImageExpression.prototype.evaluate = function evaluate(ctx) {\n  var evaluatedImageName = this.input.evaluate(ctx);\n  var value = ResolvedImage$1.fromString(evaluatedImageName);\n  if (value && ctx.availableImages) {\n    value.available = ctx.availableImages.indexOf(evaluatedImageName) > -1;\n  }\n  return value;\n};\nImageExpression.prototype.eachChild = function eachChild(fn) {\n  fn(this.input);\n};\nImageExpression.prototype.outputDefined = function outputDefined() {\n  // The output of image is determined by the list of available images in the evaluation context\n  return false;\n};\nImageExpression.prototype.serialize = function serialize() {\n  return ['image', this.input.serialize()];\n};\nvar ImageExpression$1 = ImageExpression;\nvar types$1 = {\n  'to-boolean': BooleanType,\n  'to-color': ColorType,\n  'to-number': NumberType,\n  'to-string': StringType\n};\n/**\n * Special form for error-coalescing coercion expressions \"to-number\",\n * \"to-color\".  Since these coercions can fail at runtime, they accept multiple\n * arguments, only evaluating one at a time until one succeeds.\n *\n * @private\n */\nvar Coercion = function Coercion(type, args) {\n  this.type = type;\n  this.args = args;\n};\nCoercion.parse = function parse(args, context) {\n  if (args.length < 2) {\n    return context.error(\"Expected at least one argument.\");\n  }\n  var name = args[0];\n  if ((name === 'to-boolean' || name === 'to-string') && args.length !== 2) {\n    return context.error(\"Expected one argument.\");\n  }\n  var type = types$1[name];\n  var parsed = [];\n  for (var i = 1; i < args.length; i++) {\n    var input = context.parse(args[i], i, ValueType);\n    if (!input) {\n      return null;\n    }\n    parsed.push(input);\n  }\n  return new Coercion(type, parsed);\n};\nCoercion.prototype.evaluate = function evaluate(ctx) {\n  if (this.type.kind === 'boolean') {\n    return Boolean(this.args[0].evaluate(ctx));\n  } else if (this.type.kind === 'color') {\n    var input;\n    var error;\n    for (var i = 0, list = this.args; i < list.length; i += 1) {\n      var arg = list[i];\n      input = arg.evaluate(ctx);\n      error = null;\n      if (input instanceof Color$1) {\n        return input;\n      } else if (typeof input === 'string') {\n        var c = ctx.parseColor(input);\n        if (c) {\n          return c;\n        }\n      } else if (Array.isArray(input)) {\n        if (input.length < 3 || input.length > 4) {\n          error = \"Invalid rbga value \" + JSON.stringify(input) + \": expected an array containing either three or four numeric values.\";\n        } else {\n          error = validateRGBA(input[0], input[1], input[2], input[3]);\n        }\n        if (!error) {\n          return new Color$1(input[0] / 255, input[1] / 255, input[2] / 255, input[3]);\n        }\n      }\n    }\n    throw new RuntimeError$1(error || \"Could not parse color from value '\" + (typeof input === 'string' ? input : String(JSON.stringify(input))) + \"'\");\n  } else if (this.type.kind === 'number') {\n    var value = null;\n    for (var i$1 = 0, list$1 = this.args; i$1 < list$1.length; i$1 += 1) {\n      var arg$1 = list$1[i$1];\n      value = arg$1.evaluate(ctx);\n      if (value === null) {\n        return 0;\n      }\n      var num = Number(value);\n      if (isNaN(num)) {\n        continue;\n      }\n      return num;\n    }\n    throw new RuntimeError$1(\"Could not convert \" + JSON.stringify(value) + \" to number.\");\n  } else if (this.type.kind === 'formatted') {\n    // There is no explicit 'to-formatted' but this coercion can be implicitly\n    // created by properties that expect the 'formatted' type.\n    return Formatted$1.fromString(toString(this.args[0].evaluate(ctx)));\n  } else if (this.type.kind === 'resolvedImage') {\n    return ResolvedImage$1.fromString(toString(this.args[0].evaluate(ctx)));\n  } else {\n    return toString(this.args[0].evaluate(ctx));\n  }\n};\nCoercion.prototype.eachChild = function eachChild(fn) {\n  this.args.forEach(fn);\n};\nCoercion.prototype.outputDefined = function outputDefined() {\n  return this.args.every(function (arg) {\n    return arg.outputDefined();\n  });\n};\nCoercion.prototype.serialize = function serialize() {\n  if (this.type.kind === 'formatted') {\n    return new FormatExpression$1([{\n      content: this.args[0],\n      scale: null,\n      font: null,\n      textColor: null\n    }]).serialize();\n  }\n  if (this.type.kind === 'resolvedImage') {\n    return new ImageExpression$1(this.args[0]).serialize();\n  }\n  var serialized = [\"to-\" + this.type.kind];\n  this.eachChild(function (child) {\n    serialized.push(child.serialize());\n  });\n  return serialized;\n};\nvar Coercion$1 = Coercion;\n\n//      \nvar geometryTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];\nvar EvaluationContext = function EvaluationContext() {\n  this.globals = null;\n  this.feature = null;\n  this.featureState = null;\n  this.formattedSection = null;\n  this._parseColorCache = {};\n  this.availableImages = null;\n  this.canonical = null;\n  this.featureTileCoord = null;\n  this.featureDistanceData = null;\n};\nEvaluationContext.prototype.id = function id() {\n  return this.feature && this.feature.id !== undefined ? this.feature.id : null;\n};\nEvaluationContext.prototype.geometryType = function geometryType() {\n  return this.feature ? typeof this.feature.type === 'number' ? geometryTypes[this.feature.type] : this.feature.type : null;\n};\nEvaluationContext.prototype.geometry = function geometry() {\n  return this.feature && 'geometry' in this.feature ? this.feature.geometry : null;\n};\nEvaluationContext.prototype.canonicalID = function canonicalID() {\n  return this.canonical;\n};\nEvaluationContext.prototype.properties = function properties() {\n  return this.feature && this.feature.properties || {};\n};\nEvaluationContext.prototype.distanceFromCenter = function distanceFromCenter() {\n  if (this.featureTileCoord && this.featureDistanceData) {\n    var c = this.featureDistanceData.center;\n    var scale = this.featureDistanceData.scale;\n    var ref = this.featureTileCoord;\n    var x = ref.x;\n    var y = ref.y;\n    // Calculate the distance vector `d` (left handed)\n    var dX = x * scale - c[0];\n    var dY = y * scale - c[1];\n    // The bearing vector `b` (left handed)\n    var bX = this.featureDistanceData.bearing[0];\n    var bY = this.featureDistanceData.bearing[1];\n    // Distance is calculated as `dot(d, v)`\n    var dist = bX * dX + bY * dY;\n    return dist;\n  }\n  return 0;\n};\nEvaluationContext.prototype.parseColor = function parseColor(input) {\n  var cached = this._parseColorCache[input];\n  if (!cached) {\n    cached = this._parseColorCache[input] = Color$1.parse(input);\n  }\n  return cached;\n};\nvar EvaluationContext$1 = EvaluationContext;\n\n//      \nvar CompoundExpression = function CompoundExpression(name, type, evaluate, args) {\n  this.name = name;\n  this.type = type;\n  this._evaluate = evaluate;\n  this.args = args;\n};\nCompoundExpression.prototype.evaluate = function evaluate(ctx) {\n  return this._evaluate(ctx, this.args);\n};\nCompoundExpression.prototype.eachChild = function eachChild(fn) {\n  this.args.forEach(fn);\n};\nCompoundExpression.prototype.outputDefined = function outputDefined() {\n  return false;\n};\nCompoundExpression.prototype.serialize = function serialize() {\n  return [this.name].concat(this.args.map(function (arg) {\n    return arg.serialize();\n  }));\n};\nCompoundExpression.parse = function parse(args, context) {\n  var ref$1;\n  var op = args[0];\n  var definition = CompoundExpression.definitions[op];\n  if (!definition) {\n    return context.error(\"Unknown expression \\\"\" + op + \"\\\". If you wanted a literal array, use [\\\"literal\\\", [...]].\", 0);\n  }\n  // Now check argument types against each signature\n  var type = Array.isArray(definition) ? definition[0] : definition.type;\n  var availableOverloads = Array.isArray(definition) ? [[definition[1], definition[2]]] : definition.overloads;\n  var overloads = availableOverloads.filter(function (ref) {\n    var signature = ref[0];\n    return !Array.isArray(signature) ||\n    // varags\n    signature.length === args.length - 1;\n  } // correct param count\n  );\n\n  var signatureContext = null;\n  for (var i$3 = 0, list = overloads; i$3 < list.length; i$3 += 1) {\n    // Use a fresh context for each attempted signature so that, if\n    // we eventually succeed, we haven't polluted `context.errors`.\n    var ref = list[i$3];\n    var params = ref[0];\n    var evaluate = ref[1];\n    signatureContext = new ParsingContext$1(context.registry, context.path, null, context.scope);\n    // First parse all the args, potentially coercing to the\n    // types expected by this overload.\n    var parsedArgs = [];\n    var argParseFailed = false;\n    for (var i = 1; i < args.length; i++) {\n      var arg = args[i];\n      var expectedType = Array.isArray(params) ? params[i - 1] : params.type;\n      var parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);\n      if (!parsed) {\n        argParseFailed = true;\n        break;\n      }\n      parsedArgs.push(parsed);\n    }\n    if (argParseFailed) {\n      // Couldn't coerce args of this overload to expected type, move\n      // on to next one.\n      continue;\n    }\n    if (Array.isArray(params)) {\n      if (params.length !== parsedArgs.length) {\n        signatureContext.error(\"Expected \" + params.length + \" arguments, but found \" + parsedArgs.length + \" instead.\");\n        continue;\n      }\n    }\n    for (var i$1 = 0; i$1 < parsedArgs.length; i$1++) {\n      var expected = Array.isArray(params) ? params[i$1] : params.type;\n      var arg$1 = parsedArgs[i$1];\n      signatureContext.concat(i$1 + 1).checkSubtype(expected, arg$1.type);\n    }\n    if (signatureContext.errors.length === 0) {\n      return new CompoundExpression(op, type, evaluate, parsedArgs);\n    }\n  }\n  if (overloads.length === 1) {\n    (ref$1 = context.errors).push.apply(ref$1, signatureContext.errors);\n  } else {\n    var expected$1 = overloads.length ? overloads : availableOverloads;\n    var signatures = expected$1.map(function (ref) {\n      var params = ref[0];\n      return stringifySignature(params);\n    }).join(' | ');\n    var actualTypes = [];\n    // For error message, re-parse arguments without trying to\n    // apply any coercions\n    for (var i$2 = 1; i$2 < args.length; i$2++) {\n      var parsed$1 = context.parse(args[i$2], 1 + actualTypes.length);\n      if (!parsed$1) {\n        return null;\n      }\n      actualTypes.push(toString$1(parsed$1.type));\n    }\n    context.error(\"Expected arguments of type \" + signatures + \", but found (\" + actualTypes.join(', ') + \") instead.\");\n  }\n  return null;\n};\nCompoundExpression.register = function register(registry, definitions) {\n  CompoundExpression.definitions = definitions;\n  for (var name in definitions) {\n    registry[name] = CompoundExpression;\n  }\n};\nfunction stringifySignature(signature) {\n  if (Array.isArray(signature)) {\n    return \"(\" + signature.map(toString$1).join(', ') + \")\";\n  } else {\n    return \"(\" + toString$1(signature.type) + \"...)\";\n  }\n}\nvar CompoundExpression$1 = CompoundExpression;\n\n//      \nvar CollatorExpression = function CollatorExpression(caseSensitive, diacriticSensitive, locale) {\n  this.type = CollatorType;\n  this.locale = locale;\n  this.caseSensitive = caseSensitive;\n  this.diacriticSensitive = diacriticSensitive;\n};\nCollatorExpression.parse = function parse(args, context) {\n  if (args.length !== 2) {\n    return context.error(\"Expected one argument.\");\n  }\n  var options = args[1];\n  if (typeof options !== 'object' || Array.isArray(options)) {\n    return context.error(\"Collator options argument must be an object.\");\n  }\n  var caseSensitive = context.parse(options['case-sensitive'] === undefined ? false : options['case-sensitive'], 1, BooleanType);\n  if (!caseSensitive) {\n    return null;\n  }\n  var diacriticSensitive = context.parse(options['diacritic-sensitive'] === undefined ? false : options['diacritic-sensitive'], 1, BooleanType);\n  if (!diacriticSensitive) {\n    return null;\n  }\n  var locale = null;\n  if (options['locale']) {\n    locale = context.parse(options['locale'], 1, StringType);\n    if (!locale) {\n      return null;\n    }\n  }\n  return new CollatorExpression(caseSensitive, diacriticSensitive, locale);\n};\nCollatorExpression.prototype.evaluate = function evaluate(ctx) {\n  return new Collator$1(this.caseSensitive.evaluate(ctx), this.diacriticSensitive.evaluate(ctx), this.locale ? this.locale.evaluate(ctx) : null);\n};\nCollatorExpression.prototype.eachChild = function eachChild(fn) {\n  fn(this.caseSensitive);\n  fn(this.diacriticSensitive);\n  if (this.locale) {\n    fn(this.locale);\n  }\n};\nCollatorExpression.prototype.outputDefined = function outputDefined() {\n  // Technically the set of possible outputs is the combinatoric set of Collators produced\n  // by all possible outputs of locale/caseSensitive/diacriticSensitive\n  // But for the primary use of Collators in comparison operators, we ignore the Collator's\n  // possible outputs anyway, so we can get away with leaving this false for now.\n  return false;\n};\nCollatorExpression.prototype.serialize = function serialize() {\n  var options = {};\n  options['case-sensitive'] = this.caseSensitive.serialize();\n  options['diacritic-sensitive'] = this.diacriticSensitive.serialize();\n  if (this.locale) {\n    options['locale'] = this.locale.serialize();\n  }\n  return ['collator', options];\n};\nvar CollatorExpression$1 = CollatorExpression;\n\n//      \n// minX, minY, maxX, maxY\nvar EXTENT = 8192;\nfunction updateBBox(bbox, coord) {\n  bbox[0] = Math.min(bbox[0], coord[0]);\n  bbox[1] = Math.min(bbox[1], coord[1]);\n  bbox[2] = Math.max(bbox[2], coord[0]);\n  bbox[3] = Math.max(bbox[3], coord[1]);\n}\nfunction mercatorXfromLng(lng) {\n  return (180 + lng) / 360;\n}\nfunction mercatorYfromLat(lat) {\n  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;\n}\nfunction boxWithinBox(bbox1, bbox2) {\n  if (bbox1[0] <= bbox2[0]) {\n    return false;\n  }\n  if (bbox1[2] >= bbox2[2]) {\n    return false;\n  }\n  if (bbox1[1] <= bbox2[1]) {\n    return false;\n  }\n  if (bbox1[3] >= bbox2[3]) {\n    return false;\n  }\n  return true;\n}\nfunction getTileCoordinates(p, canonical) {\n  var x = mercatorXfromLng(p[0]);\n  var y = mercatorYfromLat(p[1]);\n  var tilesAtZoom = Math.pow(2, canonical.z);\n  return [Math.round(x * tilesAtZoom * EXTENT), Math.round(y * tilesAtZoom * EXTENT)];\n}\nfunction onBoundary(p, p1, p2) {\n  var x1 = p[0] - p1[0];\n  var y1 = p[1] - p1[1];\n  var x2 = p[0] - p2[0];\n  var y2 = p[1] - p2[1];\n  return x1 * y2 - x2 * y1 === 0 && x1 * x2 <= 0 && y1 * y2 <= 0;\n}\nfunction rayIntersect(p, p1, p2) {\n  return p1[1] > p[1] !== p2[1] > p[1] && p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0];\n}\n// ray casting algorithm for detecting if point is in polygon\nfunction pointWithinPolygon(point, rings) {\n  var inside = false;\n  for (var i = 0, len = rings.length; i < len; i++) {\n    var ring = rings[i];\n    for (var j = 0, len2 = ring.length; j < len2 - 1; j++) {\n      if (onBoundary(point, ring[j], ring[j + 1])) {\n        return false;\n      }\n      if (rayIntersect(point, ring[j], ring[j + 1])) {\n        inside = !inside;\n      }\n    }\n  }\n  return inside;\n}\nfunction pointWithinPolygons(point, polygons) {\n  for (var i = 0; i < polygons.length; i++) {\n    if (pointWithinPolygon(point, polygons[i])) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction perp(v1, v2) {\n  return v1[0] * v2[1] - v1[1] * v2[0];\n}\n// check if p1 and p2 are in different sides of line segment q1->q2\nfunction twoSided(p1, p2, q1, q2) {\n  // q1->p1 (x1, y1), q1->p2 (x2, y2), q1->q2 (x3, y3)\n  var x1 = p1[0] - q1[0];\n  var y1 = p1[1] - q1[1];\n  var x2 = p2[0] - q1[0];\n  var y2 = p2[1] - q1[1];\n  var x3 = q2[0] - q1[0];\n  var y3 = q2[1] - q1[1];\n  var det1 = x1 * y3 - x3 * y1;\n  var det2 = x2 * y3 - x3 * y2;\n  if (det1 > 0 && det2 < 0 || det1 < 0 && det2 > 0) {\n    return true;\n  }\n  return false;\n}\n// a, b are end points for line segment1, c and d are end points for line segment2\nfunction lineIntersectLine(a, b, c, d) {\n  // check if two segments are parallel or not\n  // precondition is end point a, b is inside polygon, if line a->b is\n  // parallel to polygon edge c->d, then a->b won't intersect with c->d\n  var vectorP = [b[0] - a[0], b[1] - a[1]];\n  var vectorQ = [d[0] - c[0], d[1] - c[1]];\n  if (perp(vectorQ, vectorP) === 0) {\n    return false;\n  }\n  // If lines are intersecting with each other, the relative location should be:\n  // a and b lie in different sides of segment c->d\n  // c and d lie in different sides of segment a->b\n  if (twoSided(a, b, c, d) && twoSided(c, d, a, b)) {\n    return true;\n  }\n  return false;\n}\nfunction lineIntersectPolygon(p1, p2, polygon) {\n  for (var i = 0, list = polygon; i < list.length; i += 1) {\n    // loop through every edge of the ring\n    var ring = list[i];\n    for (var j = 0; j < ring.length - 1; ++j) {\n      if (lineIntersectLine(p1, p2, ring[j], ring[j + 1])) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction lineStringWithinPolygon(line, polygon) {\n  // First, check if geometry points of line segments are all inside polygon\n  for (var i = 0; i < line.length; ++i) {\n    if (!pointWithinPolygon(line[i], polygon)) {\n      return false;\n    }\n  }\n  // Second, check if there is line segment intersecting polygon edge\n  for (var i$1 = 0; i$1 < line.length - 1; ++i$1) {\n    if (lineIntersectPolygon(line[i$1], line[i$1 + 1], polygon)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction lineStringWithinPolygons(line, polygons) {\n  for (var i = 0; i < polygons.length; i++) {\n    if (lineStringWithinPolygon(line, polygons[i])) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getTilePolygon(coordinates, bbox, canonical) {\n  var polygon = [];\n  for (var i = 0; i < coordinates.length; i++) {\n    var ring = [];\n    for (var j = 0; j < coordinates[i].length; j++) {\n      var coord = getTileCoordinates(coordinates[i][j], canonical);\n      updateBBox(bbox, coord);\n      ring.push(coord);\n    }\n    polygon.push(ring);\n  }\n  return polygon;\n}\nfunction getTilePolygons(coordinates, bbox, canonical) {\n  var polygons = [];\n  for (var i = 0; i < coordinates.length; i++) {\n    var polygon = getTilePolygon(coordinates[i], bbox, canonical);\n    polygons.push(polygon);\n  }\n  return polygons;\n}\nfunction updatePoint(p, bbox, polyBBox, worldSize) {\n  if (p[0] < polyBBox[0] || p[0] > polyBBox[2]) {\n    var halfWorldSize = worldSize * 0.5;\n    var shift = p[0] - polyBBox[0] > halfWorldSize ? -worldSize : polyBBox[0] - p[0] > halfWorldSize ? worldSize : 0;\n    if (shift === 0) {\n      shift = p[0] - polyBBox[2] > halfWorldSize ? -worldSize : polyBBox[2] - p[0] > halfWorldSize ? worldSize : 0;\n    }\n    p[0] += shift;\n  }\n  updateBBox(bbox, p);\n}\nfunction resetBBox(bbox) {\n  bbox[0] = bbox[1] = Infinity;\n  bbox[2] = bbox[3] = -Infinity;\n}\nfunction getTilePoints(geometry, pointBBox, polyBBox, canonical) {\n  var worldSize = Math.pow(2, canonical.z) * EXTENT;\n  var shifts = [canonical.x * EXTENT, canonical.y * EXTENT];\n  var tilePoints = [];\n  if (!geometry) {\n    return tilePoints;\n  }\n  for (var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1) {\n    var points = list$1[i$1];\n    for (var i = 0, list = points; i < list.length; i += 1) {\n      var point = list[i];\n      var p = [point.x + shifts[0], point.y + shifts[1]];\n      updatePoint(p, pointBBox, polyBBox, worldSize);\n      tilePoints.push(p);\n    }\n  }\n  return tilePoints;\n}\nfunction getTileLines(geometry, lineBBox, polyBBox, canonical) {\n  var worldSize = Math.pow(2, canonical.z) * EXTENT;\n  var shifts = [canonical.x * EXTENT, canonical.y * EXTENT];\n  var tileLines = [];\n  if (!geometry) {\n    return tileLines;\n  }\n  for (var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1) {\n    var line = list$1[i$1];\n    var tileLine = [];\n    for (var i = 0, list = line; i < list.length; i += 1) {\n      var point = list[i];\n      var p = [point.x + shifts[0], point.y + shifts[1]];\n      updateBBox(lineBBox, p);\n      tileLine.push(p);\n    }\n    tileLines.push(tileLine);\n  }\n  if (lineBBox[2] - lineBBox[0] <= worldSize / 2) {\n    resetBBox(lineBBox);\n    for (var i$3 = 0, list$3 = tileLines; i$3 < list$3.length; i$3 += 1) {\n      var line$1 = list$3[i$3];\n      for (var i$2 = 0, list$2 = line$1; i$2 < list$2.length; i$2 += 1) {\n        var p$1 = list$2[i$2];\n        updatePoint(p$1, lineBBox, polyBBox, worldSize);\n      }\n    }\n  }\n  return tileLines;\n}\nfunction pointsWithinPolygons(ctx, polygonGeometry) {\n  var pointBBox = [Infinity, Infinity, -Infinity, -Infinity];\n  var polyBBox = [Infinity, Infinity, -Infinity, -Infinity];\n  var canonical = ctx.canonicalID();\n  if (!canonical) {\n    return false;\n  }\n  if (polygonGeometry.type === 'Polygon') {\n    var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);\n    var tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);\n    if (!boxWithinBox(pointBBox, polyBBox)) {\n      return false;\n    }\n    for (var i = 0, list = tilePoints; i < list.length; i += 1) {\n      var point = list[i];\n      if (!pointWithinPolygon(point, tilePolygon)) {\n        return false;\n      }\n    }\n  }\n  if (polygonGeometry.type === 'MultiPolygon') {\n    var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);\n    var tilePoints$1 = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);\n    if (!boxWithinBox(pointBBox, polyBBox)) {\n      return false;\n    }\n    for (var i$1 = 0, list$1 = tilePoints$1; i$1 < list$1.length; i$1 += 1) {\n      var point$1 = list$1[i$1];\n      if (!pointWithinPolygons(point$1, tilePolygons)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction linesWithinPolygons(ctx, polygonGeometry) {\n  var lineBBox = [Infinity, Infinity, -Infinity, -Infinity];\n  var polyBBox = [Infinity, Infinity, -Infinity, -Infinity];\n  var canonical = ctx.canonicalID();\n  if (!canonical) {\n    return false;\n  }\n  if (polygonGeometry.type === 'Polygon') {\n    var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);\n    var tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);\n    if (!boxWithinBox(lineBBox, polyBBox)) {\n      return false;\n    }\n    for (var i = 0, list = tileLines; i < list.length; i += 1) {\n      var line = list[i];\n      if (!lineStringWithinPolygon(line, tilePolygon)) {\n        return false;\n      }\n    }\n  }\n  if (polygonGeometry.type === 'MultiPolygon') {\n    var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);\n    var tileLines$1 = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);\n    if (!boxWithinBox(lineBBox, polyBBox)) {\n      return false;\n    }\n    for (var i$1 = 0, list$1 = tileLines$1; i$1 < list$1.length; i$1 += 1) {\n      var line$1 = list$1[i$1];\n      if (!lineStringWithinPolygons(line$1, tilePolygons)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nvar Within = function Within(geojson, geometries) {\n  this.type = BooleanType;\n  this.geojson = geojson;\n  this.geometries = geometries;\n};\nWithin.parse = function parse(args, context) {\n  if (args.length !== 2) {\n    return context.error(\"'within' expression requires exactly one argument, but found \" + (args.length - 1) + \" instead.\");\n  }\n  if (isValue(args[1])) {\n    var geojson = args[1];\n    if (geojson.type === 'FeatureCollection') {\n      for (var i = 0; i < geojson.features.length; ++i) {\n        var type = geojson.features[i].geometry.type;\n        if (type === 'Polygon' || type === 'MultiPolygon') {\n          return new Within(geojson, geojson.features[i].geometry);\n        }\n      }\n    } else if (geojson.type === 'Feature') {\n      var type$1 = geojson.geometry.type;\n      if (type$1 === 'Polygon' || type$1 === 'MultiPolygon') {\n        return new Within(geojson, geojson.geometry);\n      }\n    } else if (geojson.type === 'Polygon' || geojson.type === 'MultiPolygon') {\n      return new Within(geojson, geojson);\n    }\n  }\n  return context.error(\"'within' expression requires valid geojson object that contains polygon geometry type.\");\n};\nWithin.prototype.evaluate = function evaluate(ctx) {\n  if (ctx.geometry() != null && ctx.canonicalID() != null) {\n    if (ctx.geometryType() === 'Point') {\n      return pointsWithinPolygons(ctx, this.geometries);\n    } else if (ctx.geometryType() === 'LineString') {\n      return linesWithinPolygons(ctx, this.geometries);\n    }\n  }\n  return false;\n};\nWithin.prototype.eachChild = function eachChild() {};\nWithin.prototype.outputDefined = function outputDefined() {\n  return true;\n};\nWithin.prototype.serialize = function serialize() {\n  return ['within', this.geojson];\n};\nvar Within$1 = Within;\n\n//      \nfunction isFeatureConstant(e) {\n  if (e instanceof CompoundExpression$1) {\n    if (e.name === 'get' && e.args.length === 1) {\n      return false;\n    } else if (e.name === 'feature-state') {\n      return false;\n    } else if (e.name === 'has' && e.args.length === 1) {\n      return false;\n    } else if (e.name === 'properties' || e.name === 'geometry-type' || e.name === 'id') {\n      return false;\n    } else if (/^filter-/.test(e.name)) {\n      return false;\n    }\n  }\n  if (e instanceof Within$1) {\n    return false;\n  }\n  var result = true;\n  e.eachChild(function (arg) {\n    if (result && !isFeatureConstant(arg)) {\n      result = false;\n    }\n  });\n  return result;\n}\nfunction isStateConstant(e) {\n  if (e instanceof CompoundExpression$1) {\n    if (e.name === 'feature-state') {\n      return false;\n    }\n  }\n  var result = true;\n  e.eachChild(function (arg) {\n    if (result && !isStateConstant(arg)) {\n      result = false;\n    }\n  });\n  return result;\n}\nfunction isGlobalPropertyConstant(e, properties) {\n  if (e instanceof CompoundExpression$1 && properties.indexOf(e.name) >= 0) {\n    return false;\n  }\n  var result = true;\n  e.eachChild(function (arg) {\n    if (result && !isGlobalPropertyConstant(arg, properties)) {\n      result = false;\n    }\n  });\n  return result;\n}\n\n//      \nvar Var = function Var(name, boundExpression) {\n  this.type = boundExpression.type;\n  this.name = name;\n  this.boundExpression = boundExpression;\n};\nVar.parse = function parse(args, context) {\n  if (args.length !== 2 || typeof args[1] !== 'string') {\n    return context.error(\"'var' expression requires exactly one string literal argument.\");\n  }\n  var name = args[1];\n  if (!context.scope.has(name)) {\n    return context.error(\"Unknown variable \\\"\" + name + \"\\\". Make sure \\\"\" + name + \"\\\" has been bound in an enclosing \\\"let\\\" expression before using it.\", 1);\n  }\n  return new Var(name, context.scope.get(name));\n};\nVar.prototype.evaluate = function evaluate(ctx) {\n  return this.boundExpression.evaluate(ctx);\n};\nVar.prototype.eachChild = function eachChild() {};\nVar.prototype.outputDefined = function outputDefined() {\n  return false;\n};\nVar.prototype.serialize = function serialize() {\n  return ['var', this.name];\n};\nvar Var$1 = Var;\n\n//      \n/**\n * State associated parsing at a given point in an expression tree.\n * @private\n */\nvar ParsingContext = function ParsingContext(registry, path, expectedType, scope, errors) {\n  if (path === void 0) path = [];\n  if (scope === void 0) scope = new Scope$1();\n  if (errors === void 0) errors = [];\n  this.registry = registry;\n  this.path = path;\n  this.key = path.map(function (part) {\n    return \"[\" + part + \"]\";\n  }).join('');\n  this.scope = scope;\n  this.errors = errors;\n  this.expectedType = expectedType;\n};\n/**\n * @param expr the JSON expression to parse\n * @param index the optional argument index if this expression is an argument of a parent expression that's being parsed\n * @param options\n * @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.\n * @private\n */\nParsingContext.prototype.parse = function parse(expr, index, expectedType, bindings, options) {\n  if (options === void 0) options = {};\n  if (index) {\n    return this.concat(index, expectedType, bindings)._parse(expr, options);\n  }\n  return this._parse(expr, options);\n};\nParsingContext.prototype._parse = function _parse(expr, options) {\n  if (expr === null || typeof expr === 'string' || typeof expr === 'boolean' || typeof expr === 'number') {\n    expr = ['literal', expr];\n  }\n  function annotate(parsed, type, typeAnnotation) {\n    if (typeAnnotation === 'assert') {\n      return new Assertion$1(type, [parsed]);\n    } else if (typeAnnotation === 'coerce') {\n      return new Coercion$1(type, [parsed]);\n    } else {\n      return parsed;\n    }\n  }\n  if (Array.isArray(expr)) {\n    if (expr.length === 0) {\n      return this.error(\"Expected an array with at least one element. If you wanted a literal array, use [\\\"literal\\\", []].\");\n    }\n    var op = expr[0];\n    if (typeof op !== 'string') {\n      this.error(\"Expression name must be a string, but found \" + typeof op + \" instead. If you wanted a literal array, use [\\\"literal\\\", [...]].\", 0);\n      return null;\n    }\n    var Expr = this.registry[op];\n    if (Expr) {\n      var parsed = Expr.parse(expr, this);\n      if (!parsed) {\n        return null;\n      }\n      if (this.expectedType) {\n        var expected = this.expectedType;\n        var actual = parsed.type;\n        // When we expect a number, string, boolean, or array but have a value, wrap it in an assertion.\n        // When we expect a color or formatted string, but have a string or value, wrap it in a coercion.\n        // Otherwise, we do static type-checking.\n        //\n        // These behaviors are overridable for:\n        //   * The \"coalesce\" operator, which needs to omit type annotations.\n        //   * String-valued properties (e.g. `text-field`), where coercion is more convenient than assertion.\n        //\n        if ((expected.kind === 'string' || expected.kind === 'number' || expected.kind === 'boolean' || expected.kind === 'object' || expected.kind === 'array') && actual.kind === 'value') {\n          parsed = annotate(parsed, expected, options.typeAnnotation || 'assert');\n        } else if ((expected.kind === 'color' || expected.kind === 'formatted' || expected.kind === 'resolvedImage') && (actual.kind === 'value' || actual.kind === 'string')) {\n          parsed = annotate(parsed, expected, options.typeAnnotation || 'coerce');\n        } else if (this.checkSubtype(expected, actual)) {\n          return null;\n        }\n      }\n      // If an expression's arguments are all literals, we can evaluate\n      // it immediately and replace it with a literal value in the\n      // parsed/compiled result. Expressions that expect an image should\n      // not be resolved here so we can later get the available images.\n      if (!(parsed instanceof Literal$1) && parsed.type.kind !== 'resolvedImage' && isConstant(parsed)) {\n        var ec = new EvaluationContext$1();\n        try {\n          parsed = new Literal$1(parsed.type, parsed.evaluate(ec));\n        } catch (e) {\n          this.error(e.message);\n          return null;\n        }\n      }\n      return parsed;\n    }\n    return this.error(\"Unknown expression \\\"\" + op + \"\\\". If you wanted a literal array, use [\\\"literal\\\", [...]].\", 0);\n  } else if (typeof expr === 'undefined') {\n    return this.error(\"'undefined' value invalid. Use null instead.\");\n  } else if (typeof expr === 'object') {\n    return this.error(\"Bare objects invalid. Use [\\\"literal\\\", {...}] instead.\");\n  } else {\n    return this.error(\"Expected an array, but found \" + typeof expr + \" instead.\");\n  }\n};\n/**\n * Returns a copy of this context suitable for parsing the subexpression at\n * index `index`, optionally appending to 'let' binding map.\n *\n * Note that `errors` property, intended for collecting errors while\n * parsing, is copied by reference rather than cloned.\n * @private\n */\nParsingContext.prototype.concat = function concat(index, expectedType, bindings) {\n  var path = typeof index === 'number' ? this.path.concat(index) : this.path;\n  var scope = bindings ? this.scope.concat(bindings) : this.scope;\n  return new ParsingContext(this.registry, path, expectedType || null, scope, this.errors);\n};\n/**\n * Push a parsing (or type checking) error into the `this.errors`\n * @param error The message\n * @param keys Optionally specify the source of the error at a child\n * of the current expression at `this.key`.\n * @private\n */\nParsingContext.prototype.error = function error(error$1) {\n  var keys = [],\n    len = arguments.length - 1;\n  while (len-- > 0) keys[len] = arguments[len + 1];\n  var key = \"\" + this.key + keys.map(function (k) {\n    return \"[\" + k + \"]\";\n  }).join('');\n  this.errors.push(new ParsingError$1(key, error$1));\n};\n/**\n * Returns null if `t` is a subtype of `expected`; otherwise returns an\n * error message and also pushes it to `this.errors`.\n */\nParsingContext.prototype.checkSubtype = function checkSubtype$1(expected, t) {\n  var error = checkSubtype(expected, t);\n  if (error) {\n    this.error(error);\n  }\n  return error;\n};\nvar ParsingContext$1 = ParsingContext;\nfunction isConstant(expression) {\n  if (expression instanceof Var$1) {\n    return isConstant(expression.boundExpression);\n  } else if (expression instanceof CompoundExpression$1 && expression.name === 'error') {\n    return false;\n  } else if (expression instanceof CollatorExpression$1) {\n    // Although the results of a Collator expression with fixed arguments\n    // generally shouldn't change between executions, we can't serialize them\n    // as constant expressions because results change based on environment.\n    return false;\n  } else if (expression instanceof Within$1) {\n    return false;\n  }\n  var isTypeAnnotation = expression instanceof Coercion$1 || expression instanceof Assertion$1;\n  var childrenConstant = true;\n  expression.eachChild(function (child) {\n    // We can _almost_ assume that if `expressions` children are constant,\n    // they would already have been evaluated to Literal values when they\n    // were parsed.  Type annotations are the exception, because they might\n    // have been inferred and added after a child was parsed.\n    // So we recurse into isConstant() for the children of type annotations,\n    // but otherwise simply check whether they are Literals.\n    if (isTypeAnnotation) {\n      childrenConstant = childrenConstant && isConstant(child);\n    } else {\n      childrenConstant = childrenConstant && child instanceof Literal$1;\n    }\n  });\n  if (!childrenConstant) {\n    return false;\n  }\n  return isFeatureConstant(expression) && isGlobalPropertyConstant(expression, ['zoom', 'heatmap-density', 'line-progress', 'sky-radial-progress', 'accumulated', 'is-supported-script', 'pitch', 'distance-from-center']);\n}\n\n//      \n/**\n * Returns the index of the last stop <= input, or 0 if it doesn't exist.\n * @private\n */\nfunction findStopLessThanOrEqualTo(stops, input) {\n  var lastIndex = stops.length - 1;\n  var lowerIndex = 0;\n  var upperIndex = lastIndex;\n  var currentIndex = 0;\n  var currentValue, nextValue;\n  while (lowerIndex <= upperIndex) {\n    currentIndex = Math.floor((lowerIndex + upperIndex) / 2);\n    currentValue = stops[currentIndex];\n    nextValue = stops[currentIndex + 1];\n    if (currentValue <= input) {\n      if (currentIndex === lastIndex || input < nextValue) {\n        // Search complete\n        return currentIndex;\n      }\n      lowerIndex = currentIndex + 1;\n    } else if (currentValue > input) {\n      upperIndex = currentIndex - 1;\n    } else {\n      throw new RuntimeError$1('Input is not a number.');\n    }\n  }\n  return 0;\n}\n\n//      \nvar Step = function Step(type, input, stops) {\n  this.type = type;\n  this.input = input;\n  this.labels = [];\n  this.outputs = [];\n  for (var i = 0, list = stops; i < list.length; i += 1) {\n    var ref = list[i];\n    var label = ref[0];\n    var expression = ref[1];\n    this.labels.push(label);\n    this.outputs.push(expression);\n  }\n};\nStep.parse = function parse(args, context) {\n  if (args.length - 1 < 4) {\n    return context.error(\"Expected at least 4 arguments, but found only \" + (args.length - 1) + \".\");\n  }\n  if ((args.length - 1) % 2 !== 0) {\n    return context.error(\"Expected an even number of arguments.\");\n  }\n  var input = context.parse(args[1], 1, NumberType);\n  if (!input) {\n    return null;\n  }\n  var stops = [];\n  var outputType = null;\n  if (context.expectedType && context.expectedType.kind !== 'value') {\n    outputType = context.expectedType;\n  }\n  for (var i = 1; i < args.length; i += 2) {\n    var label = i === 1 ? -Infinity : args[i];\n    var value = args[i + 1];\n    var labelKey = i;\n    var valueKey = i + 1;\n    if (typeof label !== 'number') {\n      return context.error('Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);\n    }\n    if (stops.length && stops[stops.length - 1][0] >= label) {\n      return context.error('Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.', labelKey);\n    }\n    var parsed = context.parse(value, valueKey, outputType);\n    if (!parsed) {\n      return null;\n    }\n    outputType = outputType || parsed.type;\n    stops.push([label, parsed]);\n  }\n  return new Step(outputType, input, stops);\n};\nStep.prototype.evaluate = function evaluate(ctx) {\n  var labels = this.labels;\n  var outputs = this.outputs;\n  if (labels.length === 1) {\n    return outputs[0].evaluate(ctx);\n  }\n  var value = this.input.evaluate(ctx);\n  if (value <= labels[0]) {\n    return outputs[0].evaluate(ctx);\n  }\n  var stopCount = labels.length;\n  if (value >= labels[stopCount - 1]) {\n    return outputs[stopCount - 1].evaluate(ctx);\n  }\n  var index = findStopLessThanOrEqualTo(labels, value);\n  return outputs[index].evaluate(ctx);\n};\nStep.prototype.eachChild = function eachChild(fn) {\n  fn(this.input);\n  for (var i = 0, list = this.outputs; i < list.length; i += 1) {\n    var expression = list[i];\n    fn(expression);\n  }\n};\nStep.prototype.outputDefined = function outputDefined() {\n  return this.outputs.every(function (out) {\n    return out.outputDefined();\n  });\n};\nStep.prototype.serialize = function serialize() {\n  var serialized = ['step', this.input.serialize()];\n  for (var i = 0; i < this.labels.length; i++) {\n    if (i > 0) {\n      serialized.push(this.labels[i]);\n    }\n    serialized.push(this.outputs[i].serialize());\n  }\n  return serialized;\n};\nvar Step$1 = Step;\n\n/*\n * Copyright (C) 2008 Apple Inc. All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Ported from Webkit\n * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h\n */\n\nvar unitbezier = UnitBezier;\nfunction UnitBezier(p1x, p1y, p2x, p2y) {\n  // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).\n  this.cx = 3 * p1x;\n  this.bx = 3 * (p2x - p1x) - this.cx;\n  this.ax = 1 - this.cx - this.bx;\n  this.cy = 3 * p1y;\n  this.by = 3 * (p2y - p1y) - this.cy;\n  this.ay = 1 - this.cy - this.by;\n  this.p1x = p1x;\n  this.p1y = p2y;\n  this.p2x = p2x;\n  this.p2y = p2y;\n}\nUnitBezier.prototype.sampleCurveX = function (t) {\n  // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.\n  return ((this.ax * t + this.bx) * t + this.cx) * t;\n};\nUnitBezier.prototype.sampleCurveY = function (t) {\n  return ((this.ay * t + this.by) * t + this.cy) * t;\n};\nUnitBezier.prototype.sampleCurveDerivativeX = function (t) {\n  return (3 * this.ax * t + 2 * this.bx) * t + this.cx;\n};\nUnitBezier.prototype.solveCurveX = function (x, epsilon) {\n  if (typeof epsilon === 'undefined') {\n    epsilon = 0.000001;\n  }\n  var t0, t1, t2, x2, i;\n  // First try a few iterations of Newton's method -- normally very fast.\n  for (t2 = x, i = 0; i < 8; i++) {\n    x2 = this.sampleCurveX(t2) - x;\n    if (Math.abs(x2) < epsilon) {\n      return t2;\n    }\n    var d2 = this.sampleCurveDerivativeX(t2);\n    if (Math.abs(d2) < 0.000001) {\n      break;\n    }\n    t2 = t2 - x2 / d2;\n  }\n  // Fall back to the bisection method for reliability.\n  t0 = 0;\n  t1 = 1;\n  t2 = x;\n  if (t2 < t0) {\n    return t0;\n  }\n  if (t2 > t1) {\n    return t1;\n  }\n  while (t0 < t1) {\n    x2 = this.sampleCurveX(t2);\n    if (Math.abs(x2 - x) < epsilon) {\n      return t2;\n    }\n    if (x > x2) {\n      t0 = t2;\n    } else {\n      t1 = t2;\n    }\n    t2 = (t1 - t0) * 0.5 + t0;\n  }\n  // Failure.\n  return t2;\n};\nUnitBezier.prototype.solve = function (x, epsilon) {\n  return this.sampleCurveY(this.solveCurveX(x, epsilon));\n};\n\n//      \nfunction number(a, b, t) {\n  return a * (1 - t) + b * t;\n}\nfunction color(from, to, t) {\n  return new Color$1(number(from.r, to.r, t), number(from.g, to.g, t), number(from.b, to.b, t), number(from.a, to.a, t));\n}\nfunction array(from, to, t) {\n  return from.map(function (d, i) {\n    return number(d, to[i], t);\n  });\n}\nvar interpolate = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  number: number,\n  color: color,\n  array: array\n});\n\n//      \n// Constants\nvar Xn = 0.95047,\n  // D65 standard referent\n  Yn = 1,\n  Zn = 1.08883,\n  t0 = 4 / 29,\n  t1 = 6 / 29,\n  t2 = 3 * t1 * t1,\n  t3 = t1 * t1 * t1,\n  deg2rad$1 = Math.PI / 180,\n  rad2deg = 180 / Math.PI;\n// Utilities\nfunction xyz2lab(t) {\n  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n}\nfunction lab2xyz(t) {\n  return t > t1 ? t * t * t : t2 * (t - t0);\n}\nfunction xyz2rgb(x) {\n  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n}\nfunction rgb2xyz(x) {\n  x /= 255;\n  return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n}\n// LAB\nfunction rgbToLab(rgbColor) {\n  var b = rgb2xyz(rgbColor.r),\n    a = rgb2xyz(rgbColor.g),\n    l = rgb2xyz(rgbColor.b),\n    x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),\n    y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.072175 * l) / Yn),\n    z = xyz2lab((0.0193339 * b + 0.119192 * a + 0.9503041 * l) / Zn);\n  return {\n    l: 116 * y - 16,\n    a: 500 * (x - y),\n    b: 200 * (y - z),\n    alpha: rgbColor.a\n  };\n}\nfunction labToRgb(labColor) {\n  var y = (labColor.l + 16) / 116,\n    x = isNaN(labColor.a) ? y : y + labColor.a / 500,\n    z = isNaN(labColor.b) ? y : y - labColor.b / 200;\n  y = Yn * lab2xyz(y);\n  x = Xn * lab2xyz(x);\n  z = Zn * lab2xyz(z);\n  return new Color$1(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z),\n  // D65 -> sRGB\n  xyz2rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), labColor.alpha);\n}\nfunction interpolateLab(from, to, t) {\n  return {\n    l: number(from.l, to.l, t),\n    a: number(from.a, to.a, t),\n    b: number(from.b, to.b, t),\n    alpha: number(from.alpha, to.alpha, t)\n  };\n}\n// HCL\nfunction rgbToHcl(rgbColor) {\n  var ref = rgbToLab(rgbColor);\n  var l = ref.l;\n  var a = ref.a;\n  var b = ref.b;\n  var h = Math.atan2(b, a) * rad2deg;\n  return {\n    h: h < 0 ? h + 360 : h,\n    c: Math.sqrt(a * a + b * b),\n    l: l,\n    alpha: rgbColor.a\n  };\n}\nfunction hclToRgb(hclColor) {\n  var h = hclColor.h * deg2rad$1,\n    c = hclColor.c,\n    l = hclColor.l;\n  return labToRgb({\n    l: l,\n    a: Math.cos(h) * c,\n    b: Math.sin(h) * c,\n    alpha: hclColor.alpha\n  });\n}\nfunction interpolateHue(a, b, t) {\n  var d = b - a;\n  return a + t * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);\n}\nfunction interpolateHcl(from, to, t) {\n  return {\n    h: interpolateHue(from.h, to.h, t),\n    c: number(from.c, to.c, t),\n    l: number(from.l, to.l, t),\n    alpha: number(from.alpha, to.alpha, t)\n  };\n}\nvar lab = {\n  forward: rgbToLab,\n  reverse: labToRgb,\n  interpolate: interpolateLab\n};\nvar hcl = {\n  forward: rgbToHcl,\n  reverse: hclToRgb,\n  interpolate: interpolateHcl\n};\n\n//      \nvar Interpolate = function Interpolate(type, operator, interpolation, input, stops) {\n  this.type = type;\n  this.operator = operator;\n  this.interpolation = interpolation;\n  this.input = input;\n  this.labels = [];\n  this.outputs = [];\n  for (var i = 0, list = stops; i < list.length; i += 1) {\n    var ref = list[i];\n    var label = ref[0];\n    var expression = ref[1];\n    this.labels.push(label);\n    this.outputs.push(expression);\n  }\n};\nInterpolate.interpolationFactor = function interpolationFactor(interpolation, input, lower, upper) {\n  var t = 0;\n  if (interpolation.name === 'exponential') {\n    t = exponentialInterpolation(input, interpolation.base, lower, upper);\n  } else if (interpolation.name === 'linear') {\n    t = exponentialInterpolation(input, 1, lower, upper);\n  } else if (interpolation.name === 'cubic-bezier') {\n    var c = interpolation.controlPoints;\n    var ub = new unitbezier(c[0], c[1], c[2], c[3]);\n    t = ub.solve(exponentialInterpolation(input, 1, lower, upper));\n  }\n  return t;\n};\nInterpolate.parse = function parse(args, context) {\n  var operator = args[0];\n  var interpolation = args[1];\n  var input = args[2];\n  var rest = args.slice(3);\n  if (!Array.isArray(interpolation) || interpolation.length === 0) {\n    return context.error(\"Expected an interpolation type expression.\", 1);\n  }\n  if (interpolation[0] === 'linear') {\n    interpolation = {\n      name: 'linear'\n    };\n  } else if (interpolation[0] === 'exponential') {\n    var base = interpolation[1];\n    if (typeof base !== 'number') {\n      return context.error(\"Exponential interpolation requires a numeric base.\", 1, 1);\n    }\n    interpolation = {\n      name: 'exponential',\n      base: base\n    };\n  } else if (interpolation[0] === 'cubic-bezier') {\n    var controlPoints = interpolation.slice(1);\n    if (controlPoints.length !== 4 || controlPoints.some(function (t) {\n      return typeof t !== 'number' || t < 0 || t > 1;\n    })) {\n      return context.error('Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.', 1);\n    }\n    interpolation = {\n      name: 'cubic-bezier',\n      controlPoints: controlPoints\n    };\n  } else {\n    return context.error(\"Unknown interpolation type \" + String(interpolation[0]), 1, 0);\n  }\n  if (args.length - 1 < 4) {\n    return context.error(\"Expected at least 4 arguments, but found only \" + (args.length - 1) + \".\");\n  }\n  if ((args.length - 1) % 2 !== 0) {\n    return context.error(\"Expected an even number of arguments.\");\n  }\n  input = context.parse(input, 2, NumberType);\n  if (!input) {\n    return null;\n  }\n  var stops = [];\n  var outputType = null;\n  if (operator === 'interpolate-hcl' || operator === 'interpolate-lab') {\n    outputType = ColorType;\n  } else if (context.expectedType && context.expectedType.kind !== 'value') {\n    outputType = context.expectedType;\n  }\n  for (var i = 0; i < rest.length; i += 2) {\n    var label = rest[i];\n    var value = rest[i + 1];\n    var labelKey = i + 3;\n    var valueKey = i + 4;\n    if (typeof label !== 'number') {\n      return context.error('Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);\n    }\n    if (stops.length && stops[stops.length - 1][0] >= label) {\n      return context.error('Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.', labelKey);\n    }\n    var parsed = context.parse(value, valueKey, outputType);\n    if (!parsed) {\n      return null;\n    }\n    outputType = outputType || parsed.type;\n    stops.push([label, parsed]);\n  }\n  if (outputType.kind !== 'number' && outputType.kind !== 'color' && !(outputType.kind === 'array' && outputType.itemType.kind === 'number' && typeof outputType.N === 'number')) {\n    return context.error(\"Type \" + toString$1(outputType) + \" is not interpolatable.\");\n  }\n  return new Interpolate(outputType, operator, interpolation, input, stops);\n};\nInterpolate.prototype.evaluate = function evaluate(ctx) {\n  var labels = this.labels;\n  var outputs = this.outputs;\n  if (labels.length === 1) {\n    return outputs[0].evaluate(ctx);\n  }\n  var value = this.input.evaluate(ctx);\n  if (value <= labels[0]) {\n    return outputs[0].evaluate(ctx);\n  }\n  var stopCount = labels.length;\n  if (value >= labels[stopCount - 1]) {\n    return outputs[stopCount - 1].evaluate(ctx);\n  }\n  var index = findStopLessThanOrEqualTo(labels, value);\n  var lower = labels[index];\n  var upper = labels[index + 1];\n  var t = Interpolate.interpolationFactor(this.interpolation, value, lower, upper);\n  var outputLower = outputs[index].evaluate(ctx);\n  var outputUpper = outputs[index + 1].evaluate(ctx);\n  if (this.operator === 'interpolate') {\n    return interpolate[this.type.kind.toLowerCase()](outputLower, outputUpper, t); // eslint-disable-line import/namespace\n  } else if (this.operator === 'interpolate-hcl') {\n    return hcl.reverse(hcl.interpolate(hcl.forward(outputLower), hcl.forward(outputUpper), t));\n  } else {\n    return lab.reverse(lab.interpolate(lab.forward(outputLower), lab.forward(outputUpper), t));\n  }\n};\nInterpolate.prototype.eachChild = function eachChild(fn) {\n  fn(this.input);\n  for (var i = 0, list = this.outputs; i < list.length; i += 1) {\n    var expression = list[i];\n    fn(expression);\n  }\n};\nInterpolate.prototype.outputDefined = function outputDefined() {\n  return this.outputs.every(function (out) {\n    return out.outputDefined();\n  });\n};\nInterpolate.prototype.serialize = function serialize() {\n  var interpolation;\n  if (this.interpolation.name === 'linear') {\n    interpolation = ['linear'];\n  } else if (this.interpolation.name === 'exponential') {\n    if (this.interpolation.base === 1) {\n      interpolation = ['linear'];\n    } else {\n      interpolation = ['exponential', this.interpolation.base];\n    }\n  } else {\n    interpolation = ['cubic-bezier'].concat(this.interpolation.controlPoints);\n  }\n  var serialized = [this.operator, interpolation, this.input.serialize()];\n  for (var i = 0; i < this.labels.length; i++) {\n    serialized.push(this.labels[i], this.outputs[i].serialize());\n  }\n  return serialized;\n};\n/**\n * Returns a ratio that can be used to interpolate between exponential function\n * stops.\n * How it works: Two consecutive stop values define a (scaled and shifted) exponential function `f(x) = a * base^x + b`, where `base` is the user-specified base,\n * and `a` and `b` are constants affording sufficient degrees of freedom to fit\n * the function to the given stops.\n *\n * Here's a bit of algebra that lets us compute `f(x)` directly from the stop\n * values without explicitly solving for `a` and `b`:\n *\n * First stop value: `f(x0) = y0 = a * base^x0 + b`\n * Second stop value: `f(x1) = y1 = a * base^x1 + b`\n * => `y1 - y0 = a(base^x1 - base^x0)`\n * => `a = (y1 - y0)/(base^x1 - base^x0)`\n *\n * Desired value: `f(x) = y = a * base^x + b`\n * => `f(x) = y0 + a * (base^x - base^x0)`\n *\n * From the above, we can replace the `a` in `a * (base^x - base^x0)` and do a\n * little algebra:\n * ```\n * a * (base^x - base^x0) = (y1 - y0)/(base^x1 - base^x0) * (base^x - base^x0)\n *                     = (y1 - y0) * (base^x - base^x0) / (base^x1 - base^x0)\n * ```\n *\n * If we let `(base^x - base^x0) / (base^x1 base^x0)`, then we have\n * `f(x) = y0 + (y1 - y0) * ratio`.  In other words, `ratio` may be treated as\n * an interpolation factor between the two stops' output values.\n *\n * (Note: a slightly different form for `ratio`,\n * `(base^(x-x0) - 1) / (base^(x1-x0) - 1) `, is equivalent, but requires fewer\n * expensive `Math.pow()` operations.)\n *\n * @private\n*/\nfunction exponentialInterpolation(input, base, lowerValue, upperValue) {\n  var difference = upperValue - lowerValue;\n  var progress = input - lowerValue;\n  if (difference === 0) {\n    return 0;\n  } else if (base === 1) {\n    return progress / difference;\n  } else {\n    return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);\n  }\n}\nvar Interpolate$1 = Interpolate;\nvar Coalesce = function Coalesce(type, args) {\n  this.type = type;\n  this.args = args;\n};\nCoalesce.parse = function parse(args, context) {\n  if (args.length < 2) {\n    return context.error('Expectected at least one argument.');\n  }\n  var outputType = null;\n  var expectedType = context.expectedType;\n  if (expectedType && expectedType.kind !== 'value') {\n    outputType = expectedType;\n  }\n  var parsedArgs = [];\n  for (var i = 0, list = args.slice(1); i < list.length; i += 1) {\n    var arg = list[i];\n    var parsed = context.parse(arg, 1 + parsedArgs.length, outputType, undefined, {\n      typeAnnotation: 'omit'\n    });\n    if (!parsed) {\n      return null;\n    }\n    outputType = outputType || parsed.type;\n    parsedArgs.push(parsed);\n  }\n  // Above, we parse arguments without inferred type annotation so that\n  // they don't produce a runtime error for `null` input, which would\n  // preempt the desired null-coalescing behavior.\n  // Thus, if any of our arguments would have needed an annotation, we\n  // need to wrap the enclosing coalesce expression with it instead.\n  var needsAnnotation = expectedType && parsedArgs.some(function (arg) {\n    return checkSubtype(expectedType, arg.type);\n  });\n  return needsAnnotation ? new Coalesce(ValueType, parsedArgs) : new Coalesce(outputType, parsedArgs);\n};\nCoalesce.prototype.evaluate = function evaluate(ctx) {\n  var result = null;\n  var argCount = 0;\n  var firstImage;\n  for (var i = 0, list = this.args; i < list.length; i += 1) {\n    var arg = list[i];\n    argCount++;\n    result = arg.evaluate(ctx);\n    // we need to keep track of the first requested image in a coalesce statement\n    // if coalesce can't find a valid image, we return the first image so styleimagemissing can fire\n    if (result && result instanceof ResolvedImage$1 && !result.available) {\n      // set to first image\n      if (!firstImage) {\n        firstImage = result;\n      }\n      result = null;\n      // if we reach the end, return the first image\n      if (argCount === this.args.length) {\n        return firstImage;\n      }\n    }\n    if (result !== null) {\n      break;\n    }\n  }\n  return result;\n};\nCoalesce.prototype.eachChild = function eachChild(fn) {\n  this.args.forEach(fn);\n};\nCoalesce.prototype.outputDefined = function outputDefined() {\n  return this.args.every(function (arg) {\n    return arg.outputDefined();\n  });\n};\nCoalesce.prototype.serialize = function serialize() {\n  var serialized = ['coalesce'];\n  this.eachChild(function (child) {\n    serialized.push(child.serialize());\n  });\n  return serialized;\n};\nvar Coalesce$1 = Coalesce;\n\n//      \nvar Let = function Let(bindings, result) {\n  this.type = result.type;\n  this.bindings = [].concat(bindings);\n  this.result = result;\n};\nLet.prototype.evaluate = function evaluate(ctx) {\n  return this.result.evaluate(ctx);\n};\nLet.prototype.eachChild = function eachChild(fn) {\n  for (var i = 0, list = this.bindings; i < list.length; i += 1) {\n    var binding = list[i];\n    fn(binding[1]);\n  }\n  fn(this.result);\n};\nLet.parse = function parse(args, context) {\n  if (args.length < 4) {\n    return context.error(\"Expected at least 3 arguments, but found \" + (args.length - 1) + \" instead.\");\n  }\n  var bindings = [];\n  for (var i = 1; i < args.length - 1; i += 2) {\n    var name = args[i];\n    if (typeof name !== 'string') {\n      return context.error(\"Expected string, but found \" + typeof name + \" instead.\", i);\n    }\n    if (/[^a-zA-Z0-9_]/.test(name)) {\n      return context.error(\"Variable names must contain only alphanumeric characters or '_'.\", i);\n    }\n    var value = context.parse(args[i + 1], i + 1);\n    if (!value) {\n      return null;\n    }\n    bindings.push([name, value]);\n  }\n  var result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);\n  if (!result) {\n    return null;\n  }\n  return new Let(bindings, result);\n};\nLet.prototype.outputDefined = function outputDefined() {\n  return this.result.outputDefined();\n};\nLet.prototype.serialize = function serialize() {\n  var serialized = ['let'];\n  for (var i = 0, list = this.bindings; i < list.length; i += 1) {\n    var ref = list[i];\n    var name = ref[0];\n    var expr = ref[1];\n    serialized.push(name, expr.serialize());\n  }\n  serialized.push(this.result.serialize());\n  return serialized;\n};\nvar Let$1 = Let;\n\n//      \nvar At = function At(type, index, input) {\n  this.type = type;\n  this.index = index;\n  this.input = input;\n};\nAt.parse = function parse(args, context) {\n  if (args.length !== 3) {\n    return context.error(\"Expected 2 arguments, but found \" + (args.length - 1) + \" instead.\");\n  }\n  var index = context.parse(args[1], 1, NumberType);\n  var input = context.parse(args[2], 2, array$1(context.expectedType || ValueType));\n  if (!index || !input) {\n    return null;\n  }\n  var t = input.type;\n  return new At(t.itemType, index, input);\n};\nAt.prototype.evaluate = function evaluate(ctx) {\n  var index = this.index.evaluate(ctx);\n  var array = this.input.evaluate(ctx);\n  if (index < 0) {\n    throw new RuntimeError$1(\"Array index out of bounds: \" + index + \" < 0.\");\n  }\n  if (index >= array.length) {\n    throw new RuntimeError$1(\"Array index out of bounds: \" + index + \" > \" + (array.length - 1) + \".\");\n  }\n  if (index !== Math.floor(index)) {\n    throw new RuntimeError$1(\"Array index must be an integer, but found \" + index + \" instead.\");\n  }\n  return array[index];\n};\nAt.prototype.eachChild = function eachChild(fn) {\n  fn(this.index);\n  fn(this.input);\n};\nAt.prototype.outputDefined = function outputDefined() {\n  return false;\n};\nAt.prototype.serialize = function serialize() {\n  return ['at', this.index.serialize(), this.input.serialize()];\n};\nvar At$1 = At;\n\n//      \nvar In = function In(needle, haystack) {\n  this.type = BooleanType;\n  this.needle = needle;\n  this.haystack = haystack;\n};\nIn.parse = function parse(args, context) {\n  if (args.length !== 3) {\n    return context.error(\"Expected 2 arguments, but found \" + (args.length - 1) + \" instead.\");\n  }\n  var needle = context.parse(args[1], 1, ValueType);\n  var haystack = context.parse(args[2], 2, ValueType);\n  if (!needle || !haystack) {\n    return null;\n  }\n  if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {\n    return context.error(\"Expected first argument to be of type boolean, string, number or null, but found \" + toString$1(needle.type) + \" instead\");\n  }\n  return new In(needle, haystack);\n};\nIn.prototype.evaluate = function evaluate(ctx) {\n  var needle = this.needle.evaluate(ctx);\n  var haystack = this.haystack.evaluate(ctx);\n  if (haystack == null) {\n    return false;\n  }\n  if (!isValidNativeType(needle, ['boolean', 'string', 'number', 'null'])) {\n    throw new RuntimeError$1(\"Expected first argument to be of type boolean, string, number or null, but found \" + toString$1(typeOf(needle)) + \" instead.\");\n  }\n  if (!isValidNativeType(haystack, ['string', 'array'])) {\n    throw new RuntimeError$1(\"Expected second argument to be of type array or string, but found \" + toString$1(typeOf(haystack)) + \" instead.\");\n  }\n  return haystack.indexOf(needle) >= 0;\n};\nIn.prototype.eachChild = function eachChild(fn) {\n  fn(this.needle);\n  fn(this.haystack);\n};\nIn.prototype.outputDefined = function outputDefined() {\n  return true;\n};\nIn.prototype.serialize = function serialize() {\n  return ['in', this.needle.serialize(), this.haystack.serialize()];\n};\nvar In$1 = In;\n\n//      \nvar IndexOf = function IndexOf(needle, haystack, fromIndex) {\n  this.type = NumberType;\n  this.needle = needle;\n  this.haystack = haystack;\n  this.fromIndex = fromIndex;\n};\nIndexOf.parse = function parse(args, context) {\n  if (args.length <= 2 || args.length >= 5) {\n    return context.error(\"Expected 3 or 4 arguments, but found \" + (args.length - 1) + \" instead.\");\n  }\n  var needle = context.parse(args[1], 1, ValueType);\n  var haystack = context.parse(args[2], 2, ValueType);\n  if (!needle || !haystack) {\n    return null;\n  }\n  if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {\n    return context.error(\"Expected first argument to be of type boolean, string, number or null, but found \" + toString$1(needle.type) + \" instead\");\n  }\n  if (args.length === 4) {\n    var fromIndex = context.parse(args[3], 3, NumberType);\n    if (!fromIndex) {\n      return null;\n    }\n    return new IndexOf(needle, haystack, fromIndex);\n  } else {\n    return new IndexOf(needle, haystack);\n  }\n};\nIndexOf.prototype.evaluate = function evaluate(ctx) {\n  var needle = this.needle.evaluate(ctx);\n  var haystack = this.haystack.evaluate(ctx);\n  if (!isValidNativeType(needle, ['boolean', 'string', 'number', 'null'])) {\n    throw new RuntimeError$1(\"Expected first argument to be of type boolean, string, number or null, but found \" + toString$1(typeOf(needle)) + \" instead.\");\n  }\n  if (!isValidNativeType(haystack, ['string', 'array'])) {\n    throw new RuntimeError$1(\"Expected second argument to be of type array or string, but found \" + toString$1(typeOf(haystack)) + \" instead.\");\n  }\n  if (this.fromIndex) {\n    var fromIndex = this.fromIndex.evaluate(ctx);\n    return haystack.indexOf(needle, fromIndex);\n  }\n  return haystack.indexOf(needle);\n};\nIndexOf.prototype.eachChild = function eachChild(fn) {\n  fn(this.needle);\n  fn(this.haystack);\n  if (this.fromIndex) {\n    fn(this.fromIndex);\n  }\n};\nIndexOf.prototype.outputDefined = function outputDefined() {\n  return false;\n};\nIndexOf.prototype.serialize = function serialize() {\n  if (this.fromIndex != null && this.fromIndex !== undefined) {\n    var fromIndex = this.fromIndex.serialize();\n    return ['index-of', this.needle.serialize(), this.haystack.serialize(), fromIndex];\n  }\n  return ['index-of', this.needle.serialize(), this.haystack.serialize()];\n};\nvar IndexOf$1 = IndexOf;\n\n// Map input label values to output expression index\nvar Match = function Match(inputType, outputType, input, cases, outputs, otherwise) {\n  this.inputType = inputType;\n  this.type = outputType;\n  this.input = input;\n  this.cases = cases;\n  this.outputs = outputs;\n  this.otherwise = otherwise;\n};\nMatch.parse = function parse(args, context) {\n  if (args.length < 5) {\n    return context.error(\"Expected at least 4 arguments, but found only \" + (args.length - 1) + \".\");\n  }\n  if (args.length % 2 !== 1) {\n    return context.error(\"Expected an even number of arguments.\");\n  }\n  var inputType;\n  var outputType;\n  if (context.expectedType && context.expectedType.kind !== 'value') {\n    outputType = context.expectedType;\n  }\n  var cases = {};\n  var outputs = [];\n  for (var i = 2; i < args.length - 1; i += 2) {\n    var labels = args[i];\n    var value = args[i + 1];\n    if (!Array.isArray(labels)) {\n      labels = [labels];\n    }\n    var labelContext = context.concat(i);\n    if (labels.length === 0) {\n      return labelContext.error('Expected at least one branch label.');\n    }\n    for (var i$1 = 0, list = labels; i$1 < list.length; i$1 += 1) {\n      var label = list[i$1];\n      if (typeof label !== 'number' && typeof label !== 'string') {\n        return labelContext.error(\"Branch labels must be numbers or strings.\");\n      } else if (typeof label === 'number' && Math.abs(label) > Number.MAX_SAFE_INTEGER) {\n        return labelContext.error(\"Branch labels must be integers no larger than \" + Number.MAX_SAFE_INTEGER + \".\");\n      } else if (typeof label === 'number' && Math.floor(label) !== label) {\n        return labelContext.error(\"Numeric branch labels must be integer values.\");\n      } else if (!inputType) {\n        inputType = typeOf(label);\n      } else if (labelContext.checkSubtype(inputType, typeOf(label))) {\n        return null;\n      }\n      if (typeof cases[String(label)] !== 'undefined') {\n        return labelContext.error('Branch labels must be unique.');\n      }\n      cases[String(label)] = outputs.length;\n    }\n    var result = context.parse(value, i, outputType);\n    if (!result) {\n      return null;\n    }\n    outputType = outputType || result.type;\n    outputs.push(result);\n  }\n  var input = context.parse(args[1], 1, ValueType);\n  if (!input) {\n    return null;\n  }\n  var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);\n  if (!otherwise) {\n    return null;\n  }\n  if (input.type.kind !== 'value' && context.concat(1).checkSubtype(inputType, input.type)) {\n    return null;\n  }\n  return new Match(inputType, outputType, input, cases, outputs, otherwise);\n};\nMatch.prototype.evaluate = function evaluate(ctx) {\n  var input = this.input.evaluate(ctx);\n  var output = typeOf(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;\n  return output.evaluate(ctx);\n};\nMatch.prototype.eachChild = function eachChild(fn) {\n  fn(this.input);\n  this.outputs.forEach(fn);\n  fn(this.otherwise);\n};\nMatch.prototype.outputDefined = function outputDefined() {\n  return this.outputs.every(function (out) {\n    return out.outputDefined();\n  }) && this.otherwise.outputDefined();\n};\nMatch.prototype.serialize = function serialize() {\n  var this$1$1 = this;\n  var serialized = ['match', this.input.serialize()];\n  // Sort so serialization has an arbitrary defined order, even though\n  // branch order doesn't affect evaluation\n  var sortedLabels = Object.keys(this.cases).sort();\n  // Group branches by unique match expression to support condensed\n  // serializations of the form [case1, case2, ...] -> matchExpression\n  var groupedByOutput = [];\n  var outputLookup = {};\n  // lookup index into groupedByOutput for a given output expression\n  for (var i = 0, list = sortedLabels; i < list.length; i += 1) {\n    var label = list[i];\n    var outputIndex = outputLookup[this.cases[label]];\n    if (outputIndex === undefined) {\n      // First time seeing this output, add it to the end of the grouped list\n      outputLookup[this.cases[label]] = groupedByOutput.length;\n      groupedByOutput.push([this.cases[label], [label]]);\n    } else {\n      // We've seen this expression before, add the label to that output's group\n      groupedByOutput[outputIndex][1].push(label);\n    }\n  }\n  var coerceLabel = function (label) {\n    return this$1$1.inputType.kind === 'number' ? Number(label) : label;\n  };\n  for (var i$1 = 0, list$1 = groupedByOutput; i$1 < list$1.length; i$1 += 1) {\n    var ref = list$1[i$1];\n    var outputIndex = ref[0];\n    var labels = ref[1];\n    if (labels.length === 1) {\n      // Only a single label matches this output expression\n      serialized.push(coerceLabel(labels[0]));\n    } else {\n      // Array of literal labels pointing to this output expression\n      serialized.push(labels.map(coerceLabel));\n    }\n    serialized.push(this.outputs[outputIndex$1].serialize());\n  }\n  serialized.push(this.otherwise.serialize());\n  return serialized;\n};\nvar Match$1 = Match;\nvar Case = function Case(type, branches, otherwise) {\n  this.type = type;\n  this.branches = branches;\n  this.otherwise = otherwise;\n};\nCase.parse = function parse(args, context) {\n  if (args.length < 4) {\n    return context.error(\"Expected at least 3 arguments, but found only \" + (args.length - 1) + \".\");\n  }\n  if (args.length % 2 !== 0) {\n    return context.error(\"Expected an odd number of arguments.\");\n  }\n  var outputType;\n  if (context.expectedType && context.expectedType.kind !== 'value') {\n    outputType = context.expectedType;\n  }\n  var branches = [];\n  for (var i = 1; i < args.length - 1; i += 2) {\n    var test = context.parse(args[i], i, BooleanType);\n    if (!test) {\n      return null;\n    }\n    var result = context.parse(args[i + 1], i + 1, outputType);\n    if (!result) {\n      return null;\n    }\n    branches.push([test, result]);\n    outputType = outputType || result.type;\n  }\n  var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);\n  if (!otherwise) {\n    return null;\n  }\n  return new Case(outputType, branches, otherwise);\n};\nCase.prototype.evaluate = function evaluate(ctx) {\n  for (var i = 0, list = this.branches; i < list.length; i += 1) {\n    var ref = list[i];\n    var test = ref[0];\n    var expression = ref[1];\n    if (test.evaluate(ctx)) {\n      return expression.evaluate(ctx);\n    }\n  }\n  return this.otherwise.evaluate(ctx);\n};\nCase.prototype.eachChild = function eachChild(fn) {\n  for (var i = 0, list = this.branches; i < list.length; i += 1) {\n    var ref = list[i];\n    var test = ref[0];\n    var expression = ref[1];\n    fn(test);\n    fn(expression);\n  }\n  fn(this.otherwise);\n};\nCase.prototype.outputDefined = function outputDefined() {\n  return this.branches.every(function (ref) {\n    ref[0];\n    var out = ref[1];\n    return out.outputDefined();\n  }) && this.otherwise.outputDefined();\n};\nCase.prototype.serialize = function serialize() {\n  var serialized = ['case'];\n  this.eachChild(function (child) {\n    serialized.push(child.serialize());\n  });\n  return serialized;\n};\nvar Case$1 = Case;\n\n//      \nvar Slice = function Slice(type, input, beginIndex, endIndex) {\n  this.type = type;\n  this.input = input;\n  this.beginIndex = beginIndex;\n  this.endIndex = endIndex;\n};\nSlice.parse = function parse(args, context) {\n  if (args.length <= 2 || args.length >= 5) {\n    return context.error(\"Expected 3 or 4 arguments, but found \" + (args.length - 1) + \" instead.\");\n  }\n  var input = context.parse(args[1], 1, ValueType);\n  var beginIndex = context.parse(args[2], 2, NumberType);\n  if (!input || !beginIndex) {\n    return null;\n  }\n  if (!isValidType(input.type, [array$1(ValueType), StringType, ValueType])) {\n    return context.error(\"Expected first argument to be of type array or string, but found \" + toString$1(input.type) + \" instead\");\n  }\n  if (args.length === 4) {\n    var endIndex = context.parse(args[3], 3, NumberType);\n    if (!endIndex) {\n      return null;\n    }\n    return new Slice(input.type, input, beginIndex, endIndex);\n  } else {\n    return new Slice(input.type, input, beginIndex);\n  }\n};\nSlice.prototype.evaluate = function evaluate(ctx) {\n  var input = this.input.evaluate(ctx);\n  var beginIndex = this.beginIndex.evaluate(ctx);\n  if (!isValidNativeType(input, ['string', 'array'])) {\n    throw new RuntimeError$1(\"Expected first argument to be of type array or string, but found \" + toString$1(typeOf(input)) + \" instead.\");\n  }\n  if (this.endIndex) {\n    var endIndex = this.endIndex.evaluate(ctx);\n    return input.slice(beginIndex, endIndex);\n  }\n  return input.slice(beginIndex);\n};\nSlice.prototype.eachChild = function eachChild(fn) {\n  fn(this.input);\n  fn(this.beginIndex);\n  if (this.endIndex) {\n    fn(this.endIndex);\n  }\n};\nSlice.prototype.outputDefined = function outputDefined() {\n  return false;\n};\nSlice.prototype.serialize = function serialize() {\n  if (this.endIndex != null && this.endIndex !== undefined) {\n    var endIndex = this.endIndex.serialize();\n    return ['slice', this.input.serialize(), this.beginIndex.serialize(), endIndex];\n  }\n  return ['slice', this.input.serialize(), this.beginIndex.serialize()];\n};\nvar Slice$1 = Slice;\n\n//      \nfunction isComparableType(op, type) {\n  if (op === '==' || op === '!=') {\n    // equality operator\n    return type.kind === 'boolean' || type.kind === 'string' || type.kind === 'number' || type.kind === 'null' || type.kind === 'value';\n  } else {\n    // ordering operator\n    return type.kind === 'string' || type.kind === 'number' || type.kind === 'value';\n  }\n}\nfunction eq(ctx, a, b) {\n  return a === b;\n}\nfunction neq(ctx, a, b) {\n  return a !== b;\n}\nfunction lt(ctx, a, b) {\n  return a < b;\n}\nfunction gt(ctx, a, b) {\n  return a > b;\n}\nfunction lteq(ctx, a, b) {\n  return a <= b;\n}\nfunction gteq(ctx, a, b) {\n  return a >= b;\n}\nfunction eqCollate(ctx, a, b, c) {\n  return c.compare(a, b) === 0;\n}\nfunction neqCollate(ctx, a, b, c) {\n  return !eqCollate(ctx, a, b, c);\n}\nfunction ltCollate(ctx, a, b, c) {\n  return c.compare(a, b) < 0;\n}\nfunction gtCollate(ctx, a, b, c) {\n  return c.compare(a, b) > 0;\n}\nfunction lteqCollate(ctx, a, b, c) {\n  return c.compare(a, b) <= 0;\n}\nfunction gteqCollate(ctx, a, b, c) {\n  return c.compare(a, b) >= 0;\n}\n/**\n * Special form for comparison operators, implementing the signatures:\n * - (T, T, ?Collator) => boolean\n * - (T, value, ?Collator) => boolean\n * - (value, T, ?Collator) => boolean\n *\n * For inequalities, T must be either value, string, or number. For ==/!=, it\n * can also be boolean or null.\n *\n * Equality semantics are equivalent to Javascript's strict equality (===/!==)\n * -- i.e., when the arguments' types don't match, == evaluates to false, != to\n * true.\n *\n * When types don't match in an ordering comparison, a runtime error is thrown.\n *\n * @private\n */\nfunction makeComparison(op, compareBasic, compareWithCollator) {\n  var isOrderComparison = op !== '==' && op !== '!=';\n  return /*@__PURE__*/function () {\n    function Comparison(lhs, rhs, collator) {\n      this.type = BooleanType;\n      this.lhs = lhs;\n      this.rhs = rhs;\n      this.collator = collator;\n      this.hasUntypedArgument = lhs.type.kind === 'value' || rhs.type.kind === 'value';\n    }\n    Comparison.parse = function parse(args, context) {\n      if (args.length !== 3 && args.length !== 4) {\n        return context.error(\"Expected two or three arguments.\");\n      }\n      var op = args[0];\n      var lhs = context.parse(args[1], 1, ValueType);\n      if (!lhs) {\n        return null;\n      }\n      if (!isComparableType(op, lhs.type)) {\n        return context.concat(1).error(\"\\\"\" + op + \"\\\" comparisons are not supported for type '\" + toString$1(lhs.type) + \"'.\");\n      }\n      var rhs = context.parse(args[2], 2, ValueType);\n      if (!rhs) {\n        return null;\n      }\n      if (!isComparableType(op, rhs.type)) {\n        return context.concat(2).error(\"\\\"\" + op + \"\\\" comparisons are not supported for type '\" + toString$1(rhs.type) + \"'.\");\n      }\n      if (lhs.type.kind !== rhs.type.kind && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {\n        return context.error(\"Cannot compare types '\" + toString$1(lhs.type) + \"' and '\" + toString$1(rhs.type) + \"'.\");\n      }\n      if (isOrderComparison) {\n        // typing rules specific to less/greater than operators\n        if (lhs.type.kind === 'value' && rhs.type.kind !== 'value') {\n          // (value, T)\n          lhs = new Assertion$1(rhs.type, [lhs]);\n        } else if (lhs.type.kind !== 'value' && rhs.type.kind === 'value') {\n          // (T, value)\n          rhs = new Assertion$1(lhs.type, [rhs]);\n        }\n      }\n      var collator = null;\n      if (args.length === 4) {\n        if (lhs.type.kind !== 'string' && rhs.type.kind !== 'string' && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {\n          return context.error(\"Cannot use collator to compare non-string types.\");\n        }\n        collator = context.parse(args[3], 3, CollatorType);\n        if (!collator) {\n          return null;\n        }\n      }\n      return new Comparison(lhs, rhs, collator);\n    };\n    Comparison.prototype.evaluate = function evaluate(ctx) {\n      var lhs = this.lhs.evaluate(ctx);\n      var rhs = this.rhs.evaluate(ctx);\n      if (isOrderComparison && this.hasUntypedArgument) {\n        var lt = typeOf(lhs);\n        var rt = typeOf(rhs);\n        // check that type is string or number, and equal\n        if (lt.kind !== rt.kind || !(lt.kind === 'string' || lt.kind === 'number')) {\n          throw new RuntimeError$1(\"Expected arguments for \\\"\" + op + \"\\\" to be (string, string) or (number, number), but found (\" + lt.kind + \", \" + rt.kind + \") instead.\");\n        }\n      }\n      if (this.collator && !isOrderComparison && this.hasUntypedArgument) {\n        var lt$1 = typeOf(lhs);\n        var rt$1 = typeOf(rhs);\n        if (lt$1.kind !== 'string' || rt$1.kind !== 'string') {\n          return compareBasic(ctx, lhs, rhs);\n        }\n      }\n      return this.collator ? compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) : compareBasic(ctx, lhs, rhs);\n    };\n    Comparison.prototype.eachChild = function eachChild(fn) {\n      fn(this.lhs);\n      fn(this.rhs);\n      if (this.collator) {\n        fn(this.collator);\n      }\n    };\n    Comparison.prototype.outputDefined = function outputDefined() {\n      return true;\n    };\n    Comparison.prototype.serialize = function serialize() {\n      var serialized = [op];\n      this.eachChild(function (child) {\n        serialized.push(child.serialize());\n      });\n      return serialized;\n    };\n    return Comparison;\n  }();\n}\nvar Equals = makeComparison('==', eq, eqCollate);\nvar NotEquals = makeComparison('!=', neq, neqCollate);\nvar LessThan = makeComparison('<', lt, ltCollate);\nvar GreaterThan = makeComparison('>', gt, gtCollate);\nvar LessThanOrEqual = makeComparison('<=', lteq, lteqCollate);\nvar GreaterThanOrEqual = makeComparison('>=', gteq, gteqCollate);\n\n//      \nvar NumberFormat = function NumberFormat(number, locale, currency, unit, minFractionDigits, maxFractionDigits) {\n  this.type = StringType;\n  this.number = number;\n  this.locale = locale;\n  this.currency = currency;\n  this.unit = unit;\n  this.minFractionDigits = minFractionDigits;\n  this.maxFractionDigits = maxFractionDigits;\n};\nNumberFormat.parse = function parse(args, context) {\n  if (args.length !== 3) {\n    return context.error(\"Expected two arguments.\");\n  }\n  var number = context.parse(args[1], 1, NumberType);\n  if (!number) {\n    return null;\n  }\n  var options = args[2];\n  if (typeof options !== 'object' || Array.isArray(options)) {\n    return context.error(\"NumberFormat options argument must be an object.\");\n  }\n  var locale = null;\n  if (options['locale']) {\n    locale = context.parse(options['locale'], 1, StringType);\n    if (!locale) {\n      return null;\n    }\n  }\n  var currency = null;\n  if (options['currency']) {\n    currency = context.parse(options['currency'], 1, StringType);\n    if (!currency) {\n      return null;\n    }\n  }\n  var unit = null;\n  if (options['unit']) {\n    unit = context.parse(options['unit'], 1, StringType);\n    if (!unit) {\n      return null;\n    }\n  }\n  var minFractionDigits = null;\n  if (options['min-fraction-digits']) {\n    minFractionDigits = context.parse(options['min-fraction-digits'], 1, NumberType);\n    if (!minFractionDigits) {\n      return null;\n    }\n  }\n  var maxFractionDigits = null;\n  if (options['max-fraction-digits']) {\n    maxFractionDigits = context.parse(options['max-fraction-digits'], 1, NumberType);\n    if (!maxFractionDigits) {\n      return null;\n    }\n  }\n  return new NumberFormat(number, locale, currency, unit, minFractionDigits, maxFractionDigits);\n};\nNumberFormat.prototype.evaluate = function evaluate(ctx) {\n  return new Intl.NumberFormat(this.locale ? this.locale.evaluate(ctx) : [], {\n    style: this.currency && 'currency' || this.unit && 'unit' || 'decimal',\n    currency: this.currency ? this.currency.evaluate(ctx) : undefined,\n    unit: this.unit ? this.unit.evaluate(ctx) : undefined,\n    minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(ctx) : undefined,\n    maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(ctx) : undefined\n  }).format(this.number.evaluate(ctx));\n};\nNumberFormat.prototype.eachChild = function eachChild(fn) {\n  fn(this.number);\n  if (this.locale) {\n    fn(this.locale);\n  }\n  if (this.currency) {\n    fn(this.currency);\n  }\n  if (this.unit) {\n    fn(this.unit);\n  }\n  if (this.minFractionDigits) {\n    fn(this.minFractionDigits);\n  }\n  if (this.maxFractionDigits) {\n    fn(this.maxFractionDigits);\n  }\n};\nNumberFormat.prototype.outputDefined = function outputDefined() {\n  return false;\n};\nNumberFormat.prototype.serialize = function serialize() {\n  var options = {};\n  if (this.locale) {\n    options['locale'] = this.locale.serialize();\n  }\n  if (this.currency) {\n    options['currency'] = this.currency.serialize();\n  }\n  if (this.unit) {\n    options['unit'] = this.unit.serialize();\n  }\n  if (this.minFractionDigits) {\n    options['min-fraction-digits'] = this.minFractionDigits.serialize();\n  }\n  if (this.maxFractionDigits) {\n    options['max-fraction-digits'] = this.maxFractionDigits.serialize();\n  }\n  return ['number-format', this.number.serialize(), options];\n};\nvar NumberFormat$1 = NumberFormat;\n\n//      \nvar Length = function Length(input) {\n  this.type = NumberType;\n  this.input = input;\n};\nLength.parse = function parse(args, context) {\n  if (args.length !== 2) {\n    return context.error(\"Expected 1 argument, but found \" + (args.length - 1) + \" instead.\");\n  }\n  var input = context.parse(args[1], 1);\n  if (!input) {\n    return null;\n  }\n  if (input.type.kind !== 'array' && input.type.kind !== 'string' && input.type.kind !== 'value') {\n    return context.error(\"Expected argument of type string or array, but found \" + toString$1(input.type) + \" instead.\");\n  }\n  return new Length(input);\n};\nLength.prototype.evaluate = function evaluate(ctx) {\n  var input = this.input.evaluate(ctx);\n  if (typeof input === 'string') {\n    return input.length;\n  } else if (Array.isArray(input)) {\n    return input.length;\n  } else {\n    throw new RuntimeError$1(\"Expected value to be of type string or array, but found \" + toString$1(typeOf(input)) + \" instead.\");\n  }\n};\nLength.prototype.eachChild = function eachChild(fn) {\n  fn(this.input);\n};\nLength.prototype.outputDefined = function outputDefined() {\n  return false;\n};\nLength.prototype.serialize = function serialize() {\n  var serialized = ['length'];\n  this.eachChild(function (child) {\n    serialized.push(child.serialize());\n  });\n  return serialized;\n};\nvar Length$1 = Length;\n\n//      \nvar expressions = {\n  // special forms\n  '==': Equals,\n  '!=': NotEquals,\n  '>': GreaterThan,\n  '<': LessThan,\n  '>=': GreaterThanOrEqual,\n  '<=': LessThanOrEqual,\n  'array': Assertion$1,\n  'at': At$1,\n  'boolean': Assertion$1,\n  'case': Case$1,\n  'coalesce': Coalesce$1,\n  'collator': CollatorExpression$1,\n  'format': FormatExpression$1,\n  'image': ImageExpression$1,\n  'in': In$1,\n  'index-of': IndexOf$1,\n  'interpolate': Interpolate$1,\n  'interpolate-hcl': Interpolate$1,\n  'interpolate-lab': Interpolate$1,\n  'length': Length$1,\n  'let': Let$1,\n  'literal': Literal$1,\n  'match': Match$1,\n  'number': Assertion$1,\n  'number-format': NumberFormat$1,\n  'object': Assertion$1,\n  'slice': Slice$1,\n  'step': Step$1,\n  'string': Assertion$1,\n  'to-boolean': Coercion$1,\n  'to-color': Coercion$1,\n  'to-number': Coercion$1,\n  'to-string': Coercion$1,\n  'var': Var$1,\n  'within': Within$1\n};\nfunction rgba(ctx, ref) {\n  var r = ref[0];\n  var g = ref[1];\n  var b = ref[2];\n  var a = ref[3];\n  r = r.evaluate(ctx);\n  g = g.evaluate(ctx);\n  b = b.evaluate(ctx);\n  var alpha = a ? a.evaluate(ctx) : 1;\n  var error = validateRGBA(r, g, b, alpha);\n  if (error) {\n    throw new RuntimeError$1(error);\n  }\n  return new Color$1(r / 255 * alpha, g / 255 * alpha, b / 255 * alpha, alpha);\n}\nfunction has(key, obj) {\n  return key in obj;\n}\nfunction get(key, obj) {\n  var v = obj[key];\n  return typeof v === 'undefined' ? null : v;\n}\nfunction binarySearch(v, a, i, j) {\n  while (i <= j) {\n    var m = i + j >> 1;\n    if (a[m] === v) {\n      return true;\n    }\n    if (a[m] > v) {\n      j = m - 1;\n    } else {\n      i = m + 1;\n    }\n  }\n  return false;\n}\nfunction varargs(type) {\n  return {\n    type: type\n  };\n}\nCompoundExpression$1.register(expressions, {\n  'error': [ErrorType, [StringType], function (ctx, ref) {\n    var v = ref[0];\n    throw new RuntimeError$1(v.evaluate(ctx));\n  }],\n  'typeof': [StringType, [ValueType], function (ctx, ref) {\n    var v = ref[0];\n    return toString$1(typeOf(v.evaluate(ctx)));\n  }],\n  'to-rgba': [array$1(NumberType, 4), [ColorType], function (ctx, ref) {\n    var v = ref[0];\n    return v.evaluate(ctx).toArray();\n  }],\n  'rgb': [ColorType, [NumberType, NumberType, NumberType], rgba],\n  'rgba': [ColorType, [NumberType, NumberType, NumberType, NumberType], rgba],\n  'has': {\n    type: BooleanType,\n    overloads: [[[StringType], function (ctx, ref) {\n      var key = ref[0];\n      return has(key.evaluate(ctx), ctx.properties());\n    }], [[StringType, ObjectType], function (ctx, ref) {\n      var key = ref[0];\n      var obj = ref[1];\n      return has(key.evaluate(ctx), obj.evaluate(ctx));\n    }]]\n  },\n  'get': {\n    type: ValueType,\n    overloads: [[[StringType], function (ctx, ref) {\n      var key = ref[0];\n      return get(key.evaluate(ctx), ctx.properties());\n    }], [[StringType, ObjectType], function (ctx, ref) {\n      var key = ref[0];\n      var obj = ref[1];\n      return get(key.evaluate(ctx), obj.evaluate(ctx));\n    }]]\n  },\n  'feature-state': [ValueType, [StringType], function (ctx, ref) {\n    var key = ref[0];\n    return get(key.evaluate(ctx), ctx.featureState || {});\n  }],\n  'properties': [ObjectType, [], function (ctx) {\n    return ctx.properties();\n  }],\n  'geometry-type': [StringType, [], function (ctx) {\n    return ctx.geometryType();\n  }],\n  'id': [ValueType, [], function (ctx) {\n    return ctx.id();\n  }],\n  'zoom': [NumberType, [], function (ctx) {\n    return ctx.globals.zoom;\n  }],\n  'pitch': [NumberType, [], function (ctx) {\n    return ctx.globals.pitch || 0;\n  }],\n  'distance-from-center': [NumberType, [], function (ctx) {\n    return ctx.distanceFromCenter();\n  }],\n  'heatmap-density': [NumberType, [], function (ctx) {\n    return ctx.globals.heatmapDensity || 0;\n  }],\n  'line-progress': [NumberType, [], function (ctx) {\n    return ctx.globals.lineProgress || 0;\n  }],\n  'sky-radial-progress': [NumberType, [], function (ctx) {\n    return ctx.globals.skyRadialProgress || 0;\n  }],\n  'accumulated': [ValueType, [], function (ctx) {\n    return ctx.globals.accumulated === undefined ? null : ctx.globals.accumulated;\n  }],\n  '+': [NumberType, varargs(NumberType), function (ctx, args) {\n    var result = 0;\n    for (var i = 0, list = args; i < list.length; i += 1) {\n      var arg = list[i];\n      result += arg.evaluate(ctx);\n    }\n    return result;\n  }],\n  '*': [NumberType, varargs(NumberType), function (ctx, args) {\n    var result = 1;\n    for (var i = 0, list = args; i < list.length; i += 1) {\n      var arg = list[i];\n      result *= arg.evaluate(ctx);\n    }\n    return result;\n  }],\n  '-': {\n    type: NumberType,\n    overloads: [[[NumberType, NumberType], function (ctx, ref) {\n      var a = ref[0];\n      var b = ref[1];\n      return a.evaluate(ctx) - b.evaluate(ctx);\n    }], [[NumberType], function (ctx, ref) {\n      var a = ref[0];\n      return -a.evaluate(ctx);\n    }]]\n  },\n  '/': [NumberType, [NumberType, NumberType], function (ctx, ref) {\n    var a = ref[0];\n    var b = ref[1];\n    return a.evaluate(ctx) / b.evaluate(ctx);\n  }],\n  '%': [NumberType, [NumberType, NumberType], function (ctx, ref) {\n    var a = ref[0];\n    var b = ref[1];\n    return a.evaluate(ctx) % b.evaluate(ctx);\n  }],\n  'ln2': [NumberType, [], function () {\n    return Math.LN2;\n  }],\n  'pi': [NumberType, [], function () {\n    return Math.PI;\n  }],\n  'e': [NumberType, [], function () {\n    return Math.E;\n  }],\n  '^': [NumberType, [NumberType, NumberType], function (ctx, ref) {\n    var b = ref[0];\n    var e = ref[1];\n    return Math.pow(b.evaluate(ctx), e.evaluate(ctx));\n  }],\n  'sqrt': [NumberType, [NumberType], function (ctx, ref) {\n    var x = ref[0];\n    return Math.sqrt(x.evaluate(ctx));\n  }],\n  'log10': [NumberType, [NumberType], function (ctx, ref) {\n    var n = ref[0];\n    return Math.log(n.evaluate(ctx)) / Math.LN10;\n  }],\n  'ln': [NumberType, [NumberType], function (ctx, ref) {\n    var n = ref[0];\n    return Math.log(n.evaluate(ctx));\n  }],\n  'log2': [NumberType, [NumberType], function (ctx, ref) {\n    var n = ref[0];\n    return Math.log(n.evaluate(ctx)) / Math.LN2;\n  }],\n  'sin': [NumberType, [NumberType], function (ctx, ref) {\n    var n = ref[0];\n    return Math.sin(n.evaluate(ctx));\n  }],\n  'cos': [NumberType, [NumberType], function (ctx, ref) {\n    var n = ref[0];\n    return Math.cos(n.evaluate(ctx));\n  }],\n  'tan': [NumberType, [NumberType], function (ctx, ref) {\n    var n = ref[0];\n    return Math.tan(n.evaluate(ctx));\n  }],\n  'asin': [NumberType, [NumberType], function (ctx, ref) {\n    var n = ref[0];\n    return Math.asin(n.evaluate(ctx));\n  }],\n  'acos': [NumberType, [NumberType], function (ctx, ref) {\n    var n = ref[0];\n    return Math.acos(n.evaluate(ctx));\n  }],\n  'atan': [NumberType, [NumberType], function (ctx, ref) {\n    var n = ref[0];\n    return Math.atan(n.evaluate(ctx));\n  }],\n  'min': [NumberType, varargs(NumberType), function (ctx, args) {\n    return Math.min.apply(Math, args.map(function (arg) {\n      return arg.evaluate(ctx);\n    }));\n  }],\n  'max': [NumberType, varargs(NumberType), function (ctx, args) {\n    return Math.max.apply(Math, args.map(function (arg) {\n      return arg.evaluate(ctx);\n    }));\n  }],\n  'abs': [NumberType, [NumberType], function (ctx, ref) {\n    var n = ref[0];\n    return Math.abs(n.evaluate(ctx));\n  }],\n  'round': [NumberType, [NumberType], function (ctx, ref) {\n    var n = ref[0];\n    var v = n.evaluate(ctx);\n    // Javascript's Math.round() rounds towards +Infinity for halfway\n    // values, even when they're negative. It's more common to round\n    // away from 0 (e.g., this is what python and C++ do)\n    return v < 0 ? -Math.round(-v) : Math.round(v);\n  }],\n  'floor': [NumberType, [NumberType], function (ctx, ref) {\n    var n = ref[0];\n    return Math.floor(n.evaluate(ctx));\n  }],\n  'ceil': [NumberType, [NumberType], function (ctx, ref) {\n    var n = ref[0];\n    return Math.ceil(n.evaluate(ctx));\n  }],\n  'filter-==': [BooleanType, [StringType, ValueType], function (ctx, ref) {\n    var k = ref[0];\n    var v = ref[1];\n    return ctx.properties()[k.value] === v.value;\n  }],\n  'filter-id-==': [BooleanType, [ValueType], function (ctx, ref) {\n    var v = ref[0];\n    return ctx.id() === v.value;\n  }],\n  'filter-type-==': [BooleanType, [StringType], function (ctx, ref) {\n    var v = ref[0];\n    return ctx.geometryType() === v.value;\n  }],\n  'filter-<': [BooleanType, [StringType, ValueType], function (ctx, ref) {\n    var k = ref[0];\n    var v = ref[1];\n    var a = ctx.properties()[k.value];\n    var b = v.value;\n    return typeof a === typeof b && a < b;\n  }],\n  'filter-id-<': [BooleanType, [ValueType], function (ctx, ref) {\n    var v = ref[0];\n    var a = ctx.id();\n    var b = v.value;\n    return typeof a === typeof b && a < b;\n  }],\n  'filter->': [BooleanType, [StringType, ValueType], function (ctx, ref) {\n    var k = ref[0];\n    var v = ref[1];\n    var a = ctx.properties()[k.value];\n    var b = v.value;\n    return typeof a === typeof b && a > b;\n  }],\n  'filter-id->': [BooleanType, [ValueType], function (ctx, ref) {\n    var v = ref[0];\n    var a = ctx.id();\n    var b = v.value;\n    return typeof a === typeof b && a > b;\n  }],\n  'filter-<=': [BooleanType, [StringType, ValueType], function (ctx, ref) {\n    var k = ref[0];\n    var v = ref[1];\n    var a = ctx.properties()[k.value];\n    var b = v.value;\n    return typeof a === typeof b && a <= b;\n  }],\n  'filter-id-<=': [BooleanType, [ValueType], function (ctx, ref) {\n    var v = ref[0];\n    var a = ctx.id();\n    var b = v.value;\n    return typeof a === typeof b && a <= b;\n  }],\n  'filter->=': [BooleanType, [StringType, ValueType], function (ctx, ref) {\n    var k = ref[0];\n    var v = ref[1];\n    var a = ctx.properties()[k.value];\n    var b = v.value;\n    return typeof a === typeof b && a >= b;\n  }],\n  'filter-id->=': [BooleanType, [ValueType], function (ctx, ref) {\n    var v = ref[0];\n    var a = ctx.id();\n    var b = v.value;\n    return typeof a === typeof b && a >= b;\n  }],\n  'filter-has': [BooleanType, [ValueType], function (ctx, ref) {\n    var k = ref[0];\n    return k.value in ctx.properties();\n  }],\n  'filter-has-id': [BooleanType, [], function (ctx) {\n    return ctx.id() !== null && ctx.id() !== undefined;\n  }],\n  'filter-type-in': [BooleanType, [array$1(StringType)], function (ctx, ref) {\n    var v = ref[0];\n    return v.value.indexOf(ctx.geometryType()) >= 0;\n  }],\n  'filter-id-in': [BooleanType, [array$1(ValueType)], function (ctx, ref) {\n    var v = ref[0];\n    return v.value.indexOf(ctx.id()) >= 0;\n  }],\n  'filter-in-small': [BooleanType, [StringType, array$1(ValueType)],\n  // assumes v is an array literal\n  function (ctx, ref) {\n    var k = ref[0];\n    var v = ref[1];\n    return v.value.indexOf(ctx.properties()[k.value]) >= 0;\n  }],\n  'filter-in-large': [BooleanType, [StringType, array$1(ValueType)],\n  // assumes v is a array literal with values sorted in ascending order and of a single type\n  function (ctx, ref) {\n    var k = ref[0];\n    var v = ref[1];\n    return binarySearch(ctx.properties()[k.value], v.value, 0, v.value.length - 1);\n  }],\n  'all': {\n    type: BooleanType,\n    overloads: [[[BooleanType, BooleanType], function (ctx, ref) {\n      var a = ref[0];\n      var b = ref[1];\n      return a.evaluate(ctx) && b.evaluate(ctx);\n    }], [varargs(BooleanType), function (ctx, args) {\n      for (var i = 0, list = args; i < list.length; i += 1) {\n        var arg = list[i];\n        if (!arg.evaluate(ctx)) {\n          return false;\n        }\n      }\n      return true;\n    }]]\n  },\n  'any': {\n    type: BooleanType,\n    overloads: [[[BooleanType, BooleanType], function (ctx, ref) {\n      var a = ref[0];\n      var b = ref[1];\n      return a.evaluate(ctx) || b.evaluate(ctx);\n    }], [varargs(BooleanType), function (ctx, args) {\n      for (var i = 0, list = args; i < list.length; i += 1) {\n        var arg = list[i];\n        if (arg.evaluate(ctx)) {\n          return true;\n        }\n      }\n      return false;\n    }]]\n  },\n  '!': [BooleanType, [BooleanType], function (ctx, ref) {\n    var b = ref[0];\n    return !b.evaluate(ctx);\n  }],\n  'is-supported-script': [BooleanType, [StringType],\n  // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant\n  function (ctx, ref) {\n    var s = ref[0];\n    var isSupportedScript = ctx.globals && ctx.globals.isSupportedScript;\n    if (isSupportedScript) {\n      return isSupportedScript(s.evaluate(ctx));\n    }\n    return true;\n  }],\n  'upcase': [StringType, [StringType], function (ctx, ref) {\n    var s = ref[0];\n    return s.evaluate(ctx).toUpperCase();\n  }],\n  'downcase': [StringType, [StringType], function (ctx, ref) {\n    var s = ref[0];\n    return s.evaluate(ctx).toLowerCase();\n  }],\n  'concat': [StringType, varargs(ValueType), function (ctx, args) {\n    return args.map(function (arg) {\n      return toString(arg.evaluate(ctx));\n    }).join('');\n  }],\n  'resolved-locale': [StringType, [CollatorType], function (ctx, ref) {\n    var collator = ref[0];\n    return collator.evaluate(ctx).resolvedLocale();\n  }]\n});\nvar definitions = expressions;\n\n//      \n/**\n * A type used for returning and propagating errors. The first element of the union\n * represents success and contains a value, and the second represents an error and\n * contains an error value.\n * @private\n */\nfunction success(value) {\n  return {\n    result: 'success',\n    value: value\n  };\n}\nfunction error(value) {\n  return {\n    result: 'error',\n    value: value\n  };\n}\n\n//      \nfunction supportsPropertyExpression(spec) {\n  return spec['property-type'] === 'data-driven';\n}\nfunction supportsZoomExpression(spec) {\n  return !!spec.expression && spec.expression.parameters.indexOf('zoom') > -1;\n}\nfunction supportsInterpolation(spec) {\n  return !!spec.expression && spec.expression.interpolated;\n}\nfunction isFunction(value) {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\nvar StyleExpression = function StyleExpression(expression, propertySpec) {\n  this.expression = expression;\n  this._warningHistory = {};\n  this._evaluator = new EvaluationContext$1();\n  this._defaultValue = propertySpec ? getDefaultValue(propertySpec) : null;\n  this._enumValues = propertySpec && propertySpec.type === 'enum' ? propertySpec.values : null;\n};\nStyleExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection, featureTileCoord, featureDistanceData) {\n  this._evaluator.globals = globals;\n  this._evaluator.feature = feature;\n  this._evaluator.featureState = featureState;\n  this._evaluator.canonical = canonical || null;\n  this._evaluator.availableImages = availableImages || null;\n  this._evaluator.formattedSection = formattedSection;\n  this._evaluator.featureTileCoord = featureTileCoord || null;\n  this._evaluator.featureDistanceData = featureDistanceData || null;\n  return this.expression.evaluate(this._evaluator);\n};\nStyleExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection, featureTileCoord, featureDistanceData) {\n  this._evaluator.globals = globals;\n  this._evaluator.feature = feature || null;\n  this._evaluator.featureState = featureState || null;\n  this._evaluator.canonical = canonical || null;\n  this._evaluator.availableImages = availableImages || null;\n  this._evaluator.formattedSection = formattedSection || null;\n  this._evaluator.featureTileCoord = featureTileCoord || null;\n  this._evaluator.featureDistanceData = featureDistanceData || null;\n  try {\n    var val = this.expression.evaluate(this._evaluator);\n    // eslint-disable-next-line no-self-compare\n    if (val === null || val === undefined || typeof val === 'number' && val !== val) {\n      return this._defaultValue;\n    }\n    if (this._enumValues && !(val in this._enumValues)) {\n      throw new RuntimeError$1(\"Expected value to be one of \" + Object.keys(this._enumValues).map(function (v) {\n        return JSON.stringify(v);\n      }).join(', ') + \", but found \" + JSON.stringify(val) + \" instead.\");\n    }\n    return val;\n  } catch (e) {\n    if (!this._warningHistory[e.message]) {\n      this._warningHistory[e.message] = true;\n      if (typeof console !== 'undefined') {\n        console.warn(e.message);\n      }\n    }\n    return this._defaultValue;\n  }\n};\nfunction isExpression(expression) {\n  return Array.isArray(expression) && expression.length > 0 && typeof expression[0] === 'string' && expression[0] in definitions;\n}\n/**\n * Parse and typecheck the given style spec JSON expression.  If\n * options.defaultValue is provided, then the resulting StyleExpression's\n * `evaluate()` method will handle errors by logging a warning (once per\n * message) and returning the default value.  Otherwise, it will throw\n * evaluation errors.\n *\n * @private\n */\nfunction createExpression(expression, propertySpec) {\n  var parser = new ParsingContext$1(definitions, [], propertySpec ? getExpectedType(propertySpec) : undefined);\n  // For string-valued properties, coerce to string at the top level rather than asserting.\n  var parsed = parser.parse(expression, undefined, undefined, undefined, propertySpec && propertySpec.type === 'string' ? {\n    typeAnnotation: 'coerce'\n  } : undefined);\n  if (!parsed) {\n    return error(parser.errors);\n  }\n  return success(new StyleExpression(parsed, propertySpec));\n}\nvar ZoomConstantExpression = function ZoomConstantExpression(kind, expression) {\n  this.kind = kind;\n  this._styleExpression = expression;\n  this.isStateDependent = kind !== 'constant' && !isStateConstant(expression.expression);\n};\nZoomConstantExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {\n  return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);\n};\nZoomConstantExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {\n  return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);\n};\nvar ZoomDependentExpression = function ZoomDependentExpression(kind, expression, zoomStops, interpolationType) {\n  this.kind = kind;\n  this.zoomStops = zoomStops;\n  this._styleExpression = expression;\n  this.isStateDependent = kind !== 'camera' && !isStateConstant(expression.expression);\n  this.interpolationType = interpolationType;\n};\nZoomDependentExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {\n  return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);\n};\nZoomDependentExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {\n  return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);\n};\nZoomDependentExpression.prototype.interpolationFactor = function interpolationFactor(input, lower, upper) {\n  if (this.interpolationType) {\n    return Interpolate$1.interpolationFactor(this.interpolationType, input, lower, upper);\n  } else {\n    return 0;\n  }\n};\nfunction createPropertyExpression(expression, propertySpec) {\n  expression = createExpression(expression, propertySpec);\n  if (expression.result === 'error') {\n    return expression;\n  }\n  var parsed = expression.value.expression;\n  var isFeatureConstant$1 = isFeatureConstant(parsed);\n  if (!isFeatureConstant$1 && !supportsPropertyExpression(propertySpec)) {\n    return error([new ParsingError$1('', 'data expressions not supported')]);\n  }\n  var isZoomConstant = isGlobalPropertyConstant(parsed, ['zoom', 'pitch', 'distance-from-center']);\n  if (!isZoomConstant && !supportsZoomExpression(propertySpec)) {\n    return error([new ParsingError$1('', 'zoom expressions not supported')]);\n  }\n  var zoomCurve = findZoomCurve(parsed);\n  if (!zoomCurve && !isZoomConstant) {\n    return error([new ParsingError$1('', '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.')]);\n  } else if (zoomCurve instanceof ParsingError$1) {\n    return error([zoomCurve]);\n  } else if (zoomCurve instanceof Interpolate$1 && !supportsInterpolation(propertySpec)) {\n    return error([new ParsingError$1('', '\"interpolate\" expressions cannot be used with this property')]);\n  }\n  if (!zoomCurve) {\n    return success(isFeatureConstant$1 ? new ZoomConstantExpression('constant', expression.value) : new ZoomConstantExpression('source', expression.value));\n  }\n  var interpolationType = zoomCurve instanceof Interpolate$1 ? zoomCurve.interpolation : undefined;\n  return success(isFeatureConstant$1 ? new ZoomDependentExpression('camera', expression.value, zoomCurve.labels, interpolationType) : new ZoomDependentExpression('composite', expression.value, zoomCurve.labels, interpolationType));\n}\n// Zoom-dependent expressions may only use [\"zoom\"] as the input to a top-level \"step\" or \"interpolate\"\n// expression (collectively referred to as a \"curve\"). The curve may be wrapped in one or more \"let\" or\n// \"coalesce\" expressions.\nfunction findZoomCurve(expression) {\n  var result = null;\n  if (expression instanceof Let$1) {\n    result = findZoomCurve(expression.result);\n  } else if (expression instanceof Coalesce$1) {\n    for (var i = 0, list = expression.args; i < list.length; i += 1) {\n      var arg = list[i];\n      result = findZoomCurve(arg);\n      if (result) {\n        break;\n      }\n    }\n  } else if ((expression instanceof Step$1 || expression instanceof Interpolate$1) && expression.input instanceof CompoundExpression$1 && expression.input.name === 'zoom') {\n    result = expression;\n  }\n  if (result instanceof ParsingError$1) {\n    return result;\n  }\n  expression.eachChild(function (child) {\n    var childResult = findZoomCurve(child);\n    if (childResult instanceof ParsingError$1) {\n      result = childResult;\n    } else if (!result && childResult) {\n      result = new ParsingError$1('', '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.');\n    } else if (result && childResult && result !== childResult) {\n      result = new ParsingError$1('', 'Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression.');\n    }\n  });\n  return result;\n}\nfunction getExpectedType(spec) {\n  var types = {\n    color: ColorType,\n    string: StringType,\n    number: NumberType,\n    enum: StringType,\n    boolean: BooleanType,\n    formatted: FormattedType,\n    resolvedImage: ResolvedImageType\n  };\n  if (spec.type === 'array') {\n    return array$1(types[spec.value] || ValueType, spec.length);\n  }\n  return types[spec.type];\n}\nfunction getDefaultValue(spec) {\n  if (spec.type === 'color' && (isFunction(spec.default) || Array.isArray(spec.default))) {\n    // Special case for heatmap-color: it uses the 'default:' to define a\n    // default color ramp, but createExpression expects a simple value to fall\n    // back to in case of runtime errors\n    return new Color$1(0, 0, 0, 0);\n  } else if (spec.type === 'color') {\n    return Color$1.parse(spec.default) || null;\n  } else if (spec.default === undefined) {\n    return null;\n  } else {\n    return spec.default;\n  }\n}\n\n//      \n// Turn jsonlint-lines-primitives objects into primitive objects\nfunction unbundle(value) {\n  if (value instanceof Number || value instanceof String || value instanceof Boolean) {\n    return value.valueOf();\n  } else {\n    return value;\n  }\n}\nfunction deepUnbundle(value) {\n  if (Array.isArray(value)) {\n    return value.map(deepUnbundle);\n  } else if (value instanceof Object && !(value instanceof Number || value instanceof String || value instanceof Boolean)) {\n    var unbundledValue = {};\n    for (var key in value) {\n      unbundledValue[key] = deepUnbundle(value[key]);\n    }\n    return unbundledValue;\n  }\n  return unbundle(value);\n}\nvar spec = {\n  \"$version\": 8,\n  \"$root\": {\n    \"version\": {\n      \"required\": true,\n      \"type\": \"enum\",\n      \"values\": [8]\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"metadata\": {\n      \"type\": \"*\"\n    },\n    \"center\": {\n      \"type\": \"array\",\n      \"value\": \"number\"\n    },\n    \"zoom\": {\n      \"type\": \"number\"\n    },\n    \"bearing\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"period\": 360,\n      \"units\": \"degrees\"\n    },\n    \"pitch\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"units\": \"degrees\"\n    },\n    \"light\": {\n      \"type\": \"light\"\n    },\n    \"terrain\": {\n      \"type\": \"terrain\"\n    },\n    \"fog\": {\n      \"type\": \"fog\"\n    },\n    \"sources\": {\n      \"required\": true,\n      \"type\": \"sources\"\n    },\n    \"sprite\": {\n      \"type\": \"string\"\n    },\n    \"glyphs\": {\n      \"type\": \"string\"\n    },\n    \"transition\": {\n      \"type\": \"transition\"\n    },\n    \"projection\": {\n      \"type\": \"projection\"\n    },\n    \"layers\": {\n      \"required\": true,\n      \"type\": \"array\",\n      \"value\": \"layer\"\n    }\n  },\n  \"sources\": {\n    \"*\": {\n      \"type\": \"source\"\n    }\n  },\n  \"source\": [\"source_vector\", \"source_raster\", \"source_raster_dem\", \"source_geojson\", \"source_video\", \"source_image\"],\n  \"source_vector\": {\n    \"type\": {\n      \"required\": true,\n      \"type\": \"enum\",\n      \"values\": {\n        \"vector\": {}\n      }\n    },\n    \"url\": {\n      \"type\": \"string\"\n    },\n    \"tiles\": {\n      \"type\": \"array\",\n      \"value\": \"string\"\n    },\n    \"bounds\": {\n      \"type\": \"array\",\n      \"value\": \"number\",\n      \"length\": 4,\n      \"default\": [-180, -85.051129, 180, 85.051129]\n    },\n    \"scheme\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"xyz\": {},\n        \"tms\": {}\n      },\n      \"default\": \"xyz\"\n    },\n    \"minzoom\": {\n      \"type\": \"number\",\n      \"default\": 0\n    },\n    \"maxzoom\": {\n      \"type\": \"number\",\n      \"default\": 22\n    },\n    \"attribution\": {\n      \"type\": \"string\"\n    },\n    \"promoteId\": {\n      \"type\": \"promoteId\"\n    },\n    \"volatile\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"*\": {\n      \"type\": \"*\"\n    }\n  },\n  \"source_raster\": {\n    \"type\": {\n      \"required\": true,\n      \"type\": \"enum\",\n      \"values\": {\n        \"raster\": {}\n      }\n    },\n    \"url\": {\n      \"type\": \"string\"\n    },\n    \"tiles\": {\n      \"type\": \"array\",\n      \"value\": \"string\"\n    },\n    \"bounds\": {\n      \"type\": \"array\",\n      \"value\": \"number\",\n      \"length\": 4,\n      \"default\": [-180, -85.051129, 180, 85.051129]\n    },\n    \"minzoom\": {\n      \"type\": \"number\",\n      \"default\": 0\n    },\n    \"maxzoom\": {\n      \"type\": \"number\",\n      \"default\": 22\n    },\n    \"tileSize\": {\n      \"type\": \"number\",\n      \"default\": 512,\n      \"units\": \"pixels\"\n    },\n    \"scheme\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"xyz\": {},\n        \"tms\": {}\n      },\n      \"default\": \"xyz\"\n    },\n    \"attribution\": {\n      \"type\": \"string\"\n    },\n    \"volatile\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"*\": {\n      \"type\": \"*\"\n    }\n  },\n  \"source_raster_dem\": {\n    \"type\": {\n      \"required\": true,\n      \"type\": \"enum\",\n      \"values\": {\n        \"raster-dem\": {}\n      }\n    },\n    \"url\": {\n      \"type\": \"string\"\n    },\n    \"tiles\": {\n      \"type\": \"array\",\n      \"value\": \"string\"\n    },\n    \"bounds\": {\n      \"type\": \"array\",\n      \"value\": \"number\",\n      \"length\": 4,\n      \"default\": [-180, -85.051129, 180, 85.051129]\n    },\n    \"minzoom\": {\n      \"type\": \"number\",\n      \"default\": 0\n    },\n    \"maxzoom\": {\n      \"type\": \"number\",\n      \"default\": 22\n    },\n    \"tileSize\": {\n      \"type\": \"number\",\n      \"default\": 512,\n      \"units\": \"pixels\"\n    },\n    \"attribution\": {\n      \"type\": \"string\"\n    },\n    \"encoding\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"terrarium\": {},\n        \"mapbox\": {}\n      },\n      \"default\": \"mapbox\"\n    },\n    \"volatile\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"*\": {\n      \"type\": \"*\"\n    }\n  },\n  \"source_geojson\": {\n    \"type\": {\n      \"required\": true,\n      \"type\": \"enum\",\n      \"values\": {\n        \"geojson\": {}\n      }\n    },\n    \"data\": {\n      \"type\": \"*\"\n    },\n    \"maxzoom\": {\n      \"type\": \"number\",\n      \"default\": 18\n    },\n    \"attribution\": {\n      \"type\": \"string\"\n    },\n    \"buffer\": {\n      \"type\": \"number\",\n      \"default\": 128,\n      \"maximum\": 512,\n      \"minimum\": 0\n    },\n    \"filter\": {\n      \"type\": \"*\"\n    },\n    \"tolerance\": {\n      \"type\": \"number\",\n      \"default\": 0.375\n    },\n    \"cluster\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"clusterRadius\": {\n      \"type\": \"number\",\n      \"default\": 50,\n      \"minimum\": 0\n    },\n    \"clusterMaxZoom\": {\n      \"type\": \"number\"\n    },\n    \"clusterMinPoints\": {\n      \"type\": \"number\"\n    },\n    \"clusterProperties\": {\n      \"type\": \"*\"\n    },\n    \"lineMetrics\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"generateId\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"promoteId\": {\n      \"type\": \"promoteId\"\n    }\n  },\n  \"source_video\": {\n    \"type\": {\n      \"required\": true,\n      \"type\": \"enum\",\n      \"values\": {\n        \"video\": {}\n      }\n    },\n    \"urls\": {\n      \"required\": true,\n      \"type\": \"array\",\n      \"value\": \"string\"\n    },\n    \"coordinates\": {\n      \"required\": true,\n      \"type\": \"array\",\n      \"length\": 4,\n      \"value\": {\n        \"type\": \"array\",\n        \"length\": 2,\n        \"value\": \"number\"\n      }\n    }\n  },\n  \"source_image\": {\n    \"type\": {\n      \"required\": true,\n      \"type\": \"enum\",\n      \"values\": {\n        \"image\": {}\n      }\n    },\n    \"url\": {\n      \"required\": true,\n      \"type\": \"string\"\n    },\n    \"coordinates\": {\n      \"required\": true,\n      \"type\": \"array\",\n      \"length\": 4,\n      \"value\": {\n        \"type\": \"array\",\n        \"length\": 2,\n        \"value\": \"number\"\n      }\n    }\n  },\n  \"layer\": {\n    \"id\": {\n      \"type\": \"string\",\n      \"required\": true\n    },\n    \"type\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"fill\": {},\n        \"line\": {},\n        \"symbol\": {},\n        \"circle\": {},\n        \"heatmap\": {},\n        \"fill-extrusion\": {},\n        \"raster\": {},\n        \"hillshade\": {},\n        \"background\": {},\n        \"sky\": {}\n      },\n      \"required\": true\n    },\n    \"metadata\": {\n      \"type\": \"*\"\n    },\n    \"source\": {\n      \"type\": \"string\"\n    },\n    \"source-layer\": {\n      \"type\": \"string\"\n    },\n    \"minzoom\": {\n      \"type\": \"number\",\n      \"minimum\": 0,\n      \"maximum\": 24\n    },\n    \"maxzoom\": {\n      \"type\": \"number\",\n      \"minimum\": 0,\n      \"maximum\": 24\n    },\n    \"filter\": {\n      \"type\": \"filter\"\n    },\n    \"layout\": {\n      \"type\": \"layout\"\n    },\n    \"paint\": {\n      \"type\": \"paint\"\n    }\n  },\n  \"layout\": [\"layout_fill\", \"layout_line\", \"layout_circle\", \"layout_heatmap\", \"layout_fill-extrusion\", \"layout_symbol\", \"layout_raster\", \"layout_hillshade\", \"layout_background\", \"layout_sky\"],\n  \"layout_background\": {\n    \"visibility\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"visible\": {},\n        \"none\": {}\n      },\n      \"default\": \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  \"layout_sky\": {\n    \"visibility\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"visible\": {},\n        \"none\": {}\n      },\n      \"default\": \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  \"layout_fill\": {\n    \"fill-sort-key\": {\n      \"type\": \"number\",\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"visibility\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"visible\": {},\n        \"none\": {}\n      },\n      \"default\": \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  \"layout_circle\": {\n    \"circle-sort-key\": {\n      \"type\": \"number\",\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"visibility\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"visible\": {},\n        \"none\": {}\n      },\n      \"default\": \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  \"layout_heatmap\": {\n    \"visibility\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"visible\": {},\n        \"none\": {}\n      },\n      \"default\": \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  \"layout_fill-extrusion\": {\n    \"visibility\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"visible\": {},\n        \"none\": {}\n      },\n      \"default\": \"visible\",\n      \"property-type\": \"constant\"\n    },\n    \"fill-extrusion-edge-radius\": {\n      \"type\": \"number\",\n      \"private\": true,\n      \"default\": 0,\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"property-type\": \"constant\"\n    }\n  },\n  \"layout_line\": {\n    \"line-cap\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"butt\": {},\n        \"round\": {},\n        \"square\": {}\n      },\n      \"default\": \"butt\",\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"line-join\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"bevel\": {},\n        \"round\": {},\n        \"miter\": {}\n      },\n      \"default\": \"miter\",\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"line-miter-limit\": {\n      \"type\": \"number\",\n      \"default\": 2,\n      \"requires\": [{\n        \"line-join\": \"miter\"\n      }],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"line-round-limit\": {\n      \"type\": \"number\",\n      \"default\": 1.05,\n      \"requires\": [{\n        \"line-join\": \"round\"\n      }],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"line-sort-key\": {\n      \"type\": \"number\",\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"visibility\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"visible\": {},\n        \"none\": {}\n      },\n      \"default\": \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  \"layout_symbol\": {\n    \"symbol-placement\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"point\": {},\n        \"line\": {},\n        \"line-center\": {}\n      },\n      \"default\": \"point\",\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"symbol-spacing\": {\n      \"type\": \"number\",\n      \"default\": 250,\n      \"minimum\": 1,\n      \"units\": \"pixels\",\n      \"requires\": [{\n        \"symbol-placement\": \"line\"\n      }],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"symbol-avoid-edges\": {\n      \"type\": \"boolean\",\n      \"default\": false,\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"symbol-sort-key\": {\n      \"type\": \"number\",\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"symbol-z-order\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"auto\": {},\n        \"viewport-y\": {},\n        \"source\": {}\n      },\n      \"default\": \"auto\",\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-allow-overlap\": {\n      \"type\": \"boolean\",\n      \"default\": false,\n      \"requires\": [\"icon-image\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-ignore-placement\": {\n      \"type\": \"boolean\",\n      \"default\": false,\n      \"requires\": [\"icon-image\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-optional\": {\n      \"type\": \"boolean\",\n      \"default\": false,\n      \"requires\": [\"icon-image\", \"text-field\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-rotation-alignment\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"map\": {},\n        \"viewport\": {},\n        \"auto\": {}\n      },\n      \"default\": \"auto\",\n      \"requires\": [\"icon-image\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-size\": {\n      \"type\": \"number\",\n      \"default\": 1,\n      \"minimum\": 0,\n      \"units\": \"factor of the original icon size\",\n      \"requires\": [\"icon-image\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-text-fit\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"none\": {},\n        \"width\": {},\n        \"height\": {},\n        \"both\": {}\n      },\n      \"default\": \"none\",\n      \"requires\": [\"icon-image\", \"text-field\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-text-fit-padding\": {\n      \"type\": \"array\",\n      \"value\": \"number\",\n      \"length\": 4,\n      \"default\": [0, 0, 0, 0],\n      \"units\": \"pixels\",\n      \"requires\": [\"icon-image\", \"text-field\", {\n        \"icon-text-fit\": [\"both\", \"width\", \"height\"]\n      }],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-image\": {\n      \"type\": \"resolvedImage\",\n      \"tokens\": true,\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-rotate\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"period\": 360,\n      \"units\": \"degrees\",\n      \"requires\": [\"icon-image\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-padding\": {\n      \"type\": \"number\",\n      \"default\": 2,\n      \"minimum\": 0,\n      \"units\": \"pixels\",\n      \"requires\": [\"icon-image\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-keep-upright\": {\n      \"type\": \"boolean\",\n      \"default\": false,\n      \"requires\": [\"icon-image\", {\n        \"icon-rotation-alignment\": \"map\"\n      }, {\n        \"symbol-placement\": [\"line\", \"line-center\"]\n      }],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-offset\": {\n      \"type\": \"array\",\n      \"value\": \"number\",\n      \"length\": 2,\n      \"default\": [0, 0],\n      \"requires\": [\"icon-image\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-anchor\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"center\": {},\n        \"left\": {},\n        \"right\": {},\n        \"top\": {},\n        \"bottom\": {},\n        \"top-left\": {},\n        \"top-right\": {},\n        \"bottom-left\": {},\n        \"bottom-right\": {}\n      },\n      \"default\": \"center\",\n      \"requires\": [\"icon-image\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-pitch-alignment\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"map\": {},\n        \"viewport\": {},\n        \"auto\": {}\n      },\n      \"default\": \"auto\",\n      \"requires\": [\"icon-image\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-pitch-alignment\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"map\": {},\n        \"viewport\": {},\n        \"auto\": {}\n      },\n      \"default\": \"auto\",\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-rotation-alignment\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"map\": {},\n        \"viewport\": {},\n        \"auto\": {}\n      },\n      \"default\": \"auto\",\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-field\": {\n      \"type\": \"formatted\",\n      \"default\": \"\",\n      \"tokens\": true,\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-font\": {\n      \"type\": \"array\",\n      \"value\": \"string\",\n      \"default\": [\"Open Sans Regular\", \"Arial Unicode MS Regular\"],\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-size\": {\n      \"type\": \"number\",\n      \"default\": 16,\n      \"minimum\": 0,\n      \"units\": \"pixels\",\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-max-width\": {\n      \"type\": \"number\",\n      \"default\": 10,\n      \"minimum\": 0,\n      \"units\": \"ems\",\n      \"requires\": [\"text-field\", {\n        \"symbol-placement\": [\"point\"]\n      }],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-line-height\": {\n      \"type\": \"number\",\n      \"default\": 1.2,\n      \"units\": \"ems\",\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-letter-spacing\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"units\": \"ems\",\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-justify\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"auto\": {},\n        \"left\": {},\n        \"center\": {},\n        \"right\": {}\n      },\n      \"default\": \"center\",\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-radial-offset\": {\n      \"type\": \"number\",\n      \"units\": \"ems\",\n      \"default\": 0,\n      \"requires\": [\"text-field\"],\n      \"property-type\": \"data-driven\",\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\"]\n      }\n    },\n    \"text-variable-anchor\": {\n      \"type\": \"array\",\n      \"value\": \"enum\",\n      \"values\": {\n        \"center\": {},\n        \"left\": {},\n        \"right\": {},\n        \"top\": {},\n        \"bottom\": {},\n        \"top-left\": {},\n        \"top-right\": {},\n        \"bottom-left\": {},\n        \"bottom-right\": {}\n      },\n      \"requires\": [\"text-field\", {\n        \"symbol-placement\": [\"point\"]\n      }],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-anchor\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"center\": {},\n        \"left\": {},\n        \"right\": {},\n        \"top\": {},\n        \"bottom\": {},\n        \"top-left\": {},\n        \"top-right\": {},\n        \"bottom-left\": {},\n        \"bottom-right\": {}\n      },\n      \"default\": \"center\",\n      \"requires\": [\"text-field\", {\n        \"!\": \"text-variable-anchor\"\n      }],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-max-angle\": {\n      \"type\": \"number\",\n      \"default\": 45,\n      \"units\": \"degrees\",\n      \"requires\": [\"text-field\", {\n        \"symbol-placement\": [\"line\", \"line-center\"]\n      }],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-writing-mode\": {\n      \"type\": \"array\",\n      \"value\": \"enum\",\n      \"values\": {\n        \"horizontal\": {},\n        \"vertical\": {}\n      },\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-rotate\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"period\": 360,\n      \"units\": \"degrees\",\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-padding\": {\n      \"type\": \"number\",\n      \"default\": 2,\n      \"minimum\": 0,\n      \"units\": \"pixels\",\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-keep-upright\": {\n      \"type\": \"boolean\",\n      \"default\": true,\n      \"requires\": [\"text-field\", {\n        \"text-rotation-alignment\": \"map\"\n      }, {\n        \"symbol-placement\": [\"line\", \"line-center\"]\n      }],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-transform\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"none\": {},\n        \"uppercase\": {},\n        \"lowercase\": {}\n      },\n      \"default\": \"none\",\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-offset\": {\n      \"type\": \"array\",\n      \"value\": \"number\",\n      \"units\": \"ems\",\n      \"length\": 2,\n      \"default\": [0, 0],\n      \"requires\": [\"text-field\", {\n        \"!\": \"text-radial-offset\"\n      }],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-allow-overlap\": {\n      \"type\": \"boolean\",\n      \"default\": false,\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-ignore-placement\": {\n      \"type\": \"boolean\",\n      \"default\": false,\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-optional\": {\n      \"type\": \"boolean\",\n      \"default\": false,\n      \"requires\": [\"text-field\", \"icon-image\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"visibility\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"visible\": {},\n        \"none\": {}\n      },\n      \"default\": \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  \"layout_raster\": {\n    \"visibility\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"visible\": {},\n        \"none\": {}\n      },\n      \"default\": \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  \"layout_hillshade\": {\n    \"visibility\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"visible\": {},\n        \"none\": {}\n      },\n      \"default\": \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  \"filter\": {\n    \"type\": \"array\",\n    \"value\": \"*\"\n  },\n  \"filter_symbol\": {\n    \"type\": \"boolean\",\n    \"default\": false,\n    \"transition\": false,\n    \"property-type\": \"data-driven\",\n    \"expression\": {\n      \"interpolated\": false,\n      \"parameters\": [\"zoom\", \"feature\", \"pitch\", \"distance-from-center\"]\n    }\n  },\n  \"filter_fill\": {\n    \"type\": \"boolean\",\n    \"default\": false,\n    \"transition\": false,\n    \"property-type\": \"data-driven\",\n    \"expression\": {\n      \"interpolated\": false,\n      \"parameters\": [\"zoom\", \"feature\"]\n    }\n  },\n  \"filter_line\": {\n    \"type\": \"boolean\",\n    \"default\": false,\n    \"transition\": false,\n    \"property-type\": \"data-driven\",\n    \"expression\": {\n      \"interpolated\": false,\n      \"parameters\": [\"zoom\", \"feature\"]\n    }\n  },\n  \"filter_circle\": {\n    \"type\": \"boolean\",\n    \"default\": false,\n    \"transition\": false,\n    \"property-type\": \"data-driven\",\n    \"expression\": {\n      \"interpolated\": false,\n      \"parameters\": [\"zoom\", \"feature\"]\n    }\n  },\n  \"filter_fill-extrusion\": {\n    \"type\": \"boolean\",\n    \"default\": false,\n    \"transition\": false,\n    \"property-type\": \"data-driven\",\n    \"expression\": {\n      \"interpolated\": false,\n      \"parameters\": [\"zoom\", \"feature\"]\n    }\n  },\n  \"filter_heatmap\": {\n    \"type\": \"boolean\",\n    \"default\": false,\n    \"transition\": false,\n    \"property-type\": \"data-driven\",\n    \"expression\": {\n      \"interpolated\": false,\n      \"parameters\": [\"zoom\", \"feature\"]\n    }\n  },\n  \"filter_operator\": {\n    \"type\": \"enum\",\n    \"values\": {\n      \"==\": {},\n      \"!=\": {},\n      \">\": {},\n      \">=\": {},\n      \"<\": {},\n      \"<=\": {},\n      \"in\": {},\n      \"!in\": {},\n      \"all\": {},\n      \"any\": {},\n      \"none\": {},\n      \"has\": {},\n      \"!has\": {},\n      \"within\": {}\n    }\n  },\n  \"geometry_type\": {\n    \"type\": \"enum\",\n    \"values\": {\n      \"Point\": {},\n      \"LineString\": {},\n      \"Polygon\": {}\n    }\n  },\n  \"function\": {\n    \"expression\": {\n      \"type\": \"expression\"\n    },\n    \"stops\": {\n      \"type\": \"array\",\n      \"value\": \"function_stop\"\n    },\n    \"base\": {\n      \"type\": \"number\",\n      \"default\": 1,\n      \"minimum\": 0\n    },\n    \"property\": {\n      \"type\": \"string\",\n      \"default\": \"$zoom\"\n    },\n    \"type\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"identity\": {},\n        \"exponential\": {},\n        \"interval\": {},\n        \"categorical\": {}\n      },\n      \"default\": \"exponential\"\n    },\n    \"colorSpace\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"rgb\": {},\n        \"lab\": {},\n        \"hcl\": {}\n      },\n      \"default\": \"rgb\"\n    },\n    \"default\": {\n      \"type\": \"*\",\n      \"required\": false\n    }\n  },\n  \"function_stop\": {\n    \"type\": \"array\",\n    \"minimum\": 0,\n    \"maximum\": 24,\n    \"value\": [\"number\", \"color\"],\n    \"length\": 2\n  },\n  \"expression\": {\n    \"type\": \"array\",\n    \"value\": \"*\",\n    \"minimum\": 1\n  },\n  \"expression_name\": {\n    \"type\": \"enum\",\n    \"values\": {\n      \"let\": {\n        \"group\": \"Variable binding\"\n      },\n      \"var\": {\n        \"group\": \"Variable binding\"\n      },\n      \"literal\": {\n        \"group\": \"Types\"\n      },\n      \"array\": {\n        \"group\": \"Types\"\n      },\n      \"at\": {\n        \"group\": \"Lookup\"\n      },\n      \"in\": {\n        \"group\": \"Lookup\"\n      },\n      \"index-of\": {\n        \"group\": \"Lookup\"\n      },\n      \"slice\": {\n        \"group\": \"Lookup\"\n      },\n      \"case\": {\n        \"group\": \"Decision\"\n      },\n      \"match\": {\n        \"group\": \"Decision\"\n      },\n      \"coalesce\": {\n        \"group\": \"Decision\"\n      },\n      \"step\": {\n        \"group\": \"Ramps, scales, curves\"\n      },\n      \"interpolate\": {\n        \"group\": \"Ramps, scales, curves\"\n      },\n      \"interpolate-hcl\": {\n        \"group\": \"Ramps, scales, curves\"\n      },\n      \"interpolate-lab\": {\n        \"group\": \"Ramps, scales, curves\"\n      },\n      \"ln2\": {\n        \"group\": \"Math\"\n      },\n      \"pi\": {\n        \"group\": \"Math\"\n      },\n      \"e\": {\n        \"group\": \"Math\"\n      },\n      \"typeof\": {\n        \"group\": \"Types\"\n      },\n      \"string\": {\n        \"group\": \"Types\"\n      },\n      \"number\": {\n        \"group\": \"Types\"\n      },\n      \"boolean\": {\n        \"group\": \"Types\"\n      },\n      \"object\": {\n        \"group\": \"Types\"\n      },\n      \"collator\": {\n        \"group\": \"Types\"\n      },\n      \"format\": {\n        \"group\": \"Types\"\n      },\n      \"image\": {\n        \"group\": \"Types\"\n      },\n      \"number-format\": {\n        \"group\": \"Types\"\n      },\n      \"to-string\": {\n        \"group\": \"Types\"\n      },\n      \"to-number\": {\n        \"group\": \"Types\"\n      },\n      \"to-boolean\": {\n        \"group\": \"Types\"\n      },\n      \"to-rgba\": {\n        \"group\": \"Color\"\n      },\n      \"to-color\": {\n        \"group\": \"Types\"\n      },\n      \"rgb\": {\n        \"group\": \"Color\"\n      },\n      \"rgba\": {\n        \"group\": \"Color\"\n      },\n      \"get\": {\n        \"group\": \"Lookup\"\n      },\n      \"has\": {\n        \"group\": \"Lookup\"\n      },\n      \"length\": {\n        \"group\": \"Lookup\"\n      },\n      \"properties\": {\n        \"group\": \"Feature data\"\n      },\n      \"feature-state\": {\n        \"group\": \"Feature data\"\n      },\n      \"geometry-type\": {\n        \"group\": \"Feature data\"\n      },\n      \"id\": {\n        \"group\": \"Feature data\"\n      },\n      \"zoom\": {\n        \"group\": \"Camera\"\n      },\n      \"pitch\": {\n        \"group\": \"Camera\"\n      },\n      \"distance-from-center\": {\n        \"group\": \"Camera\"\n      },\n      \"heatmap-density\": {\n        \"group\": \"Heatmap\"\n      },\n      \"line-progress\": {\n        \"group\": \"Feature data\"\n      },\n      \"sky-radial-progress\": {\n        \"group\": \"sky\"\n      },\n      \"accumulated\": {\n        \"group\": \"Feature data\"\n      },\n      \"+\": {\n        \"group\": \"Math\"\n      },\n      \"*\": {\n        \"group\": \"Math\"\n      },\n      \"-\": {\n        \"group\": \"Math\"\n      },\n      \"/\": {\n        \"group\": \"Math\"\n      },\n      \"%\": {\n        \"group\": \"Math\"\n      },\n      \"^\": {\n        \"group\": \"Math\"\n      },\n      \"sqrt\": {\n        \"group\": \"Math\"\n      },\n      \"log10\": {\n        \"group\": \"Math\"\n      },\n      \"ln\": {\n        \"group\": \"Math\"\n      },\n      \"log2\": {\n        \"group\": \"Math\"\n      },\n      \"sin\": {\n        \"group\": \"Math\"\n      },\n      \"cos\": {\n        \"group\": \"Math\"\n      },\n      \"tan\": {\n        \"group\": \"Math\"\n      },\n      \"asin\": {\n        \"group\": \"Math\"\n      },\n      \"acos\": {\n        \"group\": \"Math\"\n      },\n      \"atan\": {\n        \"group\": \"Math\"\n      },\n      \"min\": {\n        \"group\": \"Math\"\n      },\n      \"max\": {\n        \"group\": \"Math\"\n      },\n      \"round\": {\n        \"group\": \"Math\"\n      },\n      \"abs\": {\n        \"group\": \"Math\"\n      },\n      \"ceil\": {\n        \"group\": \"Math\"\n      },\n      \"floor\": {\n        \"group\": \"Math\"\n      },\n      \"distance\": {\n        \"group\": \"Math\"\n      },\n      \"==\": {\n        \"group\": \"Decision\"\n      },\n      \"!=\": {\n        \"group\": \"Decision\"\n      },\n      \">\": {\n        \"group\": \"Decision\"\n      },\n      \"<\": {\n        \"group\": \"Decision\"\n      },\n      \">=\": {\n        \"group\": \"Decision\"\n      },\n      \"<=\": {\n        \"group\": \"Decision\"\n      },\n      \"all\": {\n        \"group\": \"Decision\"\n      },\n      \"any\": {\n        \"group\": \"Decision\"\n      },\n      \"!\": {\n        \"group\": \"Decision\"\n      },\n      \"within\": {\n        \"group\": \"Decision\"\n      },\n      \"is-supported-script\": {\n        \"group\": \"String\"\n      },\n      \"upcase\": {\n        \"group\": \"String\"\n      },\n      \"downcase\": {\n        \"group\": \"String\"\n      },\n      \"concat\": {\n        \"group\": \"String\"\n      },\n      \"resolved-locale\": {\n        \"group\": \"String\"\n      }\n    }\n  },\n  \"fog\": {\n    \"range\": {\n      \"type\": \"array\",\n      \"default\": [0.5, 10],\n      \"minimum\": -20,\n      \"maximum\": 20,\n      \"length\": 2,\n      \"value\": \"number\",\n      \"property-type\": \"data-constant\",\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      }\n    },\n    \"color\": {\n      \"type\": \"color\",\n      \"property-type\": \"data-constant\",\n      \"default\": \"#ffffff\",\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"transition\": true\n    },\n    \"high-color\": {\n      \"type\": \"color\",\n      \"property-type\": \"data-constant\",\n      \"default\": \"#245cdf\",\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"transition\": true\n    },\n    \"space-color\": {\n      \"type\": \"color\",\n      \"property-type\": \"data-constant\",\n      \"default\": [\"interpolate\", [\"linear\"], [\"zoom\"], 4, \"#010b19\", 7, \"#367ab9\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"transition\": true\n    },\n    \"horizon-blend\": {\n      \"type\": \"number\",\n      \"property-type\": \"data-constant\",\n      \"default\": [\"interpolate\", [\"linear\"], [\"zoom\"], 4, 0.2, 7, 0.1],\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"transition\": true\n    },\n    \"star-intensity\": {\n      \"type\": \"number\",\n      \"property-type\": \"data-constant\",\n      \"default\": [\"interpolate\", [\"linear\"], [\"zoom\"], 5, 0.35, 6, 0],\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"transition\": true\n    }\n  },\n  \"light\": {\n    \"anchor\": {\n      \"type\": \"enum\",\n      \"default\": \"viewport\",\n      \"values\": {\n        \"map\": {},\n        \"viewport\": {}\n      },\n      \"property-type\": \"data-constant\",\n      \"transition\": false,\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      }\n    },\n    \"position\": {\n      \"type\": \"array\",\n      \"default\": [1.15, 210, 30],\n      \"length\": 3,\n      \"value\": \"number\",\n      \"property-type\": \"data-constant\",\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      }\n    },\n    \"color\": {\n      \"type\": \"color\",\n      \"property-type\": \"data-constant\",\n      \"default\": \"#ffffff\",\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"transition\": true\n    },\n    \"intensity\": {\n      \"type\": \"number\",\n      \"property-type\": \"data-constant\",\n      \"default\": 0.5,\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"transition\": true\n    }\n  },\n  \"projection\": {\n    \"name\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"albers\": {},\n        \"equalEarth\": {},\n        \"equirectangular\": {},\n        \"lambertConformalConic\": {},\n        \"mercator\": {},\n        \"naturalEarth\": {},\n        \"winkelTripel\": {},\n        \"globe\": {}\n      },\n      \"default\": \"mercator\",\n      \"required\": true\n    },\n    \"center\": {\n      \"type\": \"array\",\n      \"length\": 2,\n      \"value\": \"number\",\n      \"property-type\": \"data-constant\",\n      \"minimum\": [-180, -90],\n      \"maximum\": [180, 90],\n      \"transition\": false,\n      \"requires\": [{\n        \"name\": [\"albers\", \"lambertConformalConic\"]\n      }]\n    },\n    \"parallels\": {\n      \"type\": \"array\",\n      \"length\": 2,\n      \"value\": \"number\",\n      \"property-type\": \"data-constant\",\n      \"minimum\": [-90, -90],\n      \"maximum\": [90, 90],\n      \"transition\": false,\n      \"requires\": [{\n        \"name\": [\"albers\", \"lambertConformalConic\"]\n      }]\n    }\n  },\n  \"terrain\": {\n    \"source\": {\n      \"type\": \"string\",\n      \"required\": true\n    },\n    \"exaggeration\": {\n      \"type\": \"number\",\n      \"property-type\": \"data-constant\",\n      \"default\": 1,\n      \"minimum\": 0,\n      \"maximum\": 1000,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"transition\": true,\n      \"requires\": [\"source\"]\n    }\n  },\n  \"paint\": [\"paint_fill\", \"paint_line\", \"paint_circle\", \"paint_heatmap\", \"paint_fill-extrusion\", \"paint_symbol\", \"paint_raster\", \"paint_hillshade\", \"paint_background\", \"paint_sky\"],\n  \"paint_fill\": {\n    \"fill-antialias\": {\n      \"type\": \"boolean\",\n      \"default\": true,\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"fill-opacity\": {\n      \"type\": \"number\",\n      \"default\": 1,\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"fill-color\": {\n      \"type\": \"color\",\n      \"default\": \"#000000\",\n      \"transition\": true,\n      \"requires\": [{\n        \"!\": \"fill-pattern\"\n      }],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"fill-outline-color\": {\n      \"type\": \"color\",\n      \"transition\": true,\n      \"requires\": [{\n        \"!\": \"fill-pattern\"\n      }, {\n        \"fill-antialias\": true\n      }],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"fill-translate\": {\n      \"type\": \"array\",\n      \"value\": \"number\",\n      \"length\": 2,\n      \"default\": [0, 0],\n      \"transition\": true,\n      \"units\": \"pixels\",\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"fill-translate-anchor\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"map\": {},\n        \"viewport\": {}\n      },\n      \"default\": \"map\",\n      \"requires\": [\"fill-translate\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"fill-pattern\": {\n      \"type\": \"resolvedImage\",\n      \"transition\": false,\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    }\n  },\n  \"paint_fill-extrusion\": {\n    \"fill-extrusion-opacity\": {\n      \"type\": \"number\",\n      \"default\": 1,\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"fill-extrusion-color\": {\n      \"type\": \"color\",\n      \"default\": \"#000000\",\n      \"transition\": true,\n      \"requires\": [{\n        \"!\": \"fill-extrusion-pattern\"\n      }],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"fill-extrusion-translate\": {\n      \"type\": \"array\",\n      \"value\": \"number\",\n      \"length\": 2,\n      \"default\": [0, 0],\n      \"transition\": true,\n      \"units\": \"pixels\",\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"fill-extrusion-translate-anchor\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"map\": {},\n        \"viewport\": {}\n      },\n      \"default\": \"map\",\n      \"requires\": [\"fill-extrusion-translate\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"fill-extrusion-pattern\": {\n      \"type\": \"resolvedImage\",\n      \"transition\": false,\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"fill-extrusion-height\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"minimum\": 0,\n      \"units\": \"meters\",\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"fill-extrusion-base\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"minimum\": 0,\n      \"units\": \"meters\",\n      \"transition\": true,\n      \"requires\": [\"fill-extrusion-height\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"fill-extrusion-vertical-gradient\": {\n      \"type\": \"boolean\",\n      \"default\": true,\n      \"transition\": false,\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"fill-extrusion-ambient-occlusion-intensity\": {\n      \"property-type\": \"data-constant\",\n      \"type\": \"number\",\n      \"private\": true,\n      \"default\": 0,\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"transition\": true\n    },\n    \"fill-extrusion-ambient-occlusion-radius\": {\n      \"property-type\": \"data-constant\",\n      \"type\": \"number\",\n      \"private\": true,\n      \"default\": 3,\n      \"minimum\": 0,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"transition\": true,\n      \"requires\": [\"fill-extrusion-edge-radius\"]\n    }\n  },\n  \"paint_line\": {\n    \"line-opacity\": {\n      \"type\": \"number\",\n      \"default\": 1,\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"line-color\": {\n      \"type\": \"color\",\n      \"default\": \"#000000\",\n      \"transition\": true,\n      \"requires\": [{\n        \"!\": \"line-pattern\"\n      }],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"line-translate\": {\n      \"type\": \"array\",\n      \"value\": \"number\",\n      \"length\": 2,\n      \"default\": [0, 0],\n      \"transition\": true,\n      \"units\": \"pixels\",\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"line-translate-anchor\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"map\": {},\n        \"viewport\": {}\n      },\n      \"default\": \"map\",\n      \"requires\": [\"line-translate\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"line-width\": {\n      \"type\": \"number\",\n      \"default\": 1,\n      \"minimum\": 0,\n      \"transition\": true,\n      \"units\": \"pixels\",\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"line-gap-width\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"minimum\": 0,\n      \"transition\": true,\n      \"units\": \"pixels\",\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"line-offset\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"transition\": true,\n      \"units\": \"pixels\",\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"line-blur\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"minimum\": 0,\n      \"transition\": true,\n      \"units\": \"pixels\",\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"line-dasharray\": {\n      \"type\": \"array\",\n      \"value\": \"number\",\n      \"minimum\": 0,\n      \"transition\": false,\n      \"units\": \"line widths\",\n      \"requires\": [{\n        \"!\": \"line-pattern\"\n      }],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"line-pattern\": {\n      \"type\": \"resolvedImage\",\n      \"transition\": false,\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"line-gradient\": {\n      \"type\": \"color\",\n      \"transition\": false,\n      \"requires\": [{\n        \"!\": \"line-pattern\"\n      }, {\n        \"source\": \"geojson\",\n        \"has\": {\n          \"lineMetrics\": true\n        }\n      }],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"line-progress\"]\n      },\n      \"property-type\": \"color-ramp\"\n    },\n    \"line-trim-offset\": {\n      \"type\": \"array\",\n      \"value\": \"number\",\n      \"length\": 2,\n      \"default\": [0, 0],\n      \"minimum\": [0, 0],\n      \"maximum\": [1, 1],\n      \"transition\": false,\n      \"requires\": [{\n        \"source\": \"geojson\",\n        \"has\": {\n          \"lineMetrics\": true\n        }\n      }],\n      \"property-type\": \"constant\"\n    }\n  },\n  \"paint_circle\": {\n    \"circle-radius\": {\n      \"type\": \"number\",\n      \"default\": 5,\n      \"minimum\": 0,\n      \"transition\": true,\n      \"units\": \"pixels\",\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"circle-color\": {\n      \"type\": \"color\",\n      \"default\": \"#000000\",\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"circle-blur\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"circle-opacity\": {\n      \"type\": \"number\",\n      \"default\": 1,\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"circle-translate\": {\n      \"type\": \"array\",\n      \"value\": \"number\",\n      \"length\": 2,\n      \"default\": [0, 0],\n      \"transition\": true,\n      \"units\": \"pixels\",\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"circle-translate-anchor\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"map\": {},\n        \"viewport\": {}\n      },\n      \"default\": \"map\",\n      \"requires\": [\"circle-translate\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"circle-pitch-scale\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"map\": {},\n        \"viewport\": {}\n      },\n      \"default\": \"map\",\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"circle-pitch-alignment\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"map\": {},\n        \"viewport\": {}\n      },\n      \"default\": \"viewport\",\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"circle-stroke-width\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"minimum\": 0,\n      \"transition\": true,\n      \"units\": \"pixels\",\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"circle-stroke-color\": {\n      \"type\": \"color\",\n      \"default\": \"#000000\",\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"circle-stroke-opacity\": {\n      \"type\": \"number\",\n      \"default\": 1,\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    }\n  },\n  \"paint_heatmap\": {\n    \"heatmap-radius\": {\n      \"type\": \"number\",\n      \"default\": 30,\n      \"minimum\": 1,\n      \"transition\": true,\n      \"units\": \"pixels\",\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"heatmap-weight\": {\n      \"type\": \"number\",\n      \"default\": 1,\n      \"minimum\": 0,\n      \"transition\": false,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"heatmap-intensity\": {\n      \"type\": \"number\",\n      \"default\": 1,\n      \"minimum\": 0,\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"heatmap-color\": {\n      \"type\": \"color\",\n      \"default\": [\"interpolate\", [\"linear\"], [\"heatmap-density\"], 0, \"rgba(0, 0, 255, 0)\", 0.1, \"royalblue\", 0.3, \"cyan\", 0.5, \"lime\", 0.7, \"yellow\", 1, \"red\"],\n      \"transition\": false,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"heatmap-density\"]\n      },\n      \"property-type\": \"color-ramp\"\n    },\n    \"heatmap-opacity\": {\n      \"type\": \"number\",\n      \"default\": 1,\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    }\n  },\n  \"paint_symbol\": {\n    \"icon-opacity\": {\n      \"type\": \"number\",\n      \"default\": 1,\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"transition\": true,\n      \"requires\": [\"icon-image\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-color\": {\n      \"type\": \"color\",\n      \"default\": \"#000000\",\n      \"transition\": true,\n      \"requires\": [\"icon-image\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-halo-color\": {\n      \"type\": \"color\",\n      \"default\": \"rgba(0, 0, 0, 0)\",\n      \"transition\": true,\n      \"requires\": [\"icon-image\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-halo-width\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"minimum\": 0,\n      \"transition\": true,\n      \"units\": \"pixels\",\n      \"requires\": [\"icon-image\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-halo-blur\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"minimum\": 0,\n      \"transition\": true,\n      \"units\": \"pixels\",\n      \"requires\": [\"icon-image\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-translate\": {\n      \"type\": \"array\",\n      \"value\": \"number\",\n      \"length\": 2,\n      \"default\": [0, 0],\n      \"transition\": true,\n      \"units\": \"pixels\",\n      \"requires\": [\"icon-image\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-translate-anchor\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"map\": {},\n        \"viewport\": {}\n      },\n      \"default\": \"map\",\n      \"requires\": [\"icon-image\", \"icon-translate\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-opacity\": {\n      \"type\": \"number\",\n      \"default\": 1,\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"transition\": true,\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-color\": {\n      \"type\": \"color\",\n      \"default\": \"#000000\",\n      \"transition\": true,\n      \"overridable\": true,\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-halo-color\": {\n      \"type\": \"color\",\n      \"default\": \"rgba(0, 0, 0, 0)\",\n      \"transition\": true,\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-halo-width\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"minimum\": 0,\n      \"transition\": true,\n      \"units\": \"pixels\",\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-halo-blur\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"minimum\": 0,\n      \"transition\": true,\n      \"units\": \"pixels\",\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-translate\": {\n      \"type\": \"array\",\n      \"value\": \"number\",\n      \"length\": 2,\n      \"default\": [0, 0],\n      \"transition\": true,\n      \"units\": \"pixels\",\n      \"requires\": [\"text-field\"],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-translate-anchor\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"map\": {},\n        \"viewport\": {}\n      },\n      \"default\": \"map\",\n      \"requires\": [\"text-field\", \"text-translate\"],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    }\n  },\n  \"paint_raster\": {\n    \"raster-opacity\": {\n      \"type\": \"number\",\n      \"default\": 1,\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"raster-hue-rotate\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"period\": 360,\n      \"transition\": true,\n      \"units\": \"degrees\",\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"raster-brightness-min\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"raster-brightness-max\": {\n      \"type\": \"number\",\n      \"default\": 1,\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"raster-saturation\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"minimum\": -1,\n      \"maximum\": 1,\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"raster-contrast\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"minimum\": -1,\n      \"maximum\": 1,\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"raster-resampling\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"linear\": {},\n        \"nearest\": {}\n      },\n      \"default\": \"linear\",\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"raster-fade-duration\": {\n      \"type\": \"number\",\n      \"default\": 300,\n      \"minimum\": 0,\n      \"transition\": false,\n      \"units\": \"milliseconds\",\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    }\n  },\n  \"paint_hillshade\": {\n    \"hillshade-illumination-direction\": {\n      \"type\": \"number\",\n      \"default\": 335,\n      \"minimum\": 0,\n      \"maximum\": 359,\n      \"transition\": false,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"hillshade-illumination-anchor\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"map\": {},\n        \"viewport\": {}\n      },\n      \"default\": \"viewport\",\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"hillshade-exaggeration\": {\n      \"type\": \"number\",\n      \"default\": 0.5,\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"hillshade-shadow-color\": {\n      \"type\": \"color\",\n      \"default\": \"#000000\",\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"hillshade-highlight-color\": {\n      \"type\": \"color\",\n      \"default\": \"#FFFFFF\",\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"hillshade-accent-color\": {\n      \"type\": \"color\",\n      \"default\": \"#000000\",\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    }\n  },\n  \"paint_background\": {\n    \"background-color\": {\n      \"type\": \"color\",\n      \"default\": \"#000000\",\n      \"transition\": true,\n      \"requires\": [{\n        \"!\": \"background-pattern\"\n      }],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"background-pattern\": {\n      \"type\": \"resolvedImage\",\n      \"transition\": false,\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"background-opacity\": {\n      \"type\": \"number\",\n      \"default\": 1,\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    }\n  },\n  \"paint_sky\": {\n    \"sky-type\": {\n      \"type\": \"enum\",\n      \"values\": {\n        \"gradient\": {},\n        \"atmosphere\": {}\n      },\n      \"default\": \"atmosphere\",\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"sky-atmosphere-sun\": {\n      \"type\": \"array\",\n      \"value\": \"number\",\n      \"length\": 2,\n      \"units\": \"degrees\",\n      \"minimum\": [0, 0],\n      \"maximum\": [360, 180],\n      \"transition\": false,\n      \"requires\": [{\n        \"sky-type\": \"atmosphere\"\n      }],\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"sky-atmosphere-sun-intensity\": {\n      \"type\": \"number\",\n      \"requires\": [{\n        \"sky-type\": \"atmosphere\"\n      }],\n      \"default\": 10,\n      \"minimum\": 0,\n      \"maximum\": 100,\n      \"transition\": false,\n      \"property-type\": \"data-constant\"\n    },\n    \"sky-gradient-center\": {\n      \"type\": \"array\",\n      \"requires\": [{\n        \"sky-type\": \"gradient\"\n      }],\n      \"value\": \"number\",\n      \"default\": [0, 0],\n      \"length\": 2,\n      \"units\": \"degrees\",\n      \"minimum\": [0, 0],\n      \"maximum\": [360, 180],\n      \"transition\": false,\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"sky-gradient-radius\": {\n      \"type\": \"number\",\n      \"requires\": [{\n        \"sky-type\": \"gradient\"\n      }],\n      \"default\": 90,\n      \"minimum\": 0,\n      \"maximum\": 180,\n      \"transition\": false,\n      \"expression\": {\n        \"interpolated\": false,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"sky-gradient\": {\n      \"type\": \"color\",\n      \"default\": [\"interpolate\", [\"linear\"], [\"sky-radial-progress\"], 0.8, \"#87ceeb\", 1, \"white\"],\n      \"transition\": false,\n      \"requires\": [{\n        \"sky-type\": \"gradient\"\n      }],\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"sky-radial-progress\"]\n      },\n      \"property-type\": \"color-ramp\"\n    },\n    \"sky-atmosphere-halo-color\": {\n      \"type\": \"color\",\n      \"default\": \"white\",\n      \"transition\": false,\n      \"requires\": [{\n        \"sky-type\": \"atmosphere\"\n      }],\n      \"property-type\": \"data-constant\"\n    },\n    \"sky-atmosphere-color\": {\n      \"type\": \"color\",\n      \"default\": \"white\",\n      \"transition\": false,\n      \"requires\": [{\n        \"sky-type\": \"atmosphere\"\n      }],\n      \"property-type\": \"data-constant\"\n    },\n    \"sky-opacity\": {\n      \"type\": \"number\",\n      \"default\": 1,\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"transition\": true,\n      \"expression\": {\n        \"interpolated\": true,\n        \"parameters\": [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    }\n  },\n  \"transition\": {\n    \"duration\": {\n      \"type\": \"number\",\n      \"default\": 300,\n      \"minimum\": 0,\n      \"units\": \"milliseconds\"\n    },\n    \"delay\": {\n      \"type\": \"number\",\n      \"default\": 0,\n      \"minimum\": 0,\n      \"units\": \"milliseconds\"\n    }\n  },\n  \"property-type\": {\n    \"data-driven\": {\n      \"type\": \"property-type\"\n    },\n    \"color-ramp\": {\n      \"type\": \"property-type\"\n    },\n    \"data-constant\": {\n      \"type\": \"property-type\"\n    },\n    \"constant\": {\n      \"type\": \"property-type\"\n    }\n  },\n  \"promoteId\": {\n    \"*\": {\n      \"type\": \"string\"\n    }\n  }\n};\n\n//      \nfunction isExpressionFilter(filter) {\n  if (filter === true || filter === false) {\n    return true;\n  }\n  if (!Array.isArray(filter) || filter.length === 0) {\n    return false;\n  }\n  switch (filter[0]) {\n    case 'has':\n      return filter.length >= 2 && filter[1] !== '$id' && filter[1] !== '$type';\n    case 'in':\n      return filter.length >= 3 && (typeof filter[1] !== 'string' || Array.isArray(filter[2]));\n    case '!in':\n    case '!has':\n    case 'none':\n      return false;\n    case '==':\n    case '!=':\n    case '>':\n    case '>=':\n    case '<':\n    case '<=':\n      return filter.length !== 3 || Array.isArray(filter[1]) || Array.isArray(filter[2]);\n    case 'any':\n    case 'all':\n      for (var i = 0, list = filter.slice(1); i < list.length; i += 1) {\n        var f = list[i];\n        if (!isExpressionFilter(f) && typeof f !== 'boolean') {\n          return false;\n        }\n      }\n      return true;\n    default:\n      return true;\n  }\n}\n/**\n * Given a filter expressed as nested arrays, return a new function\n * that evaluates whether a given feature (with a .properties or .tags property)\n * passes its test.\n *\n * @private\n * @param {Array} filter mapbox gl filter\n * @param {string} layerType the type of the layer this filter will be applied to.\n * @returns {Function} filter-evaluating function\n */\nfunction createFilter(filter, layerType) {\n  if (layerType === void 0) layerType = 'fill';\n  if (filter === null || filter === undefined) {\n    return {\n      filter: function () {\n        return true;\n      },\n      needGeometry: false,\n      needFeature: false\n    };\n  }\n  if (!isExpressionFilter(filter)) {\n    filter = convertFilter(filter);\n  }\n  var filterExp = filter;\n  var staticFilter = true;\n  try {\n    staticFilter = extractStaticFilter(filterExp);\n  } catch (e) {\n    console.warn(\"Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\\nand paste the contents of this message in the report.\\nThank you!\\nFilter Expression:\\n\" + JSON.stringify(filterExp, null, 2) + \"\\n        \");\n  }\n  // Compile the static component of the filter\n  var filterSpec = spec[\"filter_\" + layerType];\n  var compiledStaticFilter = createExpression(staticFilter, filterSpec);\n  var filterFunc = null;\n  if (compiledStaticFilter.result === 'error') {\n    throw new Error(compiledStaticFilter.value.map(function (err) {\n      return err.key + \": \" + err.message;\n    }).join(', '));\n  } else {\n    filterFunc = function (globalProperties, feature, canonical) {\n      return compiledStaticFilter.value.evaluate(globalProperties, feature, {}, canonical);\n    };\n  }\n  // If the static component is not equal to the entire filter then we have a dynamic component\n  // Compile the dynamic component separately\n  var dynamicFilterFunc = null;\n  var needFeature = null;\n  if (staticFilter !== filterExp) {\n    var compiledDynamicFilter = createExpression(filterExp, filterSpec);\n    if (compiledDynamicFilter.result === 'error') {\n      throw new Error(compiledDynamicFilter.value.map(function (err) {\n        return err.key + \": \" + err.message;\n      }).join(', '));\n    } else {\n      dynamicFilterFunc = function (globalProperties, feature, canonical, featureTileCoord, featureDistanceData) {\n        return compiledDynamicFilter.value.evaluate(globalProperties, feature, {}, canonical, undefined, undefined, featureTileCoord, featureDistanceData);\n      };\n      needFeature = !isFeatureConstant(compiledDynamicFilter.value.expression);\n    }\n  }\n  filterFunc = filterFunc;\n  var needGeometry = geometryNeeded(staticFilter);\n  return {\n    filter: filterFunc,\n    dynamicFilter: dynamicFilterFunc ? dynamicFilterFunc : undefined,\n    needGeometry: needGeometry,\n    needFeature: !!needFeature\n  };\n}\nfunction extractStaticFilter(filter) {\n  if (!isDynamicFilter(filter)) {\n    return filter;\n  }\n  // Shallow copy so we can replace expressions in-place\n  var result = deepUnbundle(filter);\n  // 1. Union branches\n  unionDynamicBranches(result);\n  // 2. Collapse dynamic conditions to  `true`\n  result = collapseDynamicBooleanExpressions(result);\n  return result;\n}\nfunction collapseDynamicBooleanExpressions(expression) {\n  if (!Array.isArray(expression)) {\n    return expression;\n  }\n  var collapsed = collapsedExpression(expression);\n  if (collapsed === true) {\n    return collapsed;\n  } else {\n    return collapsed.map(function (subExpression) {\n      return collapseDynamicBooleanExpressions(subExpression);\n    });\n  }\n}\n/**\n * Traverses the expression and replaces all instances of branching on a\n * `dynamic` conditional (such as `['pitch']` or `['distance-from-center']`)\n * into an `any` expression.\n * This ensures that all possible outcomes of a `dynamic` branch are considered\n * when evaluating the expression upfront during filtering.\n *\n * @param {Array<any>} filter the filter expression mutated in-place.\n */\nfunction unionDynamicBranches(filter) {\n  var isBranchingDynamically = false;\n  var branches = [];\n  if (filter[0] === 'case') {\n    for (var i = 1; i < filter.length - 1; i += 2) {\n      isBranchingDynamically = isBranchingDynamically || isDynamicFilter(filter[i]);\n      branches.push(filter[i + 1]);\n    }\n    branches.push(filter[filter.length - 1]);\n  } else if (filter[0] === 'match') {\n    isBranchingDynamically = isBranchingDynamically || isDynamicFilter(filter[1]);\n    for (var i$1 = 2; i$1 < filter.length - 1; i$1 += 2) {\n      branches.push(filter[i$1 + 1]);\n    }\n    branches.push(filter[filter.length - 1]);\n  } else if (filter[0] === 'step') {\n    isBranchingDynamically = isBranchingDynamically || isDynamicFilter(filter[1]);\n    for (var i$2 = 1; i$2 < filter.length - 1; i$2 += 2) {\n      branches.push(filter[i$2 + 1]);\n    }\n  }\n  if (isBranchingDynamically) {\n    filter.length = 0;\n    filter.push.apply(filter, ['any'].concat(branches));\n  }\n  // traverse and recurse into children\n  for (var i$3 = 1; i$3 < filter.length; i$3++) {\n    unionDynamicBranches(filter[i$3]);\n  }\n}\nfunction isDynamicFilter(filter) {\n  // Base Cases\n  if (!Array.isArray(filter)) {\n    return false;\n  }\n  if (isRootExpressionDynamic(filter[0])) {\n    return true;\n  }\n  for (var i = 1; i < filter.length; i++) {\n    var child = filter[i];\n    if (isDynamicFilter(child)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isRootExpressionDynamic(expression) {\n  return expression === 'pitch' || expression === 'distance-from-center';\n}\nvar dynamicConditionExpressions = new Set(['in', '==', '!=', '>', '>=', '<', '<=', 'to-boolean']);\nfunction collapsedExpression(expression) {\n  if (dynamicConditionExpressions.has(expression[0])) {\n    for (var i = 1; i < expression.length; i++) {\n      var param = expression[i];\n      if (isDynamicFilter(param)) {\n        return true;\n      }\n    }\n  }\n  return expression;\n}\n// Comparison function to sort numbers and strings\nfunction compare(a, b) {\n  return a < b ? -1 : a > b ? 1 : 0;\n}\nfunction geometryNeeded(filter) {\n  if (!Array.isArray(filter)) {\n    return false;\n  }\n  if (filter[0] === 'within') {\n    return true;\n  }\n  for (var index = 1; index < filter.length; index++) {\n    if (geometryNeeded(filter[index])) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction convertFilter(filter) {\n  if (!filter) {\n    return true;\n  }\n  var op = filter[0];\n  if (filter.length <= 1) {\n    return op !== 'any';\n  }\n  var converted = op === '==' ? convertComparisonOp(filter[1], filter[2], '==') : op === '!=' ? convertNegation(convertComparisonOp(filter[1], filter[2], '==')) : op === '<' || op === '>' || op === '<=' || op === '>=' ? convertComparisonOp(filter[1], filter[2], op) : op === 'any' ? convertDisjunctionOp(filter.slice(1)) : op === 'all' ? ['all'].concat(filter.slice(1).map(convertFilter)) : op === 'none' ? ['all'].concat(filter.slice(1).map(convertFilter).map(convertNegation)) : op === 'in' ? convertInOp(filter[1], filter.slice(2)) : op === '!in' ? convertNegation(convertInOp(filter[1], filter.slice(2))) : op === 'has' ? convertHasOp(filter[1]) : op === '!has' ? convertNegation(convertHasOp(filter[1])) : op === 'within' ? filter : true;\n  return converted;\n}\nfunction convertComparisonOp(property, value, op) {\n  switch (property) {\n    case '$type':\n      return [\"filter-type-\" + op, value];\n    case '$id':\n      return [\"filter-id-\" + op, value];\n    default:\n      return [\"filter-\" + op, property, value];\n  }\n}\nfunction convertDisjunctionOp(filters) {\n  return ['any'].concat(filters.map(convertFilter));\n}\nfunction convertInOp(property, values) {\n  if (values.length === 0) {\n    return false;\n  }\n  switch (property) {\n    case '$type':\n      return [\"filter-type-in\", ['literal', values]];\n    case '$id':\n      return [\"filter-id-in\", ['literal', values]];\n    default:\n      if (values.length > 200 && !values.some(function (v) {\n        return typeof v !== typeof values[0];\n      })) {\n        return ['filter-in-large', property, ['literal', values.sort(compare)]];\n      } else {\n        return ['filter-in-small', property, ['literal', values]];\n      }\n  }\n}\nfunction convertHasOp(property) {\n  switch (property) {\n    case '$type':\n      return true;\n    case '$id':\n      return [\"filter-has-id\"];\n    default:\n      return [\"filter-has\", property];\n  }\n}\nfunction convertNegation(filter) {\n  return ['!', filter];\n}\n\n//      \nvar refProperties = ['type', 'source', 'source-layer', 'minzoom', 'maxzoom', 'filter', 'layout'];\n\n//      \nfunction deref(layer, parent) {\n  var result = {};\n  for (var k in layer) {\n    if (k !== 'ref') {\n      result[k] = layer[k];\n    }\n  }\n  refProperties.forEach(function (k) {\n    if (k in parent) {\n      result[k] = parent[k];\n    }\n  });\n  return result;\n}\n/**\n * Given an array of layers, some of which may contain `ref` properties\n * whose value is the `id` of another property, return a new array where\n * such layers have been augmented with the 'type', 'source', etc. properties\n * from the parent layer, and the `ref` property has been removed.\n *\n * The input is not modified. The output may contain references to portions\n * of the input.\n *\n * @private\n * @param {Array<Layer>} layers\n * @returns {Array<Layer>}\n */\nfunction derefLayers(layers) {\n  layers = layers.slice();\n  var map = Object.create(null);\n  for (var i = 0; i < layers.length; i++) {\n    map[layers[i].id] = layers[i];\n  }\n  for (var i$1 = 0; i$1 < layers.length; i$1++) {\n    if ('ref' in layers[i$1]) {\n      layers[i$1] = deref(layers[i$1], map[layers[i$1].ref]);\n    }\n  }\n  return layers;\n}\nvar fontWeights = {\n  thin: 100,\n  hairline: 100,\n  'ultra-light': 100,\n  'extra-light': 100,\n  light: 200,\n  book: 300,\n  regular: 400,\n  normal: 400,\n  plain: 400,\n  roman: 400,\n  standard: 400,\n  medium: 500,\n  'semi-bold': 600,\n  'demi-bold': 600,\n  bold: 700,\n  heavy: 800,\n  black: 800,\n  'extra-bold': 800,\n  'ultra-black': 900,\n  'extra-black': 900,\n  'ultra-bold': 900,\n  'heavy-black': 900,\n  fat: 900,\n  poster: 900\n};\nvar sp = ' ';\nvar italicRE = /(italic|oblique)$/i;\nvar fontCache = {};\nvar mapboxToCssFont = function (fonts, size, lineHeight) {\n  var cssData = fontCache[fonts];\n  if (!cssData) {\n    if (!Array.isArray(fonts)) {\n      fonts = [fonts];\n    }\n    var weight = 400;\n    var style = 'normal';\n    var fontFamilies = [];\n    var haveWeight, haveStyle;\n    for (var i = 0, ii = fonts.length; i < ii; ++i) {\n      var font = fonts[i];\n      var parts = font.split(' ');\n      var maybeWeight = parts[parts.length - 1].toLowerCase();\n      if (maybeWeight == 'normal' || maybeWeight == 'italic' || maybeWeight == 'oblique') {\n        style = haveStyle ? style : maybeWeight;\n        parts.pop();\n        maybeWeight = parts[parts.length - 1].toLowerCase();\n      } else if (italicRE.test(maybeWeight)) {\n        maybeWeight = maybeWeight.replace(italicRE, '');\n        style = haveStyle ? style : parts[parts.length - 1].replace(maybeWeight, '');\n      }\n      for (var w in fontWeights) {\n        var previousPart = parts.length > 1 ? parts[parts.length - 2].toLowerCase() : '';\n        if (maybeWeight == w || maybeWeight == w.replace('-', '') || previousPart + '-' + maybeWeight == w) {\n          weight = haveWeight ? weight : fontWeights[w];\n          parts.pop();\n          if (previousPart && w.startsWith(previousPart)) {\n            parts.pop();\n          }\n          break;\n        }\n      }\n      if (!haveWeight && typeof maybeWeight == 'number') {\n        weight = maybeWeight;\n      }\n      var fontFamily = parts.join(sp).replace('Klokantech Noto Sans', 'Noto Sans');\n      if (fontFamily.indexOf(sp) !== -1) {\n        fontFamily = '\"' + fontFamily + '\"';\n      }\n      fontFamilies.push(fontFamily);\n    }\n    // CSS font property: font-style font-weight font-size/line-height font-family\n    cssData = fontCache[fonts] = [style, weight, fontFamilies];\n  }\n  return cssData[0] + sp + cssData[1] + sp + size + 'px' + (lineHeight ? '/' + lineHeight : '') + sp + cssData[2];\n};\nvar mapboxBaseUrl = 'https://api.mapbox.com';\n/**\n * Gets the path from a mapbox:// URL.\n * @param {string} url The Mapbox URL.\n * @return {string} The path.\n * @private\n */\nfunction getMapboxPath(url) {\n  var startsWith = 'mapbox://';\n  if (url.indexOf(startsWith) !== 0) {\n    return '';\n  }\n  return url.slice(startsWith.length);\n}\n/**\n * Turns mapbox:// sprite URLs into resolvable URLs.\n * @param {string} url The sprite URL.\n * @param {string} token The access token.\n * @param {string} styleUrl The style URL.\n * @return {string} A resolvable URL.\n * @private\n */\nfunction normalizeSpriteUrl(url, token, styleUrl) {\n  var mapboxPath = getMapboxPath(url);\n  if (!mapboxPath) {\n    return decodeURI(new URL(url, styleUrl).href);\n  }\n  var startsWith = 'sprites/';\n  if (mapboxPath.indexOf(startsWith) !== 0) {\n    throw new Error(\"unexpected sprites url: \" + url);\n  }\n  var sprite = mapboxPath.slice(startsWith.length);\n  return mapboxBaseUrl + \"/styles/v1/\" + sprite + \"/sprite?access_token=\" + token;\n}\n/**\n * Turns mapbox:// style URLs into resolvable URLs.\n * @param {string} url The style URL.\n * @param {string} token The access token.\n * @return {string} A resolvable URL.\n * @private\n */\nfunction normalizeStyleUrl(url, token) {\n  var mapboxPath = getMapboxPath(url);\n  if (!mapboxPath) {\n    return decodeURI(new URL(url, location.href).href);\n  }\n  var startsWith = 'styles/';\n  if (mapboxPath.indexOf(startsWith) !== 0) {\n    throw new Error(\"unexpected style url: \" + url);\n  }\n  var style = mapboxPath.slice(startsWith.length);\n  return mapboxBaseUrl + \"/styles/v1/\" + style + \"?&access_token=\" + token;\n}\n/**\n * Turns mapbox:// source URLs into vector tile URL templates.\n * @param {string} url The source URL.\n * @param {string} token The access token.\n * @param {string} tokenParam The access token key.\n * @param {string} styleUrl The style URL.\n * @return {string} A vector tile template.\n * @private\n */\nfunction normalizeSourceUrl(url, token, tokenParam, styleUrl) {\n  var urlObject = new URL(url, styleUrl);\n  var mapboxPath = getMapboxPath(url);\n  if (!mapboxPath) {\n    if (!token) {\n      return decodeURI(urlObject.href);\n    }\n    urlObject.searchParams.set(tokenParam, token);\n    return decodeURI(urlObject.href);\n  }\n  if (mapboxPath === 'mapbox.satellite') {\n    var sizeFactor = window.devicePixelRatio >= 1.5 ? '@2x' : '';\n    return \"https://api.mapbox.com/v4/\" + mapboxPath + \"/{z}/{x}/{y}\" + sizeFactor + \".webp?access_token=\" + token;\n  }\n  return \"https://{a-d}.tiles.mapbox.com/v4/\" + mapboxPath + \"/{z}/{x}/{y}.vector.pbf?access_token=\" + token;\n}\nvar styleId = 0;\nvar functionCacheByStyleId = {};\nvar filterCacheByStyleId = {};\n/**\n * @param {Object} glStyle Mapboox style object.\n * @return {Object} Function cache.\n */\nfunction getFunctionCache(glStyle) {\n  if (!glStyle.id) {\n    glStyle.id = styleId++;\n  }\n  var functionCache = {};\n  functionCacheByStyleId[glStyle.id] = functionCache;\n  return functionCache;\n}\n/**\n * @param {Object} glStyle Mapboox style object.\n * @return {Object} Filter cache.\n */\nfunction getFilterCache(glStyle) {\n  if (!glStyle.id) {\n    glStyle.id = styleId++;\n  }\n  var filterCache = {};\n  filterCacheByStyleId[glStyle.id] = filterCache;\n  return filterCache;\n}\nfunction deg2rad(degrees) {\n  return degrees * Math.PI / 180;\n}\nvar defaultResolutions = function () {\n  var resolutions = [];\n  for (var res = 78271.51696402048; resolutions.length <= 24; res /= 2) {\n    resolutions.push(res);\n  }\n  return resolutions;\n}();\n/**\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @return {HTMLCanvasElement} Canvas.\n */\nfunction createCanvas(width, height) {\n  if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && typeof OffscreenCanvas !== 'undefined') {\n    // eslint-disable-line\n    return new OffscreenCanvas(width, height);\n  }\n  var canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  return canvas;\n}\nfunction getZoomForResolution(resolution, resolutions) {\n  var i = 0;\n  var ii = resolutions.length;\n  for (; i < ii; ++i) {\n    var candidate = resolutions[i];\n    if (candidate < resolution && i + 1 < ii) {\n      var zoomFactor = resolutions[i] / resolutions[i + 1];\n      return i + Math.log(resolutions[i] / resolution) / Math.log(zoomFactor);\n    }\n  }\n  return ii - 1;\n}\nvar pendingRequests = {};\n/**\n * @param {ResourceType} resourceType Type of resource to load.\n * @param {string} url Url of the resource.\n * @param {Options} [options={}] Options.\n * @param {{request?: Request}} [metadata] Object to be filled with the request.\n * @return {Promise<Object|Response>} Promise that resolves with the loaded resource\n * or rejects with the Response object.\n * @private\n */\nfunction fetchResource(resourceType, url, options, metadata) {\n  if (options === void 0) options = {};\n  if (url in pendingRequests) {\n    if (metadata) {\n      metadata.request = pendingRequests[url][0];\n    }\n    return pendingRequests[url][1];\n  }\n  var request = options.transformRequest ? options.transformRequest(url, resourceType) || new Request(url) : new Request(url);\n  if (!request.headers.get('Accept')) {\n    request.headers.set('Accept', 'application/json');\n  }\n  if (metadata) {\n    metadata.request = request;\n  }\n  var pendingRequest = fetch(request).then(function (response) {\n    delete pendingRequests[url];\n    return response.ok ? response.json() : Promise.reject(new Error('Error fetching source ' + url));\n  }).catch(function (error) {\n    delete pendingRequests[url];\n    return Promise.reject(new Error('Error fetching source ' + url));\n  });\n  pendingRequests[url] = [request, pendingRequest];\n  return pendingRequest;\n}\nfunction getGlStyle(glStyleOrUrl, options) {\n  if (typeof glStyleOrUrl === 'string') {\n    if (glStyleOrUrl.trim().startsWith('{')) {\n      try {\n        var glStyle = JSON.parse(glStyleOrUrl);\n        return Promise.resolve(glStyle);\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    } else {\n      glStyleOrUrl = normalizeStyleUrl(glStyleOrUrl, options.accessToken);\n      return fetchResource('Style', glStyleOrUrl, options);\n    }\n  } else {\n    return Promise.resolve(glStyleOrUrl);\n  }\n}\nfunction getTransformedTilesUrl(tilesUrl, options) {\n  if (options.transformRequest) {\n    var transformedRequest = options.transformRequest(tilesUrl, 'Tiles');\n    if (transformedRequest instanceof Request) {\n      return decodeURI(transformedRequest.url);\n    }\n  }\n  return tilesUrl;\n}\nvar tilejsonCache = {};\n/**\n * @param {Object} glSource glStyle source object.\n * @param {string} styleUrl Style URL.\n * @param {Options} options Options.\n * @return {Object} TileJson\n */\nfunction getTileJson(glSource, styleUrl, options) {\n  if (options === void 0) options = {};\n  var cacheKey = [styleUrl, JSON.stringify(glSource)].toString();\n  var promise = tilejsonCache[cacheKey];\n  if (!promise || options.transformRequest) {\n    var url = glSource.url;\n    if (url && !glSource.tiles) {\n      var normalizedSourceUrl = normalizeSourceUrl(url, options.accessToken, options.accessTokenParam || 'access_token', styleUrl || location.href);\n      if (url.startsWith('mapbox://')) {\n        promise = Promise.resolve(Object.assign({}, glSource, {\n          url: undefined,\n          tiles: expandUrl(normalizedSourceUrl)\n        }));\n      } else {\n        var metadata = {};\n        promise = fetchResource('Source', normalizedSourceUrl, options, metadata).then(function (tileJson) {\n          tileJson.tiles = tileJson.tiles.map(function (tileUrl) {\n            return getTransformedTilesUrl(normalizeSourceUrl(tileUrl, options.accessToken, options.accessTokenParam || 'access_token', metadata.request.url), options);\n          });\n          return Promise.resolve(tileJson);\n        });\n      }\n    } else {\n      glSource = Object.assign({}, glSource, {\n        tiles: glSource.tiles.map(function (tileUrl) {\n          return getTransformedTilesUrl(normalizeSourceUrl(tileUrl, options.accessToken, options.accessTokenParam || 'access_token', styleUrl || location.href), options);\n        })\n      });\n      promise = Promise.resolve(Object.assign({}, glSource));\n    }\n    tilejsonCache[cacheKey] = promise;\n  }\n  return promise;\n}\n/**\n * @param {HTMLImageElement} spriteImage Sprite image id.\n * @param {{x: number, y: number, width: number, height: number, pixelRatio: number}} spriteImageData Sprite image data.\n * @param {number} haloWidth Halo width.\n * @param {{r: number, g: number, b: number, a: number}} haloColor Halo color.\n * @return {HTMLCanvasElement} Canvas element with the halo.\n */\nfunction drawIconHalo(spriteImage, spriteImageData, haloWidth, haloColor) {\n  var imageCanvas = document.createElement('canvas');\n  var imgSize = [2 * haloWidth * spriteImageData.pixelRatio + spriteImageData.width, 2 * haloWidth * spriteImageData.pixelRatio + spriteImageData.height];\n  imageCanvas.width = imgSize[0];\n  imageCanvas.height = imgSize[1];\n  var imageContext = imageCanvas.getContext('2d');\n  imageContext.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, haloWidth * spriteImageData.pixelRatio, haloWidth * spriteImageData.pixelRatio, spriteImageData.width, spriteImageData.height);\n  var imageData = imageContext.getImageData(0, 0, imgSize[0], imgSize[1]);\n  imageContext.globalCompositeOperation = 'destination-over';\n  imageContext.fillStyle = \"rgba(\" + haloColor.r * 255 + \",\" + haloColor.g * 255 + \",\" + haloColor.b * 255 + \",\" + haloColor.a + \")\";\n  var data = imageData.data;\n  for (var i = 0, ii = imageData.width; i < ii; ++i) {\n    for (var j = 0, jj = imageData.height; j < jj; ++j) {\n      var index = (j * ii + i) * 4;\n      var alpha = data[index + 3];\n      if (alpha > 0) {\n        imageContext.arc(i, j, haloWidth * spriteImageData.pixelRatio, 0, 2 * Math.PI);\n      }\n    }\n  }\n  imageContext.fill();\n  return imageCanvas;\n} /**\n  * @typedef {import(\"./apply.js\").Options} Options\n  * @typedef {import('./apply.js').ResourceType} ResourceType\n  * @private\n  */\n\nvar hairSpacePool = Array(256).join('\\u200A');\nfunction applyLetterSpacing(text, letterSpacing) {\n  if (letterSpacing >= 0.05) {\n    var textWithLetterSpacing = '';\n    var lines = text.split('\\n');\n    var joinSpaceString = hairSpacePool.slice(0, Math.round(letterSpacing / 0.1));\n    for (var l = 0, ll = lines.length; l < ll; ++l) {\n      if (l > 0) {\n        textWithLetterSpacing += '\\n';\n      }\n      textWithLetterSpacing += lines[l].split('').join(joinSpaceString);\n    }\n    return textWithLetterSpacing;\n  }\n  return text;\n}\nvar measureContext;\nfunction getMeasureContext() {\n  if (!measureContext) {\n    measureContext = createCanvas(1, 1).getContext('2d');\n  }\n  return measureContext;\n}\nfunction measureText(text, letterSpacing) {\n  return getMeasureContext().measureText(text).width + (text.length - 1) * letterSpacing;\n}\nvar measureCache = {};\nfunction wrapText(text, font, em, letterSpacing) {\n  if (text.indexOf('\\n') !== -1) {\n    var hardLines = text.split('\\n');\n    var lines = [];\n    for (var i = 0, ii = hardLines.length; i < ii; ++i) {\n      lines.push(wrapText(hardLines[i], font, em, letterSpacing));\n    }\n    return lines.join('\\n');\n  }\n  var key = em + ',' + font + ',' + text + ',' + letterSpacing;\n  var wrappedText = measureCache[key];\n  if (!wrappedText) {\n    var words = text.split(' ');\n    if (words.length > 1) {\n      var ctx = getMeasureContext();\n      ctx.font = font;\n      var oneEm = ctx.measureText('M').width;\n      var maxWidth = oneEm * em;\n      var line = '';\n      var lines$1 = [];\n      // Pass 1 - wrap lines to not exceed maxWidth\n      for (var i$1 = 0, ii$1 = words.length; i$1 < ii$1; ++i$1) {\n        var word = words[i$1];\n        var testLine = line + (line ? ' ' : '') + word;\n        if (measureText(testLine, letterSpacing) <= maxWidth) {\n          line = testLine;\n        } else {\n          if (line) {\n            lines$1.push(line);\n          }\n          line = word;\n        }\n      }\n      if (line) {\n        lines$1.push(line);\n      }\n      // Pass 2 - add lines with a width of less than 30% of maxWidth to the previous or next line\n      for (var i$2 = 0, ii$2 = lines$1.length; i$2 < ii$2 && ii$2 > 1; ++i$2) {\n        var line$1 = lines$1[i$2];\n        if (measureText(line$1, letterSpacing) < maxWidth * 0.35) {\n          var prevWidth = i$2 > 0 ? measureText(lines$1[i$2 - 1], letterSpacing) : Infinity;\n          var nextWidth = i$2 < ii$2 - 1 ? measureText(lines$1[i$2 + 1], letterSpacing) : Infinity;\n          lines$1.splice(i$2, 1);\n          ii$2 -= 1;\n          if (prevWidth < nextWidth) {\n            lines$1[i$2 - 1] += ' ' + line$1;\n            i$2 -= 1;\n          } else {\n            lines$1[i$2] = line$1 + ' ' + lines$1[i$2];\n          }\n        }\n      }\n      // Pass 3 - try to fill 80% of maxWidth for each line\n      for (var i$3 = 0, ii$3 = lines$1.length - 1; i$3 < ii$3; ++i$3) {\n        var line$2 = lines$1[i$3];\n        var next = lines$1[i$3 + 1];\n        if (measureText(line$2, letterSpacing) > maxWidth * 0.7 && measureText(next, letterSpacing) < maxWidth * 0.6) {\n          var lineWords = line$2.split(' ');\n          var lastWord = lineWords.pop();\n          if (measureText(lastWord, letterSpacing) < maxWidth * 0.2) {\n            lines$1[i$3] = lineWords.join(' ');\n            lines$1[i$3 + 1] = lastWord + ' ' + next;\n          }\n          ii$3 -= 1;\n        }\n      }\n      wrappedText = lines$1.join('\\n');\n    } else {\n      wrappedText = text;\n    }\n    wrappedText = applyLetterSpacing(wrappedText, letterSpacing);\n    measureCache[key] = wrappedText;\n  }\n  return wrappedText;\n}\nvar fontFamilyRegEx = /font-family: ?([^;]*);/;\nvar stripQuotesRegEx = /(\"|')/g;\nvar loadedFontFamilies;\nfunction hasFontFamily(family) {\n  if (!loadedFontFamilies) {\n    loadedFontFamilies = {};\n    var styleSheets = document.styleSheets;\n    for (var i = 0, ii = styleSheets.length; i < ii; ++i) {\n      var styleSheet = styleSheets[i];\n      try {\n        var cssRules = styleSheet.rules || styleSheet.cssRules;\n        if (cssRules) {\n          for (var j = 0, jj = cssRules.length; j < jj; ++j) {\n            var cssRule = cssRules[j];\n            if (cssRule.type == 5) {\n              var match = cssRule.cssText.match(fontFamilyRegEx);\n              loadedFontFamilies[match[1].replace(stripQuotesRegEx, '')] = true;\n            }\n          }\n        }\n      } catch (e) {}\n    }\n  }\n  return family in loadedFontFamilies;\n}\nvar processedFontFamilies = {};\n/**\n * @param {Array} fonts Fonts.\n * @return {Array} Processed fonts.\n * @private\n */\nfunction getFonts(fonts) {\n  var fontsKey = fonts.toString();\n  if (fontsKey in processedFontFamilies) {\n    return processedFontFamilies[fontsKey];\n  }\n  var googleFontDescriptions = [];\n  for (var i = 0, ii = fonts.length; i < ii; ++i) {\n    fonts[i] = fonts[i].replace('Arial Unicode MS', 'Arial');\n    var font = fonts[i];\n    var cssFont = mapboxToCssFont(font, 1);\n    registerFont(cssFont);\n    var parts = cssFont.split(' ');\n    googleFontDescriptions.push([parts.slice(3).join(' ').replace(/\"/g, ''), parts[1], parts[0]]);\n  }\n  for (var i$1 = 0, ii$1 = googleFontDescriptions.length; i$1 < ii$1; ++i$1) {\n    var googleFontDescription = googleFontDescriptions[i$1];\n    var family = googleFontDescription[0];\n    if (!hasFontFamily(family)) {\n      if (checkedFonts.get(googleFontDescription[2] + \"\\n\" + googleFontDescription[1] + \" \\n\" + family) !== 100) {\n        var fontUrl = 'https://fonts.googleapis.com/css?family=' + family.replace(/ /g, '+') + ':' + googleFontDescription[1] + googleFontDescription[2];\n        if (!document.querySelector('link[href=\"' + fontUrl + '\"]')) {\n          var markup = document.createElement('link');\n          markup.href = fontUrl;\n          markup.rel = 'stylesheet';\n          document.head.appendChild(markup);\n        }\n      }\n    }\n  }\n  processedFontFamilies[fontsKey] = fonts;\n  return fonts;\n}\n\n/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\n/**\n * @typedef {import(\"ol/layer/Vector\").default} VectorLayer\n * @typedef {import(\"ol/layer/VectorTile\").default} VectorTileLayer\n * @typedef {import(\"ol/style/Style\").StyleFunction} StyleFunction\n */\nvar types = {\n  'Point': 1,\n  'MultiPoint': 1,\n  'LineString': 2,\n  'MultiLineString': 2,\n  'Polygon': 3,\n  'MultiPolygon': 3\n};\nvar anchor = {\n  'center': [0.5, 0.5],\n  'left': [0, 0.5],\n  'right': [1, 0.5],\n  'top': [0.5, 0],\n  'bottom': [0.5, 1],\n  'top-left': [0, 0],\n  'top-right': [1, 0],\n  'bottom-left': [0, 1],\n  'bottom-right': [1, 1]\n};\nvar expressionData = function (rawExpression, propertySpec) {\n  var compiledExpression = createPropertyExpression(rawExpression, propertySpec);\n  if (compiledExpression.result === 'error') {\n    throw new Error(compiledExpression.value.map(function (err) {\n      return err.key + \": \" + err.message;\n    }).join(', '));\n  }\n  return compiledExpression.value;\n};\nvar emptyObj$1 = {};\nvar zoomObj = {\n  zoom: 0\n};\nvar renderFeatureCoordinates, renderFeature;\n/**\n * @private\n * @param {Object} layer Gl object layer.\n * @param {string} layoutOrPaint 'layout' or 'paint'.\n * @param {string} property Feature property.\n * @param {number} zoom Zoom.\n * @param {Object} feature Gl feature.\n * @param {Object} [functionCache] Function cache.\n * @param {Object} [featureState] Feature state.\n * @return {?} Value.\n */\nfunction getValue(layer, layoutOrPaint, property, zoom, feature, functionCache, featureState) {\n  var layerId = layer.id;\n  if (!functionCache) {\n    functionCache = {};\n    console.warn('No functionCache provided to getValue()'); //eslint-disable-line no-console\n  }\n\n  if (!functionCache[layerId]) {\n    functionCache[layerId] = {};\n  }\n  var functions = functionCache[layerId];\n  if (!functions[property]) {\n    var value = (layer[layoutOrPaint] || emptyObj$1)[property];\n    var propertySpec = spec[layoutOrPaint + \"_\" + layer.type][property];\n    if (value === undefined) {\n      value = propertySpec.default;\n    }\n    var isExpr = isExpression(value);\n    if (!isExpr && isFunction(value)) {\n      value = convertFunction(value, propertySpec);\n      isExpr = true;\n    }\n    if (isExpr) {\n      var compiledExpression = expressionData(value, propertySpec);\n      functions[property] = compiledExpression.evaluate.bind(compiledExpression);\n    } else {\n      if (propertySpec.type == 'color') {\n        value = Color$1.parse(value);\n      }\n      functions[property] = function () {\n        return value;\n      };\n    }\n  }\n  zoomObj.zoom = zoom;\n  return functions[property](zoomObj, feature, featureState);\n}\n/**\n * @private\n * @param {Object} layer Gl object layer.\n * @param {number} zoom Zoom.\n * @param {Object} feature Gl feature.\n * @param {Object} [functionCache] Function cache.\n * @return {\"declutter\"|\"obstacle\"|\"none\"} Value.\n */\nfunction getIconDeclutterMode(layer, zoom, feature, functionCache) {\n  var allowOverlap = getValue(layer, 'layout', 'icon-allow-overlap', zoom, feature, functionCache);\n  if (!allowOverlap) {\n    return 'declutter';\n  }\n  var ignorePlacement = getValue(layer, 'layout', 'icon-ignore-placement', zoom, feature, functionCache);\n  if (!ignorePlacement) {\n    return 'obstacle';\n  }\n  return 'none';\n}\n/**\n * @private\n * @param {string} layerId Layer id.\n * @param {?} filter Filter.\n * @param {Object} feature Feature.\n * @param {number} zoom Zoom.\n * @param {Object} [filterCache] Filter cache.\n * @return {boolean} Filter result.\n */\nfunction evaluateFilter(layerId, filter, feature, zoom, filterCache) {\n  if (!filterCache) {\n    console.warn('No filterCache provided to evaluateFilter()'); //eslint-disable-line no-console\n  }\n\n  if (!(layerId in filterCache)) {\n    filterCache[layerId] = createFilter(filter).filter;\n  }\n  zoomObj.zoom = zoom;\n  return filterCache[layerId](zoomObj, feature);\n}\nvar renderTransparentEnabled = false;\n/**\n * Configure whether features with a transparent style should be rendered. When\n * set to `true`, it will be possible to hit detect content that is not visible,\n * like transparent fills of polygons, using `ol/layer/Layer#getFeatures()` or\n * `ol/Map#getFeaturesAtPixel()`\n * @param {boolean} enabled Rendering of transparent elements is enabled.\n * Default is `false`.\n */\nfunction renderTransparent(enabled) {\n  renderTransparentEnabled = enabled;\n}\n/**\n * @private\n * @param {?} color Color.\n * @param {number} [opacity] Opacity.\n * @return {string} Color.\n */\nfunction colorWithOpacity(color, opacity) {\n  if (color) {\n    if (!renderTransparentEnabled && (color.a === 0 || opacity === 0)) {\n      return undefined;\n    }\n    var a = color.a;\n    opacity = opacity === undefined ? 1 : opacity;\n    return a === 0 ? 'transparent' : 'rgba(' + Math.round(color.r * 255 / a) + ',' + Math.round(color.g * 255 / a) + ',' + Math.round(color.b * 255 / a) + ',' + a * opacity + ')';\n  }\n  return color;\n}\nvar templateRegEx = /\\{[^{}}]*\\}/g;\n/**\n * @private\n * @param {string} text Text.\n * @param {Object} properties Properties.\n * @return {string} Text.\n */\nfunction fromTemplate(text, properties) {\n  return text.replace(templateRegEx, function (match) {\n    return properties[match.slice(1, -1)] || '';\n  });\n}\nvar recordLayer = false;\n/**\n * Turns recording of the Mapbox Style's `layer` on and off. When turned on,\n * the layer that a rendered feature belongs to will be set as the feature's\n * `mapbox-layer` property.\n * @param {boolean} record Recording of the style layer is on.\n */\nfunction recordStyleLayer(record) {\n  if (record === void 0) record = false;\n  recordLayer = record;\n}\n/**\n * Creates a style function from the `glStyle` object for all layers that use\n * the specified `source`, which needs to be a `\"type\": \"vector\"` or\n * `\"type\": \"geojson\"` source and applies it to the specified OpenLayers layer.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * This function also works in a web worker. In worker mode, the main thread needs\n * to listen to messages from the worker and respond with another message to make\n * sure that sprite image loading works:\n *\n * ```js\n *  worker.addEventListener('message', event => {\n *   if (event.data.action === 'loadImage') {\n *     const image = new Image();\n *     image.crossOrigin = 'anonymous';\n *     image.addEventListener('load', function() {\n *       createImageBitmap(image, 0, 0, image.width, image.height).then(imageBitmap => {\n *         worker.postMessage({\n *           action: 'imageLoaded',\n *           image: imageBitmap,\n *           src: event.data.src\n *         }, [imageBitmap]);\n *       });\n *     });\n *     image.src = event.data.src;\n *   }\n * });\n * ```\n *\n * @param {VectorLayer|VectorTileLayer} olLayer OpenLayers layer to\n * apply the style to. In addition to the style, the layer will get two\n * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used\n * for the layer, and `mapbox-layers` will be an array of the `id`s of the\n * `glStyle`'s layers.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} sourceOrLayers `source` key or an array of layer `id`s\n * from the Mapbox Style object. When a `source` key is provided, all layers for\n * the specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {Array<number>} resolutions\n * Resolutions for mapping resolution to zoom level.\n * @param {Object} spriteData Sprite data from the url specified in\n * the Mapbox Style object's `sprite` property. Only required if a `sprite`\n * property is specified in the Mapbox Style object.\n * @param {string} spriteImageUrl Sprite image url for the sprite\n * specified in the Mapbox Style object's `sprite` property. Only required if a\n * `sprite` property is specified in the Mapbox Style object.\n * @param {function(Array<string>):Array<string>} getFonts Function that\n * receives a font stack as arguments, and returns a (modified) font stack that\n * is available. Font names are the names used in the Mapbox Style object. If\n * not provided, the font stack will be used as-is. This function can also be\n * used for loading web fonts.\n * @param {function(VectorLayer|VectorTileLayer, string):HTMLImageElement|HTMLCanvasElement|string|undefined} [getImage=undefined]\n * Function that returns an image or a URL for an image name. If the result is an HTMLImageElement, it must already be\n * loaded. The layer can be used to call layer.changed() when the loading and processing of the image has finished.\n * This function can be used for icons not in the sprite or to override sprite icons.\n * @return {StyleFunction} Style function for use in\n * `ol.layer.Vector` or `ol.layer.VectorTile`.\n */\nfunction stylefunction(olLayer, glStyle, sourceOrLayers, resolutions, spriteData, spriteImageUrl, getFonts, getImage) {\n  if (resolutions === void 0) resolutions = defaultResolutions;\n  if (spriteData === void 0) spriteData = undefined;\n  if (spriteImageUrl === void 0) spriteImageUrl = undefined;\n  if (getFonts === void 0) getFonts = undefined;\n  if (getImage === void 0) getImage = undefined;\n  if (typeof glStyle == 'string') {\n    glStyle = JSON.parse(glStyle);\n  }\n  if (glStyle.version != 8) {\n    throw new Error('glStyle version 8 required.');\n  }\n  var spriteImage, spriteImageSize;\n  if (spriteImageUrl) {\n    if (typeof Image !== 'undefined') {\n      var img = new Image();\n      img.crossOrigin = 'anonymous';\n      img.onload = function () {\n        spriteImage = img;\n        spriteImageSize = [img.width, img.height];\n        olLayer.changed();\n        img.onload = null;\n      };\n      img.src = spriteImageUrl;\n    } else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n      //eslint-disable-line\n      var worker = self;\n      // Main thread needs to handle 'loadImage' and dispatch 'imageLoaded'\n      worker.postMessage({\n        action: 'loadImage',\n        src: spriteImageUrl\n      });\n      worker.addEventListener('message', function handler(event) {\n        if (event.data.action === 'imageLoaded' && event.data.src === spriteImageUrl) {\n          spriteImage = event.data.image;\n          spriteImageSize = [spriteImage.width, spriteImage.height];\n        }\n      });\n    }\n  }\n  var allLayers = derefLayers(glStyle.layers);\n  var layersBySourceLayer = {};\n  var mapboxLayers = [];\n  var iconImageCache = {};\n  var patternCache = {};\n  var functionCache = getFunctionCache(glStyle);\n  var filterCache = getFilterCache(glStyle);\n  var mapboxSource;\n  for (var i = 0, ii = allLayers.length; i < ii; ++i) {\n    var layer = allLayers[i];\n    var layerId = layer.id;\n    if (typeof sourceOrLayers == 'string' && layer.source == sourceOrLayers || sourceOrLayers.indexOf(layerId) !== -1) {\n      var sourceLayer = layer['source-layer'];\n      if (!mapboxSource) {\n        mapboxSource = layer.source;\n        var source = glStyle.sources[mapboxSource];\n        if (!source) {\n          throw new Error(\"Source \\\"\" + mapboxSource + \"\\\" is not defined\");\n        }\n        var type = source.type;\n        if (type !== 'vector' && type !== 'geojson') {\n          throw new Error(\"Source \\\"\" + mapboxSource + \"\\\" is not of type \\\"vector\\\" or \\\"geojson\\\", but \\\"\" + type + \"\\\"\");\n        }\n      } else if (layer.source !== mapboxSource) {\n        throw new Error(\"Layer \\\"\" + layerId + \"\\\" does not use source \\\"\" + mapboxSource);\n      }\n      var layers = layersBySourceLayer[sourceLayer];\n      if (!layers) {\n        layers = [];\n        layersBySourceLayer[sourceLayer] = layers;\n      }\n      layers.push({\n        layer: layer,\n        index: i\n      });\n      mapboxLayers.push(layerId);\n    }\n  }\n  var textHalo = new Stroke();\n  var textColor = new Fill();\n  var styles = [];\n  var styleFunction = function (feature, resolution) {\n    var properties = feature.getProperties();\n    var layers = layersBySourceLayer[properties.layer];\n    if (!layers) {\n      return;\n    }\n    var zoom = resolutions.indexOf(resolution);\n    if (zoom == -1) {\n      zoom = getZoomForResolution(resolution, resolutions);\n    }\n    var type = types[feature.getGeometry().getType()];\n    var f = {\n      properties: properties,\n      type: type\n    };\n    var featureState = olLayer.get('mapbox-featurestate')[feature.getId()];\n    var stylesLength = -1;\n    var featureBelongsToLayer;\n    for (var i = 0, ii = layers.length; i < ii; ++i) {\n      var layerData = layers[i];\n      var layer = layerData.layer;\n      var layerId = layer.id;\n      var layout = layer.layout || emptyObj$1;\n      var paint = layer.paint || emptyObj$1;\n      if (layout.visibility === 'none' || 'minzoom' in layer && zoom < layer.minzoom || 'maxzoom' in layer && zoom >= layer.maxzoom) {\n        continue;\n      }\n      var filter = layer.filter;\n      if (!filter || evaluateFilter(layerId, filter, f, zoom, filterCache)) {\n        featureBelongsToLayer = layer;\n        var color = void 0,\n          opacity = void 0,\n          fill = void 0,\n          stroke = void 0,\n          strokeColor = void 0,\n          style = void 0;\n        var index = layerData.index;\n        if (type == 3 && (layer.type == 'fill' || layer.type == 'fill-extrusion')) {\n          opacity = getValue(layer, 'paint', layer.type + '-opacity', zoom, f, functionCache, featureState);\n          if (layer.type + '-pattern' in paint) {\n            var fillIcon = getValue(layer, 'paint', layer.type + '-pattern', zoom, f, functionCache, featureState);\n            if (fillIcon) {\n              var icon = typeof fillIcon === 'string' ? fromTemplate(fillIcon, properties) : fillIcon.toString();\n              if (spriteImage && spriteData && spriteData[icon]) {\n                ++stylesLength;\n                style = styles[stylesLength];\n                if (!style || !style.getFill() || style.getStroke() || style.getText()) {\n                  style = new Style({\n                    fill: new Fill()\n                  });\n                  styles[stylesLength] = style;\n                }\n                fill = style.getFill();\n                style.setZIndex(index);\n                var icon_cache_key = icon + '.' + opacity;\n                var pattern = patternCache[icon_cache_key];\n                if (!pattern) {\n                  var spriteImageData = spriteData[icon];\n                  var canvas = createCanvas(spriteImageData.width, spriteImageData.height);\n                  var ctx = canvas.getContext('2d');\n                  ctx.globalAlpha = opacity;\n                  ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                  pattern = ctx.createPattern(canvas, 'repeat');\n                  patternCache[icon_cache_key] = pattern;\n                }\n                fill.setColor(pattern);\n              }\n            }\n          } else {\n            color = colorWithOpacity(getValue(layer, 'paint', layer.type + '-color', zoom, f, functionCache, featureState), opacity);\n            if (layer.type + '-outline-color' in paint) {\n              strokeColor = colorWithOpacity(getValue(layer, 'paint', layer.type + '-outline-color', zoom, f, functionCache, featureState), opacity);\n            }\n            if (!strokeColor) {\n              strokeColor = color;\n            }\n            if (color || strokeColor) {\n              ++stylesLength;\n              style = styles[stylesLength];\n              if (!style || color && !style.getFill() || !color && style.getFill() || strokeColor && !style.getStroke() || !strokeColor && style.getStroke() || style.getText()) {\n                style = new Style({\n                  fill: color ? new Fill() : undefined,\n                  stroke: strokeColor ? new Stroke() : undefined\n                });\n                styles[stylesLength] = style;\n              }\n              if (color) {\n                fill = style.getFill();\n                fill.setColor(color);\n              }\n              if (strokeColor) {\n                stroke = style.getStroke();\n                stroke.setColor(strokeColor);\n                stroke.setWidth(0.5);\n              }\n              style.setZIndex(index);\n            }\n          }\n        }\n        if (type != 1 && layer.type == 'line') {\n          color = !('line-pattern' in paint) && 'line-color' in paint ? colorWithOpacity(getValue(layer, 'paint', 'line-color', zoom, f, functionCache, featureState), getValue(layer, 'paint', 'line-opacity', zoom, f, functionCache, featureState)) : undefined;\n          var width = getValue(layer, 'paint', 'line-width', zoom, f, functionCache, featureState);\n          if (color && width > 0) {\n            ++stylesLength;\n            style = styles[stylesLength];\n            if (!style || !style.getStroke() || style.getFill() || style.getText()) {\n              style = new Style({\n                stroke: new Stroke()\n              });\n              styles[stylesLength] = style;\n            }\n            stroke = style.getStroke();\n            stroke.setLineCap(getValue(layer, 'layout', 'line-cap', zoom, f, functionCache, featureState));\n            stroke.setLineJoin(getValue(layer, 'layout', 'line-join', zoom, f, functionCache, featureState));\n            stroke.setMiterLimit(getValue(layer, 'layout', 'line-miter-limit', zoom, f, functionCache, featureState));\n            stroke.setColor(color);\n            stroke.setWidth(width);\n            stroke.setLineDash(paint['line-dasharray'] ? getValue(layer, 'paint', 'line-dasharray', zoom, f, functionCache, featureState).map(function (x) {\n              return x * width;\n            }) : null);\n            style.setZIndex(index);\n          }\n        }\n        var hasImage = false;\n        var text = null;\n        var placementAngle = 0;\n        var icon$1 = void 0,\n          iconImg = void 0,\n          skipLabel = void 0;\n        if ((type == 1 || type == 2) && 'icon-image' in layout) {\n          var iconImage = getValue(layer, 'layout', 'icon-image', zoom, f, functionCache, featureState);\n          if (iconImage) {\n            icon$1 = typeof iconImage === 'string' ? fromTemplate(iconImage, properties) : iconImage.toString();\n            var styleGeom = undefined;\n            var imageElement = getImage ? getImage(olLayer, icon$1) : undefined;\n            if (spriteImage && spriteData && spriteData[icon$1] || imageElement) {\n              var iconRotationAlignment = getValue(layer, 'layout', 'icon-rotation-alignment', zoom, f, functionCache, featureState);\n              if (type == 2) {\n                var geom = feature.getGeometry();\n                // ol package and ol-debug.js only\n                if (geom.getFlatMidpoint || geom.getFlatMidpoints) {\n                  var extent = geom.getExtent();\n                  var size = Math.sqrt(Math.max(Math.pow((extent[2] - extent[0]) / resolution, 2), Math.pow((extent[3] - extent[1]) / resolution, 2)));\n                  if (size > 150) {\n                    //FIXME Do not hard-code a size of 150\n                    var midpoint = geom.getType() === 'MultiLineString' ? geom.getFlatMidpoints() : geom.getFlatMidpoint();\n                    if (!renderFeature) {\n                      renderFeatureCoordinates = [NaN, NaN];\n                      renderFeature = new RenderFeature('Point', renderFeatureCoordinates, [], {}, null);\n                    }\n                    styleGeom = renderFeature;\n                    renderFeatureCoordinates[0] = midpoint[0];\n                    renderFeatureCoordinates[1] = midpoint[1];\n                    var placement = getValue(layer, 'layout', 'symbol-placement', zoom, f, functionCache, featureState);\n                    if (placement === 'line' && iconRotationAlignment === 'map') {\n                      var stride = geom.getStride();\n                      var coordinates = geom.getFlatCoordinates();\n                      for (var i$1 = 0, ii$1 = coordinates.length - stride; i$1 < ii$1; i$1 += stride) {\n                        var x1 = coordinates[i$1];\n                        var y1 = coordinates[i$1 + 1];\n                        var x2 = coordinates[i$1 + stride];\n                        var y2 = coordinates[i$1 + stride + 1];\n                        var minX = Math.min(x1, x2);\n                        var minY = Math.min(y1, y2);\n                        var maxX = Math.max(x1, x2);\n                        var maxY = Math.max(y1, y2);\n                        if (midpoint[0] >= minX && midpoint[0] <= maxX && midpoint[1] >= minY && midpoint[1] <= maxY) {\n                          placementAngle = Math.atan2(y1 - y2, x2 - x1);\n                          break;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n              if (type !== 2 || styleGeom) {\n                var iconSize = getValue(layer, 'layout', 'icon-size', zoom, f, functionCache, featureState);\n                var iconColor = paint['icon-color'] !== undefined ? getValue(layer, 'paint', 'icon-color', zoom, f, functionCache, featureState) : null;\n                if (!iconColor || iconColor.a !== 0) {\n                  var haloColor = getValue(layer, 'paint', 'icon-halo-color', zoom, f, functionCache, featureState);\n                  var haloWidth = getValue(layer, 'paint', 'icon-halo-width', zoom, f, functionCache, featureState);\n                  var iconCacheKey = icon$1 + \".\" + iconSize + \".\" + haloWidth + \".\" + haloColor;\n                  if (iconColor !== null) {\n                    iconCacheKey += \".\" + iconColor;\n                  }\n                  iconImg = iconImageCache[iconCacheKey];\n                  if (!iconImg) {\n                    var declutterMode = getIconDeclutterMode(layer, zoom, f, functionCache);\n                    var displacement = void 0;\n                    if ('icon-offset' in layout) {\n                      displacement = getValue(layer, 'layout', 'icon-offset', zoom, f, functionCache, featureState);\n                      displacement[1] *= -1;\n                    }\n                    var color$1 = iconColor ? [iconColor.r * 255, iconColor.g * 255, iconColor.b * 255, iconColor.a] : undefined;\n                    if (imageElement) {\n                      var iconOptions = {\n                        color: color$1,\n                        rotateWithView: iconRotationAlignment === 'map',\n                        displacement: displacement,\n                        declutterMode: declutterMode\n                      };\n                      if (typeof imageElement === 'string') {\n                        // it is a src URL\n                        iconOptions.src = imageElement;\n                      } else {\n                        iconOptions.img = imageElement;\n                        iconOptions.imgSize = [imageElement.width, imageElement.height];\n                      }\n                      iconImg = new Icon(iconOptions);\n                    } else {\n                      var spriteImageData$1 = spriteData[icon$1];\n                      var img = void 0,\n                        imgSize = void 0,\n                        size$1 = void 0,\n                        offset = void 0;\n                      if (haloWidth) {\n                        img = drawIconHalo(spriteImage, spriteImageData$1, haloWidth, haloColor);\n                        imgSize = [img.width, img.height];\n                      } else {\n                        img = spriteImage;\n                        imgSize = spriteImageSize;\n                        size$1 = [spriteImageData$1.width, spriteImageData$1.height];\n                        offset = [spriteImageData$1.x, spriteImageData$1.y];\n                      }\n                      iconImg = new Icon({\n                        color: color$1,\n                        img: img,\n                        imgSize: imgSize,\n                        size: size$1,\n                        offset: offset,\n                        rotateWithView: iconRotationAlignment === 'map',\n                        scale: iconSize / spriteImageData$1.pixelRatio,\n                        displacement: displacement,\n                        declutterMode: declutterMode\n                      });\n                    }\n                    iconImageCache[iconCacheKey] = iconImg;\n                  }\n                }\n                if (iconImg) {\n                  ++stylesLength;\n                  style = styles[stylesLength];\n                  if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n                    style = new Style();\n                    styles[stylesLength] = style;\n                  }\n                  style.setGeometry(styleGeom);\n                  iconImg.setRotation(placementAngle + deg2rad(getValue(layer, 'layout', 'icon-rotate', zoom, f, functionCache, featureState)));\n                  iconImg.setOpacity(getValue(layer, 'paint', 'icon-opacity', zoom, f, functionCache, featureState));\n                  iconImg.setAnchor(anchor[getValue(layer, 'layout', 'icon-anchor', zoom, f, functionCache, featureState)]);\n                  style.setImage(iconImg);\n                  text = style.getText();\n                  style.setText(undefined);\n                  style.setZIndex(index);\n                  hasImage = true;\n                  skipLabel = false;\n                }\n              } else {\n                skipLabel = true;\n              }\n            }\n          }\n        }\n        if (type == 1 && layer.type === 'circle') {\n          ++stylesLength;\n          style = styles[stylesLength];\n          if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n            style = new Style();\n            styles[stylesLength] = style;\n          }\n          var circleRadius = 'circle-radius' in paint ? getValue(layer, 'paint', 'circle-radius', zoom, f, functionCache, featureState) : 5;\n          var circleStrokeColor = colorWithOpacity(getValue(layer, 'paint', 'circle-stroke-color', zoom, f, functionCache, featureState), getValue(layer, 'paint', 'circle-stroke-opacity', zoom, f, functionCache, featureState));\n          var circleColor = colorWithOpacity(getValue(layer, 'paint', 'circle-color', zoom, f, functionCache, featureState), getValue(layer, 'paint', 'circle-opacity', zoom, f, functionCache, featureState));\n          var circleStrokeWidth = getValue(layer, 'paint', 'circle-stroke-width', zoom, f, functionCache, featureState);\n          var cache_key = circleRadius + '.' + circleStrokeColor + '.' + circleColor + '.' + circleStrokeWidth;\n          iconImg = iconImageCache[cache_key];\n          if (!iconImg) {\n            iconImg = new Circle({\n              radius: circleRadius,\n              stroke: circleStrokeColor && circleStrokeWidth > 0 ? new Stroke({\n                width: circleStrokeWidth,\n                color: circleStrokeColor\n              }) : undefined,\n              fill: circleColor ? new Fill({\n                color: circleColor\n              }) : undefined,\n              declutterMode: 'none'\n            });\n            iconImageCache[cache_key] = iconImg;\n          }\n          style.setImage(iconImg);\n          text = style.getText();\n          style.setText(undefined);\n          style.setGeometry(undefined);\n          style.setZIndex(index);\n          hasImage = true;\n        }\n        var label = void 0,\n          font = void 0,\n          textLineHeight = void 0,\n          textSize = void 0,\n          letterSpacing = void 0,\n          maxTextWidth = void 0;\n        if ('text-field' in layout) {\n          textSize = Math.round(getValue(layer, 'layout', 'text-size', zoom, f, functionCache, featureState));\n          var fontArray = getValue(layer, 'layout', 'text-font', zoom, f, functionCache, featureState);\n          textLineHeight = getValue(layer, 'layout', 'text-line-height', zoom, f, functionCache, featureState);\n          font = mapboxToCssFont(getFonts ? getFonts(fontArray) : fontArray, textSize, textLineHeight);\n          if (!font.includes('sans-serif')) {\n            font += ',sans-serif';\n          }\n          letterSpacing = getValue(layer, 'layout', 'text-letter-spacing', zoom, f, functionCache, featureState);\n          maxTextWidth = getValue(layer, 'layout', 'text-max-width', zoom, f, functionCache, featureState);\n          var textField = getValue(layer, 'layout', 'text-field', zoom, f, functionCache, featureState);\n          if (typeof textField === 'object' && textField.sections) {\n            if (textField.sections.length === 1) {\n              label = textField.toString();\n            } else {\n              label = textField.sections.reduce(function (acc, chunk, i) {\n                var fonts = chunk.fontStack ? chunk.fontStack.split(',') : fontArray;\n                var chunkFont = mapboxToCssFont(getFonts ? getFonts(fonts) : fonts, textSize * (chunk.scale || 1), textLineHeight);\n                var text = chunk.text;\n                if (text === '\\n') {\n                  acc.push('\\n', '');\n                  return acc;\n                }\n                if (type == 2) {\n                  acc.push(applyLetterSpacing(text, letterSpacing), chunkFont);\n                  return;\n                }\n                text = wrapText(text, chunkFont, maxTextWidth, letterSpacing).split('\\n');\n                for (var i$1 = 0, ii = text.length; i$1 < ii; ++i$1) {\n                  if (i$1 > 0) {\n                    acc.push('\\n', '');\n                  }\n                  acc.push(text[i$1], chunkFont);\n                }\n                return acc;\n              }, []);\n            }\n          } else {\n            label = fromTemplate(textField, properties).trim();\n          }\n          opacity = getValue(layer, 'paint', 'text-opacity', zoom, f, functionCache, featureState);\n        }\n        if (label && opacity && !skipLabel) {\n          if (!hasImage) {\n            ++stylesLength;\n            style = styles[stylesLength];\n            if (!style || !style.getText() || style.getFill() || style.getStroke()) {\n              style = new Style();\n              styles[stylesLength] = style;\n            }\n            style.setImage(undefined);\n            style.setGeometry(undefined);\n          }\n          if (!style.getText()) {\n            style.setText(text || new Text({\n              padding: [2, 2, 2, 2]\n            }));\n          }\n          text = style.getText();\n          var textTransform = layout['text-transform'];\n          if (textTransform == 'uppercase') {\n            label = Array.isArray(label) ? label.map(function (t, i) {\n              return i % 2 ? t : t.toUpperCase();\n            }) : label.toUpperCase();\n          } else if (textTransform == 'lowercase') {\n            label = Array.isArray(label) ? label.map(function (t, i) {\n              return i % 2 ? t : t.toLowerCase();\n            }) : label.toLowerCase();\n          }\n          var wrappedLabel = Array.isArray(label) ? label : type == 2 ? applyLetterSpacing(label, letterSpacing) : wrapText(label, font, maxTextWidth, letterSpacing);\n          text.setText(wrappedLabel);\n          text.setFont(font);\n          text.setRotation(deg2rad(getValue(layer, 'layout', 'text-rotate', zoom, f, functionCache, featureState)));\n          var textAnchor = getValue(layer, 'layout', 'text-anchor', zoom, f, functionCache, featureState);\n          var placement$1 = hasImage || type == 1 ? 'point' : getValue(layer, 'layout', 'symbol-placement', zoom, f, functionCache, featureState);\n          text.setPlacement(placement$1);\n          if (typeof text.setRepeat === 'function') {\n            var symbolSpacing = getValue(layer, 'layout', 'symbol-spacing', zoom, f, functionCache, featureState);\n            text.setRepeat(symbolSpacing * 2);\n          }\n          text.setOverflow(placement$1 === 'point');\n          var textHaloWidth = getValue(layer, 'paint', 'text-halo-width', zoom, f, functionCache, featureState);\n          var textOffset = getValue(layer, 'layout', 'text-offset', zoom, f, functionCache, featureState);\n          var textTranslate = getValue(layer, 'paint', 'text-translate', zoom, f, functionCache, featureState);\n          // Text offset has to take halo width and line height into account\n          var vOffset = 0;\n          var hOffset = 0;\n          if (placement$1 == 'point') {\n            var textAlign = 'center';\n            if (textAnchor.indexOf('left') !== -1) {\n              textAlign = 'left';\n              hOffset = textHaloWidth;\n            } else if (textAnchor.indexOf('right') !== -1) {\n              textAlign = 'right';\n              hOffset = -textHaloWidth;\n            }\n            text.setTextAlign(textAlign);\n            var textRotationAlignment = getValue(layer, 'layout', 'text-rotation-alignment', zoom, f, functionCache, featureState);\n            text.setRotateWithView(textRotationAlignment == 'map');\n          } else {\n            text.setMaxAngle(deg2rad(getValue(layer, 'layout', 'text-max-angle', zoom, f, functionCache, featureState)) * label.length / wrappedLabel.length);\n            text.setTextAlign();\n            text.setRotateWithView(false);\n          }\n          var textBaseline = 'middle';\n          if (textAnchor.indexOf('bottom') == 0) {\n            textBaseline = 'bottom';\n            vOffset = -textHaloWidth - 0.5 * (textLineHeight - 1) * textSize;\n          } else if (textAnchor.indexOf('top') == 0) {\n            textBaseline = 'top';\n            vOffset = textHaloWidth + 0.5 * (textLineHeight - 1) * textSize;\n          }\n          text.setTextBaseline(textBaseline);\n          var textJustify = getValue(layer, 'layout', 'text-justify', zoom, f, functionCache, featureState);\n          text.setJustify(textJustify === 'auto' ? undefined : textJustify);\n          text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);\n          text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);\n          textColor.setColor(colorWithOpacity(getValue(layer, 'paint', 'text-color', zoom, f, functionCache, featureState), opacity));\n          text.setFill(textColor);\n          var haloColor$1 = colorWithOpacity(getValue(layer, 'paint', 'text-halo-color', zoom, f, functionCache, featureState), opacity);\n          if (haloColor$1) {\n            textHalo.setColor(haloColor$1);\n            // spec here : https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-symbol-text-halo-width\n            // Halo width must be doubled because it is applied around the center of the text outline\n            textHaloWidth *= 2;\n            // 1/4 of text size (spec) x 2\n            var halfTextSize = 0.5 * textSize;\n            textHalo.setWidth(textHaloWidth <= halfTextSize ? textHaloWidth : halfTextSize);\n            text.setStroke(textHalo);\n          } else {\n            text.setStroke(undefined);\n          }\n          var textPadding = getValue(layer, 'layout', 'text-padding', zoom, f, functionCache, featureState);\n          var padding = text.getPadding();\n          if (textPadding !== padding[0]) {\n            padding[0] = textPadding;\n            padding[1] = textPadding;\n            padding[2] = textPadding;\n            padding[3] = textPadding;\n          }\n          style.setZIndex(index);\n        }\n      }\n    }\n    if (stylesLength > -1) {\n      styles.length = stylesLength + 1;\n      if (recordLayer) {\n        if (typeof feature.set === 'function') {\n          // ol/Feature\n          feature.set('mapbox-layer', featureBelongsToLayer);\n        } else {\n          // ol/render/Feature\n          feature.getProperties()['mapbox-layer'] = featureBelongsToLayer;\n        }\n      }\n      return styles;\n    }\n  };\n  olLayer.setStyle(styleFunction);\n  olLayer.set('mapbox-source', mapboxSource);\n  olLayer.set('mapbox-layers', mapboxLayers);\n  olLayer.set('mapbox-featurestate', {});\n  return styleFunction;\n}\n\n/**\n * Generates a shaded relief image given elevation data.  Uses a 3x3\n * neighborhood for determining slope and aspect.\n * @param {Array<ImageData>} inputs Array of input images.\n * @param {Object} data Data added in the \"beforeoperations\" event.\n * @return {ImageData} Output image.\n */\nfunction hillshade(inputs, data) {\n  var elevationImage = inputs[0];\n  var width = elevationImage.width;\n  var height = elevationImage.height;\n  var elevationData = elevationImage.data;\n  var shadeData = new Uint8ClampedArray(elevationData.length);\n  var dp = data.resolution * 2;\n  var maxX = width - 1;\n  var maxY = height - 1;\n  var pixel = [0, 0, 0, 0];\n  var twoPi = 2 * Math.PI;\n  var halfPi = Math.PI / 2;\n  var sunEl = Math.PI * data.sunEl / 180;\n  var sunAz = Math.PI * data.sunAz / 180;\n  var cosSunEl = Math.cos(sunEl);\n  var sinSunEl = Math.sin(sunEl);\n  var highlightColor = data.highlightColor;\n  var shadowColor = data.shadowColor;\n  var accentColor = data.accentColor;\n  var pixelX, pixelY, x0, x1, y0, y1, offset, z0, z1, dzdx, dzdy, slope, aspect, accent, scaled, shade, scaledAccentColor, compositeShadeColor, clamp, slopeScaleBase, scaledSlope, cosIncidence;\n  function calculateElevation(pixel) {\n    // The method used to extract elevations from the DEM.\n    // In this case the format used is\n    // red + green * 2 + blue * 3\n    //\n    // Other frequently used methods include the Mapbox format\n    // (red * 256 * 256 + green * 256 + blue) * 0.1 - 10000\n    // and the Terrarium format\n    // (red * 256 + green + blue / 256) - 32768\n    //\n    return (pixel[0] * 256 * 256 + pixel[1] * 256 + pixel[2]) * 0.1 - 10000;\n  }\n  for (pixelY = 0; pixelY <= maxY; ++pixelY) {\n    y0 = pixelY === 0 ? 0 : pixelY - 1;\n    y1 = pixelY === maxY ? maxY : pixelY + 1;\n    for (pixelX = 0; pixelX <= maxX; ++pixelX) {\n      x0 = pixelX === 0 ? 0 : pixelX - 1;\n      x1 = pixelX === maxX ? maxX : pixelX + 1;\n      // determine elevation for (x0, pixelY)\n      offset = (pixelY * width + x0) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      z0 = data.vert * calculateElevation(pixel);\n      // determine elevation for (x1, pixelY)\n      offset = (pixelY * width + x1) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      z1 = data.vert * calculateElevation(pixel);\n      dzdx = (z1 - z0) / dp;\n      // determine elevation for (pixelX, y0)\n      offset = (y0 * width + pixelX) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      z0 = data.vert * calculateElevation(pixel);\n      // determine elevation for (pixelX, y1)\n      offset = (y1 * width + pixelX) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      z1 = data.vert * calculateElevation(pixel);\n      dzdy = (z1 - z0) / dp;\n      aspect = Math.atan2(dzdy, -dzdx);\n      if (aspect < 0) {\n        aspect = halfPi - aspect;\n      } else if (aspect > halfPi) {\n        aspect = twoPi - aspect + halfPi;\n      } else {\n        aspect = halfPi - aspect;\n      }\n      // Bootstrap slope and corresponding incident values\n      slope = Math.atan(Math.sqrt(dzdx * dzdx + dzdy * dzdy));\n      cosIncidence = sinSunEl * Math.cos(slope) + cosSunEl * Math.sin(slope) * Math.cos(sunAz - aspect);\n      accent = Math.cos(slope);\n      // 255 for Hex colors\n      scaled = 255 * cosIncidence;\n      /*\n      * The following is heavily inspired\n      * by [Maplibre's equivalent WebGL shader](https://github.com/maplibre/maplibre-gl-js/blob/main/src/shaders/hillshade.fragment.glsl)\n      */\n      // Forces given value to stay between two given extremes\n      clamp = Math.min(Math.max(2 * data.sunEl, 0), 1);\n      // Intensity basis for hillshade opacity\n      slopeScaleBase = 1.875 - data.opacity * 1.75;\n      // Intensity interpolation so that higher intensity values create more opaque hillshading\n      scaledSlope = data.opacity !== 0.5 ? halfPi * ((Math.pow(slopeScaleBase, slope) - 1) / (Math.pow(slopeScaleBase, halfPi) - 1)) : slope;\n      // Accent hillshade color with given accentColor to emphasize rougher terrain\n      scaledAccentColor = {\n        r: (1 - accent) * accentColor.r * clamp * 255,\n        g: (1 - accent) * accentColor.g * clamp * 255,\n        b: (1 - accent) * accentColor.b * clamp * 255,\n        a: (1 - accent) * accentColor.a * clamp * 255\n      };\n      // Allows highlight vs shadow discrimination\n      shade = Math.abs(((aspect + sunAz) / Math.PI + 0.5) % 2 - 1);\n      // Creates a composite color mix between highlight & shadow colors to emphasize slopes\n      compositeShadeColor = {\n        r: (highlightColor.r * (1 - shade) + shadowColor.r * shade) * scaled,\n        g: (highlightColor.g * (1 - shade) + shadowColor.g * shade) * scaled,\n        b: (highlightColor.b * (1 - shade) + shadowColor.b * shade) * scaled,\n        a: (highlightColor.a * (1 - shade) + shadowColor.a * shade) * scaled\n      };\n      // Fill in result color value\n      offset = (pixelY * width + pixelX) * 4;\n      shadeData[offset] = scaledAccentColor.r * (1 - shade) + compositeShadeColor.r;\n      shadeData[offset + 1] = scaledAccentColor.g * (1 - shade) + compositeShadeColor.g;\n      shadeData[offset + 2] = scaledAccentColor.b * (1 - shade) + compositeShadeColor.b;\n      // Key opacity on the scaledSlope to improve legibility by increasing higher elevation rates' contrast\n      shadeData[offset + 3] = elevationData[offset + 3] * data.opacity * clamp * Math.sin(scaledSlope);\n    }\n  }\n  return new ImageData(shadeData, width, height);\n}\n\n/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\n/**\n * @typedef {Object} FeatureIdentifier\n * @property {string|number} id The feature id.\n * @property {string} source The source id.\n */\n/**\n * @typedef {Object} Options\n * @property {string} [accessToken] Access token for 'mapbox://' urls.\n * @property {function(string, ResourceType): (Request|void)} [transformRequest]\n * Function for controlling how `ol-mapbox-style` fetches resources. Can be used for modifying\n * the url, adding headers or setting credentials options. Called with the url and the resource\n * type as arguments, this function is supposed to return a `Request` object. Without a return value,\n * the original request will not be modified. For `Tiles` and `GeoJSON` resources, only the `url` of\n * the returned request will be respected.\n * @property {string} [projection='EPSG:3857'] Only useful when working with non-standard projections.\n * Code of a projection registered with OpenLayers. All sources of the style must be provided in this\n * projection. The projection must also have a valid extent defined, which will be used to determine the\n * origin and resolutions of the tile grid for all tiled sources of the style. When provided, the bbox\n * placeholder in tile and geojson urls changes: the default is `{bbox-epsg-3857}`, when projection is e.g.\n * set to `EPSG:4326`, the bbox placeholder will be `{bbox-epsg-4326}`.\n * @property {Array<number>} [resolutions] Only useful when working with non-standard projections.\n * Resolutions for mapping resolution to the `zoom` used in the Mapbox style.\n * @property {string} [styleUrl] URL of the Mapbox GL style. Required for styles that were provided\n * as object, when they contain a relative sprite url, or sources referencing data by relative url.\n * @property {function(VectorLayer|VectorTileLayer, string):HTMLImageElement|HTMLCanvasElement|string|undefined} [getImage=undefined]\n * Function that returns an image for an icon name. If the result is an HTMLImageElement, it must already be\n * loaded. The layer can be used to call layer.changed() when the loading and processing of the image has finished.\n * This function be used for icons not in the sprite or to override sprite icons.\n * @property {string} [accessTokenParam='access_token'] Access token param. For internal use.\n */\n/**\n * @typedef {Object} ApplyStyleOptions\n * @property {string} [source=''] Source. Default is `''`, which causes the first source in the\n * style to be used.\n * @property {Array<string>} [layers] Layers. If no source is provided, the layers with the\n * provided ids will be used from the style's `layers` array. All layers need to use the same source.\n * @property {boolean} [updateSource=true] Update or create vector (tile) layer source with parameters\n * specified for the source in the mapbox style definition.\n */\n/** @typedef {'Style'|'Source'|'Sprite'|'SpriteImage'|'Tiles'|'GeoJSON'} ResourceType */\n/**\n * @param {import(\"ol/proj/Projection.js\").default} projection Projection.\n * @param {number} [tileSize=512] Tile size.\n * @return {Array<number>} Resolutions.\n */\nfunction getTileResolutions(projection, tileSize) {\n  if (tileSize === void 0) tileSize = 512;\n  return projection.getExtent() ? createXYZ({\n    extent: projection.getExtent(),\n    tileSize: tileSize,\n    maxZoom: 22\n  }).getResolutions() : defaultResolutions;\n}\n/**\n * @param {string} styleUrl Style URL.\n * @param {Options} options Options.\n * @return {Options} Completed options with accessToken and accessTokenParam.\n */\nfunction completeOptions(styleUrl, options) {\n  if (!options.accessToken) {\n    options = Object.assign({}, options);\n    var searchParams = new URL(styleUrl).searchParams;\n    // The last search parameter is the access token\n    searchParams.forEach(function (value, key) {\n      options.accessToken = value;\n      options.accessTokenParam = key;\n    });\n  }\n  return options;\n}\n/**\n * Applies a style function to an `ol/layer/VectorTile` or `ol/layer/Vector`\n * with an `ol/source/VectorTile` or an `ol/source/Vector`. If the layer does not have a source\n * yet, it will be created and populated from the information in the `glStyle` (unless `updateSource` is\n * set to `false`).\n *\n * **Example:**\n * ```js\n * import {applyStyle} from 'ol-mapbox-style';\n * import {VectorTile} from 'ol/layer.js';\n *\n * const layer = new VectorTile({declutter: true});\n * applyStyle(layer, 'https://api.maptiler.com/maps/basic/style.json?key=YOUR_OPENMAPTILES_TOKEN');\n * ```\n *\n * The style function will render all layers from the `glStyle` object that use the source\n * of the first layer, the specified `source`, or a subset of layers from the same source. The\n * source needs to be a `\"type\": \"vector\"` or `\"type\": \"geojson\"` source.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * @param {VectorTileLayer|VectorLayer} layer OpenLayers layer. When the layer has a source configured,\n * it will be modified to use the configuration from the glStyle's `source`. Options specified on the\n * layer's source will override those from the glStyle's `source`, except for `url`,\n * `tileUrlFunction` and `tileGrid` (exception: when the source projection is not `EPSG:3857`).\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>|Options&ApplyStyleOptions} [sourceOrLayersOrOptions] Options or\n * `source` key or an array of layer `id`s from the Mapbox Style object. When a `source` key is\n * provided, all layers for the specified source will be included in the style function. When layer\n * `id`s are provided, they must be from layers that use the same source. When not provided or a falsey\n * value, all layers using the first source specified in the glStyle will be rendered.\n * @param {Options&ApplyStyleOptions|string} [optionsOrPath] **Deprecated**. Options. Alternatively the path of the style file\n * (only required when a relative path is used for the `\"sprite\"` property of the style).\n * @param {Array<number>} [resolutions] **Deprecated**. Resolutions for mapping resolution to zoom level.\n * Only needed when working with non-standard tile grids or projections, can also be supplied with\n * options.\n * @return {Promise} Promise which will be resolved when the style can be used\n * for rendering.\n */\nfunction applyStyle(layer, glStyle, sourceOrLayersOrOptions, optionsOrPath, resolutions) {\n  if (sourceOrLayersOrOptions === void 0) sourceOrLayersOrOptions = '';\n  if (optionsOrPath === void 0) optionsOrPath = {};\n  if (resolutions === void 0) resolutions = undefined;\n  var styleUrl, sourceId;\n  /** @type {Options&ApplyStyleOptions} */\n  var options;\n  var sourceOrLayers;\n  var updateSource = true;\n  if (typeof sourceOrLayersOrOptions !== 'string' && !Array.isArray(sourceOrLayersOrOptions)) {\n    options = sourceOrLayersOrOptions;\n    sourceOrLayers = options.source || options.layers;\n    optionsOrPath = options;\n  } else {\n    sourceOrLayers = sourceOrLayersOrOptions;\n  }\n  if (typeof optionsOrPath === 'string') {\n    styleUrl = optionsOrPath;\n    options = {};\n  } else {\n    styleUrl = optionsOrPath.styleUrl;\n    options = optionsOrPath;\n  }\n  if (options.updateSource === false) {\n    updateSource = false;\n  }\n  if (!resolutions) {\n    resolutions = options.resolutions;\n  }\n  if (!styleUrl && typeof glStyle === 'string' && !glStyle.trim().startsWith('{')) {\n    styleUrl = glStyle;\n  }\n  if (styleUrl) {\n    styleUrl = styleUrl.startsWith('data:') ? location.href : normalizeStyleUrl(styleUrl, options.accessToken);\n    options = completeOptions(styleUrl, options);\n  }\n  return new Promise(function (resolve, reject) {\n    // TODO: figure out where best place to check source type is\n    // Note that the source arg is an array of gl layer ids and each must be\n    // dereferenced to get source type to validate\n    getGlStyle(glStyle, options).then(function (glStyle) {\n      if (glStyle.version != 8) {\n        return reject(new Error('glStyle version 8 required.'));\n      }\n      if (!(layer instanceof VectorLayer || layer instanceof VectorTileLayer)) {\n        return reject(new Error('Can only apply to VectorLayer or VectorTileLayer'));\n      }\n      var type = layer instanceof VectorTileLayer ? 'vector' : 'geojson';\n      if (!sourceOrLayers) {\n        sourceId = Object.keys(glStyle.sources).find(function (key) {\n          return glStyle.sources[key].type === type;\n        });\n        sourceOrLayers = sourceId;\n      } else if (Array.isArray(sourceOrLayers)) {\n        sourceId = glStyle.layers.find(function (layer) {\n          return layer.id === sourceOrLayers[0];\n        }).source;\n      } else {\n        sourceId = sourceOrLayers;\n      }\n      if (!sourceId) {\n        return reject(new Error(\"No \" + type + \" source found in the glStyle.\"));\n      }\n      function assignSource() {\n        if (!updateSource) {\n          return Promise.resolve();\n        }\n        if (layer instanceof VectorTileLayer) {\n          return setupVectorSource(glStyle.sources[sourceId], styleUrl, options).then(function (source) {\n            var targetSource = layer.getSource();\n            if (!targetSource) {\n              layer.setSource(source);\n            } else if (source !== targetSource) {\n              targetSource.setTileUrlFunction(source.getTileUrlFunction());\n              //@ts-ignore\n              if (!targetSource.format_) {\n                //@ts-ignore\n                targetSource.format_ = source.format_;\n              }\n              if (!targetSource.getAttributions()) {\n                targetSource.setAttributions(source.getAttributions());\n              }\n              if (targetSource.getTileLoadFunction() === defaultLoadFunction) {\n                targetSource.setTileLoadFunction(source.getTileLoadFunction());\n              }\n              if (equivalent(targetSource.getProjection(), source.getProjection())) {\n                targetSource.tileGrid = source.getTileGrid();\n              }\n            }\n            if (!isFinite(layer.getMaxResolution()) && !isFinite(layer.getMinZoom())) {\n              var tileGrid = layer.getSource().getTileGrid();\n              layer.setMaxResolution(tileGrid.getResolution(tileGrid.getMinZoom()));\n            }\n          });\n        }\n        var glSource = glStyle.sources[sourceId];\n        var source = layer.getSource();\n        if (!source || source.get('mapbox-source') !== glSource) {\n          source = setupGeoJSONSource(glSource, styleUrl, options);\n        }\n        var targetSource = layer.getSource();\n        if (!targetSource) {\n          layer.setSource(source);\n        } else if (source !== targetSource) {\n          if (!targetSource.getAttributions()) {\n            targetSource.setAttributions(source.getAttributions());\n          }\n          //@ts-ignore\n          if (!targetSource.format_) {\n            //@ts-ignore\n            targetSource.format_ = source.getFormat();\n          }\n          //@ts-ignore\n          targetSource.url_ = source.getUrl();\n        }\n        return Promise.resolve();\n      }\n      var spriteScale, spriteData, spriteImageUrl, style;\n      function onChange() {\n        if (!style && (!glStyle.sprite || spriteData)) {\n          if (options.projection && !resolutions) {\n            var projection = get$1(options.projection);\n            var units = projection.getUnits();\n            if (units !== 'm') {\n              resolutions = defaultResolutions.map(function (resolution) {\n                return resolution / METERS_PER_UNIT[units];\n              });\n            }\n          }\n          style = stylefunction(layer, glStyle, sourceOrLayers, resolutions, spriteData, spriteImageUrl, getFonts, options.getImage);\n          if (!layer.getStyle()) {\n            reject(new Error(\"Nothing to show for source [\" + sourceId + \"]\"));\n          } else {\n            assignSource().then(resolve).catch(reject);\n          }\n        } else if (style) {\n          layer.setStyle(style);\n          assignSource().then(resolve).catch(reject);\n        } else {\n          reject(new Error('Something went wrong trying to apply style.'));\n        }\n      }\n      if (glStyle.sprite) {\n        var sprite = new URL(normalizeSpriteUrl(glStyle.sprite, options.accessToken, styleUrl || location.href));\n        spriteScale = window.devicePixelRatio >= 1.5 ? 0.5 : 1;\n        var sizeFactor = spriteScale == 0.5 ? '@2x' : '';\n        var spriteUrl = sprite.origin + sprite.pathname + sizeFactor + '.json' + sprite.search;\n        new Promise(function (resolve, reject) {\n          fetchResource('Sprite', spriteUrl, options).then(resolve).catch(function (error) {\n            spriteUrl = sprite.origin + sprite.pathname + '.json' + sprite.search;\n            fetchResource('Sprite', spriteUrl, options).then(resolve).catch(reject);\n          });\n        }).then(function (spritesJson) {\n          if (spritesJson === undefined) {\n            reject(new Error('No sprites found.'));\n          }\n          spriteData = spritesJson;\n          spriteImageUrl = sprite.origin + sprite.pathname + sizeFactor + '.png' + sprite.search;\n          if (options.transformRequest) {\n            var transformed = options.transformRequest(spriteImageUrl, 'SpriteImage');\n            if (transformed instanceof Request) {\n              spriteImageUrl = encodeURI(transformed.url);\n            }\n          }\n          onChange();\n        }).catch(function (err) {\n          reject(new Error(\"Sprites cannot be loaded: \" + spriteUrl + \": \" + err.message));\n        });\n      } else {\n        onChange();\n      }\n    }).catch(reject);\n  });\n}\nvar emptyObj = {};\nfunction setFirstBackground(mapOrLayer, glStyle, options) {\n  glStyle.layers.some(function (layer) {\n    if (layer.type === 'background') {\n      if (mapOrLayer instanceof Layer) {\n        mapOrLayer.setBackground(function (resolution) {\n          return getBackgroundColor(layer, resolution, options, {});\n        });\n        return true;\n      } else if (mapOrLayer instanceof Map || mapOrLayer instanceof LayerGroup) {\n        mapOrLayer.getLayers().push(setupBackgroundLayer(layer, options, {}));\n        return true;\n      }\n    }\n  });\n}\n/**\n * Applies properties of the Mapbox Style's first `background` layer to the\n * provided map or VectorTile layer.\n *\n * **Example:**\n * ```js\n * import {applyBackground} from 'ol-mapbox-style';\n * import {Map} from 'ol';\n *\n * const map = new Map({target: 'map'});\n * applyBackground(map, 'https://api.maptiler.com/maps/basic/style.json?key=YOUR_OPENMAPTILES_TOKEN');\n * ```\n * @param {Map|VectorTileLayer} mapOrLayer OpenLayers Map or VectorTile layer.\n * @param {Object|string} glStyle Mapbox Style object or url.\n * @param {Options} options Options.\n * @return {Promise} Promise that resolves when the background is applied.\n */\nfunction applyBackground(mapOrLayer, glStyle, options) {\n  if (options === void 0) options = {};\n  return getGlStyle(glStyle, options).then(function (glStyle) {\n    setFirstBackground(mapOrLayer, glStyle, options);\n  });\n}\nfunction getSourceIdByRef(layers, ref) {\n  var sourceId;\n  layers.some(function (layer) {\n    if (layer.id == ref) {\n      sourceId = layer.source;\n      return true;\n    }\n  });\n  return sourceId;\n}\nfunction extentFromTileJSON(tileJSON, projection) {\n  var bounds = tileJSON.bounds;\n  if (bounds) {\n    var ll = fromLonLat([bounds[0], bounds[1]], projection);\n    var tr = fromLonLat([bounds[2], bounds[3]], projection);\n    return [ll[0], ll[1], tr[0], tr[1]];\n  }\n  return get$1(projection).getExtent();\n}\nfunction sourceOptionsFromTileJSON(glSource, tileJSON, options) {\n  var tileJSONSource = new TileJSON({\n    tileJSON: tileJSON,\n    tileSize: glSource.tileSize || tileJSON.tileSize || 512\n  });\n  var tileJSONDoc = tileJSONSource.getTileJSON();\n  var tileGrid = tileJSONSource.getTileGrid();\n  var projection = get$1(options.projection || 'EPSG:3857');\n  var extent = extentFromTileJSON(tileJSONDoc, projection);\n  var projectionExtent = projection.getExtent();\n  var minZoom = tileJSONDoc.minzoom || 0;\n  var maxZoom = tileJSONDoc.maxzoom || 22;\n  /** @type {import(\"ol/source/VectorTile.js\").Options} */\n  var sourceOptions = {\n    attributions: tileJSONSource.getAttributions(),\n    projection: projection,\n    tileGrid: new TileGrid({\n      origin: projectionExtent ? getTopLeft(projectionExtent) : tileGrid.getOrigin(0),\n      extent: extent || tileGrid.getExtent(),\n      minZoom: minZoom,\n      resolutions: getTileResolutions(projection, tileJSON.tileSize).slice(0, maxZoom + 1),\n      tileSize: tileGrid.getTileSize(0)\n    })\n  };\n  if (Array.isArray(tileJSONDoc.tiles)) {\n    sourceOptions.urls = tileJSONDoc.tiles;\n  } else {\n    sourceOptions.url = tileJSONDoc.tiles;\n  }\n  return sourceOptions;\n}\nfunction getBackgroundColor(glLayer, resolution, options, functionCache) {\n  var background = {\n    id: glLayer.id,\n    type: glLayer.type\n  };\n  var layout = glLayer.layout || {};\n  var paint = glLayer.paint || {};\n  background['paint'] = paint;\n  var zoom = getZoomForResolution(resolution, options.resolutions || defaultResolutions);\n  var bg, opacity;\n  if (paint['background-color'] !== undefined) {\n    bg = getValue(background, 'paint', 'background-color', zoom, emptyObj, functionCache);\n  }\n  if (paint['background-opacity'] !== undefined) {\n    opacity = getValue(background, 'paint', 'background-opacity', zoom, emptyObj, functionCache);\n  }\n  return layout.visibility == 'none' ? undefined : colorWithOpacity(bg, opacity);\n}\n/**\n * @param {Object} glLayer Mapbox Style layer object.\n * @param {Options} options Options.\n * @param {Object} functionCache Cache for functions.\n * @return {Layer} OpenLayers layer.\n */\nfunction setupBackgroundLayer(glLayer, options, functionCache) {\n  var div = document.createElement('div');\n  div.className = 'ol-mapbox-style-background';\n  div.style.position = 'absolute';\n  div.style.width = '100%';\n  div.style.height = '100%';\n  return new Layer({\n    source: new Source({}),\n    render: function render(frameState) {\n      var color = getBackgroundColor(glLayer, frameState.viewState.resolution, options, functionCache);\n      div.style.backgroundColor = color;\n      return div;\n    }\n  });\n}\n/**\n * Creates an OpenLayers VectorTile source for a gl source entry.\n * @param {Object} glSource \"source\" entry from a Mapbox Style object.\n * @param {string|undefined} styleUrl URL to use for the source. This is expected to be the complete http(s) url,\n * with access key applied.\n * @param {Options} options Options.\n * @return {Promise<import(\"ol/source/VectorTile\").default>} Promise resolving to a VectorTile source.\n * @private\n */\nfunction setupVectorSource(glSource, styleUrl, options) {\n  return new Promise(function (resolve, reject) {\n    getTileJson(glSource, styleUrl, options).then(function (tileJSON) {\n      var sourceOptions = sourceOptionsFromTileJSON(glSource, tileJSON, options);\n      sourceOptions.format = new MVT();\n      if (Array.isArray(tileJSON.tiles)) {\n        sourceOptions.urls = tileJSON.tiles;\n      } else {\n        sourceOptions.url = tileJSON.tiles;\n      }\n      resolve(new VectorTileSource(sourceOptions));\n    }).catch(reject);\n  });\n}\nfunction setupVectorLayer(glSource, styleUrl, options) {\n  var layer = new VectorTileLayer({\n    declutter: true,\n    visible: false\n  });\n  setupVectorSource(glSource, styleUrl, options).then(function (source) {\n    source.set('mapbox-source', glSource);\n    layer.setSource(source);\n  }).catch(function (error) {\n    layer.setSource(undefined);\n  });\n  return layer;\n}\nfunction getBboxTemplate(projection) {\n  var projCode = projection ? projection.getCode() : 'EPSG:3857';\n  return \"{bbox-\" + projCode.toLowerCase().replace(/[^a-z0-9]/g, '-') + \"}\";\n}\nfunction setupRasterLayer(glSource, styleUrl, options) {\n  var layer = new TileLayer();\n  getTileJson(glSource, styleUrl, options).then(function (tileJson) {\n    var source = new TileJSON({\n      interpolate: options.interpolate === undefined ? true : options.interpolate,\n      transition: 0,\n      crossOrigin: 'anonymous',\n      tileJSON: tileJson\n    });\n    source.tileGrid = sourceOptionsFromTileJSON(glSource, tileJson, options).tileGrid;\n    if (options.projection) {\n      //@ts-ignore\n      source.projection = get$1(options.projection);\n    }\n    var getTileUrl = source.getTileUrlFunction();\n    source.setTileUrlFunction(function (tileCoord, pixelRatio, projection) {\n      var bboxTemplate = getBboxTemplate(projection);\n      var src = getTileUrl(tileCoord, pixelRatio, projection);\n      if (src.indexOf(bboxTemplate) != -1) {\n        var bbox = source.getTileGrid().getTileCoordExtent(tileCoord);\n        src = src.replace(bboxTemplate, bbox.toString());\n      }\n      return src;\n    });\n    source.set('mapbox-source', glSource);\n    layer.setSource(source);\n  }).catch(function (error) {\n    layer.setSource(undefined);\n  });\n  return layer;\n}\n/**\n *\n * @param {Object} glSource \"source\" entry from a Mapbox Style object.\n * @param {string} styleUrl Style url\n * @param {Options} options ol-mapbox-style options.\n * @return {ImageLayer<Raster>} The raster layer\n */\nfunction setupHillshadeLayer(glSource, styleUrl, options) {\n  var tileLayer = setupRasterLayer(glSource, styleUrl, options);\n  /** @type {ImageLayer<Raster>} */\n  var layer = new ImageLayer({\n    source: new Raster({\n      operationType: 'image',\n      operation: hillshade,\n      sources: [tileLayer]\n    })\n  });\n  return layer;\n}\nvar geoJsonFormat = new GeoJSON();\n/**\n * @param {Object} glSource glStyle source.\n * @param {string} styleUrl Style URL.\n * @param {Options} options Options.\n * @return {VectorSource} Configured vector source.\n */\nfunction setupGeoJSONSource(glSource, styleUrl, options) {\n  var data = glSource.data;\n  var sourceOptions = {};\n  if (typeof data == 'string') {\n    var geoJsonUrl = normalizeSourceUrl(data, options.accessToken, options.accessTokenParam || 'access_token', styleUrl || location.href);\n    if (options.transformRequest) {\n      var transformed = options.transformRequest(geoJsonUrl, 'GeoJSON');\n      if (transformed instanceof Request) {\n        geoJsonUrl = decodeURI(transformed.url);\n      }\n    }\n    if (/\\{bbox-[0-9a-z-]+\\}/.test(geoJsonUrl)) {\n      var extentUrl = function (extent, resolution, projection) {\n        var bboxTemplate = getBboxTemplate(projection);\n        return geoJsonUrl.replace(bboxTemplate, extent.join(',') + \",\" + projection.getCode());\n      };\n      var source$1 = new VectorSource({\n        attributions: glSource.attribution,\n        format: geoJsonFormat,\n        url: extentUrl,\n        strategy: bbox\n      });\n      source$1.set('mapbox-source', glSource);\n      return source$1;\n    }\n    return new VectorSource({\n      attributions: glSource.attribution,\n      format: geoJsonFormat,\n      url: geoJsonUrl\n    });\n  }\n  sourceOptions.features = geoJsonFormat.readFeatures(data, {\n    featureProjection: getUserProjection() || 'EPSG:3857'\n  });\n  var source = new VectorSource(Object.assign({\n    attributions: glSource.attribution,\n    format: geoJsonFormat\n  }, sourceOptions));\n  source.set('mapbox-source', glSource);\n  return source;\n}\nfunction setupGeoJSONLayer(glSource, styleUrl, options) {\n  return new VectorLayer({\n    declutter: true,\n    source: setupGeoJSONSource(glSource, styleUrl, options),\n    visible: false\n  });\n}\nfunction prerenderRasterLayer(glLayer, layer, functionCache) {\n  var zoom = null;\n  return function (event) {\n    if (glLayer.paint && 'raster-opacity' in glLayer.paint && event.frameState.viewState.zoom !== zoom) {\n      zoom = event.frameState.viewState.zoom;\n      delete functionCache[glLayer.id];\n      updateRasterLayerProperties(glLayer, layer, zoom, functionCache);\n    }\n  };\n}\nfunction updateRasterLayerProperties(glLayer, layer, zoom, functionCache) {\n  var opacity = getValue(glLayer, 'paint', 'raster-opacity', zoom, emptyObj, functionCache);\n  layer.setOpacity(opacity);\n}\n/**\n * @param {*} glStyle Mapbox Style.\n * @param {Map|LayerGroup} mapOrGroup Map or layer group.\n * @param {string} styleUrl Style URL.\n * @param {Options} options Options.\n * @return {Promise} Promise that resolves when the style is loaded.\n */\nfunction processStyle(glStyle, mapOrGroup, styleUrl, options) {\n  var promises = [];\n  var view = null;\n  if (mapOrGroup instanceof Map) {\n    view = mapOrGroup.getView();\n    if (!view.isDef() && !view.getRotation() && !view.getResolutions()) {\n      var projection = options.projection ? get$1(options.projection) : view.getProjection();\n      view = new View(Object.assign(view.getProperties(), {\n        maxResolution: defaultResolutions[0] / METERS_PER_UNIT[projection.getUnits()],\n        projection: options.projection || view.getProjection()\n      }));\n      mapOrGroup.setView(view);\n    }\n    if ('center' in glStyle && !view.getCenter()) {\n      view.setCenter(fromLonLat(glStyle.center, view.getProjection()));\n    }\n    if ('zoom' in glStyle && view.getZoom() === undefined) {\n      view.setResolution(defaultResolutions[0] / METERS_PER_UNIT[view.getProjection().getUnits()] / Math.pow(2, glStyle.zoom));\n    }\n    if (!view.getCenter() || view.getZoom() === undefined) {\n      view.fit(view.getProjection().getExtent(), {\n        nearest: true,\n        size: mapOrGroup.getSize()\n      });\n    }\n  }\n  var glLayers = glStyle.layers;\n  var layerIds = [];\n  var layer, glSource, glSourceId, id;\n  var loop = function (i, ii) {\n    var glLayer = glLayers[i];\n    var type = glLayer.type;\n    if (type == 'heatmap') {\n      //FIXME Unsupported layer type\n      throw new Error(type + \" layers are not supported\");\n    } else {\n      id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref);\n      // this technique assumes gl layers will be in a particular order\n      if (!id || id != glSourceId) {\n        if (layerIds.length) {\n          promises.push(finalizeLayer(layer, layerIds, glStyle, styleUrl, mapOrGroup, options));\n          layerIds = [];\n        }\n        var functionCache = getFunctionCache(glStyle);\n        glSource = glStyle.sources[id];\n        if (type == 'background') {\n          layer = setupBackgroundLayer(glLayer, options, functionCache);\n        } else if (glSource.type == 'vector') {\n          layer = setupVectorLayer(glSource, styleUrl, options);\n        } else if (glSource.type == 'raster') {\n          layerIds = [];\n          layer = setupRasterLayer(glSource, styleUrl, options);\n          layer.setVisible(glLayer.layout ? glLayer.layout.visibility !== 'none' : true);\n          layer.on('prerender', prerenderRasterLayer(glLayer, layer, functionCache));\n        } else if (glSource.type == 'geojson') {\n          layer = setupGeoJSONLayer(glSource, styleUrl, options);\n        } else if (glSource.type == 'raster-dem' && glLayer.type == 'hillshade') {\n          layerIds = [];\n          var hillshadeLayer = setupHillshadeLayer(glSource, styleUrl, options);\n          layer = hillshadeLayer;\n          hillshadeLayer.getSource().on('beforeoperations', function (event) {\n            var data = event.data;\n            data.resolution = event.resolution;\n            var zoom = getZoomForResolution(event.resolution, options.resolutions || defaultResolutions);\n            data.vert = 5 * getValue(glLayer, 'paint', 'hillshade-exaggeration', zoom, emptyObj, functionCache);\n            data.sunAz = getValue(glLayer, 'paint', 'hillshade-illumination-direction', zoom, emptyObj, functionCache);\n            data.sunEl = 35;\n            data.opacity = 0.3;\n            data.highlightColor = getValue(glLayer, 'paint', 'hillshade-highlight-color', zoom, emptyObj, functionCache);\n            data.shadowColor = getValue(glLayer, 'paint', 'hillshade-shadow-color', zoom, emptyObj, functionCache);\n            data.accentColor = getValue(glLayer, 'paint', 'hillshade-accent-color', zoom, emptyObj, functionCache);\n          });\n          layer.setVisible(glLayer.layout ? glLayer.layout.visibility !== 'none' : true);\n        }\n        glSourceId = id;\n        if (layer) {\n          layer.set('mapbox-source', glSourceId);\n        }\n      }\n      layerIds.push(glLayer.id);\n    }\n  };\n  for (var i = 0, ii = glLayers.length; i < ii; ++i) loop(i);\n  promises.push(finalizeLayer(layer, layerIds, glStyle, styleUrl, mapOrGroup, options));\n  mapOrGroup.set('mapbox-style', glStyle);\n  return Promise.all(promises);\n}\n/**\n * Loads and applies a Mapbox Style object into an OpenLayers Map or LayerGroup.\n * This includes the map background, the layers, and for Map instances that did not\n * have a View defined yet also the center and the zoom.\n *\n * **Example:**\n * ```js\n * import apply from 'ol-mapbox-style';\n *\n * apply('map', 'mapbox://styles/mapbox/bright-v9', {accessToken: 'YOUR_MAPBOX_TOKEN'});\n * ```\n *\n * The center and zoom will only be set if present in the Mapbox Style document,\n * and if not already set on the OpenLayers map.\n *\n * Layers will be added to the OpenLayers map, without affecting any layers that\n * might already be set on the map.\n *\n * Layers added by `apply()` will have two additional properties:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * This function sets an additional `mapbox-style` property on the OpenLayers\n * Map or LayerGroup instance, which holds the Mapbox Style object.\n *\n * @param {Map|HTMLElement|string|LayerGroup} mapOrGroupOrElement Either an existing\n * OpenLayers Map instance, or a HTML element, or the id of a HTML element that will be\n * the target of a new OpenLayers Map, or a layer group. If layer group, styles\n * releated to the map and view will be ignored.\n * @param {string|Object} style JSON style object or style url pointing to a\n * Mapbox Style object. When using Mapbox APIs, the url is the `styleUrl`\n * shown in Mapbox Studio's \"share\" panel. In addition, the `accessToken` option\n * (see below) must be set.\n * When passed as JSON style object, all OpenLayers layers created by `apply()`\n * will be immediately available, but they may not have a source yet (i.e. when\n * they are defined by a TileJSON url in the Mapbox Style document). When passed\n * as style url, layers will be added to the map when the Mapbox Style document\n * is loaded and parsed.\n * @param {Options} options Options.\n * @return {Promise<Map|LayerGroup>} A promise that resolves after all layers have been added to\n * the OpenLayers Map instance or LayerGroup, their sources set, and their styles applied. The\n * `resolve` callback will be called with the OpenLayers Map instance or LayerGroup as\n * argument.\n */\nfunction apply(mapOrGroupOrElement, style, options) {\n  if (options === void 0) options = {};\n  var promise;\n  /** @type {Map|LayerGroup} */\n  var mapOrGroup;\n  if (typeof mapOrGroupOrElement === 'string' || mapOrGroupOrElement instanceof HTMLElement) {\n    mapOrGroup = new Map({\n      target: mapOrGroupOrElement\n    });\n  } else {\n    mapOrGroup = mapOrGroupOrElement;\n  }\n  if (typeof style === 'string') {\n    var styleUrl = style.startsWith('data:') ? location.href : normalizeStyleUrl(style, options.accessToken);\n    options = completeOptions(styleUrl, options);\n    promise = new Promise(function (resolve, reject) {\n      getGlStyle(style, options).then(function (glStyle) {\n        processStyle(glStyle, mapOrGroup, styleUrl, options).then(function () {\n          resolve(mapOrGroup);\n        }).catch(reject);\n      }).catch(function (err) {\n        reject(new Error(\"Could not load \" + style + \": \" + err.message));\n      });\n    });\n  } else {\n    promise = new Promise(function (resolve, reject) {\n      processStyle(style, mapOrGroup, !options.styleUrl || options.styleUrl.startsWith('data:') ? location.href : normalizeStyleUrl(options.styleUrl, options.accessToken), options).then(function () {\n        resolve(mapOrGroup);\n      }).catch(reject);\n    });\n  }\n  return promise;\n}\n/**\n * If layerIds is not empty, applies the style specified in glStyle to the layer,\n * and adds the layer to the map.\n *\n * The layer may not yet have a source when the function is called.  If so, the style\n * is applied to the layer via a once listener on the 'change:source' event.\n *\n * @param {Layer} layer An OpenLayers layer instance.\n * @param {Array<string>} layerIds Array containing layer ids of already-processed layers.\n * @param {Object} glStyle Style as a JSON object.\n * @param {string|undefined} styleUrl The original style URL. Only required\n * when a relative path is used with the `\"sprite\"` property of the style.\n * @param {Map|LayerGroup} mapOrGroup OpenLayers Map.\n * @param {Options} options Options.\n * @return {Promise} Returns a promise that resolves after the source has\n * been set on the specified layer, and the style has been applied.\n * @private\n */\nfunction finalizeLayer(layer, layerIds, glStyle, styleUrl, mapOrGroup, options) {\n  if (options === void 0) options = {};\n  var minZoom = 24;\n  var maxZoom = 0;\n  var glLayers = glStyle.layers;\n  for (var i = 0, ii = glLayers.length; i < ii; ++i) {\n    var glLayer = glLayers[i];\n    if (layerIds.indexOf(glLayer.id) !== -1) {\n      minZoom = Math.min('minzoom' in glLayer ? glLayer.minzoom : 0, minZoom);\n      maxZoom = Math.max('maxzoom' in glLayer ? glLayer.maxzoom : 24, maxZoom);\n    }\n  }\n  return new Promise(function (resolve, reject) {\n    var setStyle = function () {\n      var source = layer.getSource();\n      if (!source || source.getState() === 'error') {\n        reject(new Error('Error accessing data for source ' + layer.get('mapbox-source')));\n        return;\n      }\n      if ('getTileGrid' in source) {\n        var tileGrid = /** @type {import(\"ol/source/Tile.js\").default|import(\"ol/source/VectorTile.js\").default} */\n        source.getTileGrid();\n        if (tileGrid) {\n          var sourceMinZoom = tileGrid.getMinZoom();\n          if (minZoom > 0 || sourceMinZoom > 0) {\n            layer.setMaxResolution(Math.min(defaultResolutions[minZoom], tileGrid.getResolution(sourceMinZoom)) + 1e-9);\n          }\n          if (maxZoom < 24) {\n            layer.setMinResolution(defaultResolutions[maxZoom] + 1e-9);\n          }\n        }\n      } else {\n        if (minZoom > 0) {\n          layer.setMaxResolution(defaultResolutions[minZoom] + 1e-9);\n        }\n      }\n      if (source instanceof VectorSource || source instanceof VectorTileSource) {\n        applyStyle(layer, glStyle, layerIds, Object.assign({\n          styleUrl: styleUrl\n        }, options)).then(function () {\n          layer.setVisible(true);\n          resolve();\n        }).catch(reject);\n      } else {\n        resolve();\n      }\n    };\n    layer.set('mapbox-layers', layerIds);\n    var layers = mapOrGroup.getLayers();\n    if (layers.getArray().indexOf(layer) === -1) {\n      layers.push(layer);\n    }\n    if (layer.getSource()) {\n      setStyle();\n    } else {\n      layer.once('change:source', setStyle);\n    }\n  });\n}\n/**\n * Get the OpenLayers layer instance that contains the provided Mapbox Style\n * `layer`. Note that multiple Mapbox Style layers are combined in a single\n * OpenLayers layer instance when they use the same Mapbox Style `source`.\n * @param {Map|LayerGroup} map OpenLayers Map or LayerGroup.\n * @param {string} layerId Mapbox Style layer id.\n * @return {Layer} OpenLayers layer instance.\n */\nfunction getLayer(map, layerId) {\n  var layers = map.getLayers().getArray();\n  for (var i = 0, ii = layers.length; i < ii; ++i) {\n    var mapboxLayers = layers[i].get('mapbox-layers');\n    if (mapboxLayers && mapboxLayers.indexOf(layerId) !== -1) {\n      return layers[i];\n    }\n  }\n}\n/**\n * Get the OpenLayers layer instances for the provided Mapbox Style `source`.\n * @param {Map|LayerGroup} map OpenLayers Map or LayerGroup.\n * @param {string} sourceId Mapbox Style source id.\n * @return {Array<Layer>} OpenLayers layer instances.\n */\nfunction getLayers(map, sourceId) {\n  var result = [];\n  var layers = map.getLayers().getArray();\n  for (var i = 0, ii = layers.length; i < ii; ++i) {\n    if (layers[i].get('mapbox-source') === sourceId) {\n      result.push(layers[i]);\n    }\n  }\n  return result;\n}\n/**\n * Get the OpenLayers source instance for the provided Mapbox Style `source`.\n * @param {Map|LayerGroup} map OpenLayers Map or LayerGroup.\n * @param {string} sourceId Mapbox Style source id.\n * @return {Source} OpenLayers source instance.\n */\nfunction getSource(map, sourceId) {\n  var layers = map.getLayers().getArray();\n  for (var i = 0, ii = layers.length; i < ii; ++i) {\n    var source = /** @type {Layer} */\n    layers[i].getSource();\n    if (layers[i].get('mapbox-source') === sourceId) {\n      return source;\n    }\n  }\n}\n/**\n * Sets or removes a feature state. The feature state is taken into account for styling,\n * just like the feature's properties, and can be used e.g. to conditionally render selected\n * features differently.\n *\n * The feature state will be stored on the OpenLayers layer matching the feature identifier, in the\n * `mapbox-featurestate` property.\n * @param {Map|VectorLayer|VectorTileLayer} mapOrLayer OpenLayers Map or layer to set the feature\n * state on.\n * @param {FeatureIdentifier} feature Feature identifier.\n * @param {Object|null} state Feature state. Set to `null` to remove the feature state.\n */\nfunction setFeatureState(mapOrLayer, feature, state) {\n  var layers = 'getLayers' in mapOrLayer ? getLayers(mapOrLayer, feature.source) : [mapOrLayer];\n  for (var i = 0, ii = layers.length; i < ii; ++i) {\n    var featureState = layers[i].get('mapbox-featurestate');\n    if (featureState) {\n      if (state) {\n        featureState[feature.id] = state;\n      } else {\n        delete featureState[feature.id];\n      }\n      layers[i].changed();\n    } else {\n      throw new Error(\"Map or layer for source \\\"\" + feature.source + \"\\\" not found.\");\n    }\n  }\n}\n/**\n * Sets or removes a feature state. The feature state is taken into account for styling,\n * just like the feature's properties, and can be used e.g. to conditionally render selected\n * features differently.\n * @param {Map|VectorLayer|VectorTileLayer} mapOrLayer Map or layer to set the feature state on.\n * @param {FeatureIdentifier} feature Feature identifier.\n * @return {Object|null} Feature state or `null` when no feature state is set for the given\n * feature identifier.\n */\nfunction getFeatureState(mapOrLayer, feature) {\n  var layers = 'getLayers' in mapOrLayer ? getLayers(mapOrLayer, feature.source) : [mapOrLayer];\n  for (var i = 0, ii = layers.length; i < ii; ++i) {\n    var featureState = layers[i].get('mapbox-featurestate');\n    if (featureState && featureState[feature.id]) {\n      return featureState[feature.id];\n    }\n  }\n  return null;\n}\n/**\n * Get the Mapbox Layer object for the provided `layerId`.\n * @param {Map|LayerGroup} mapOrGroup Map or LayerGroup.\n * @param {string} layerId Mapbox Layer id.\n * @return {Object} Mapbox Layer object.\n */\nfunction getMapboxLayer(mapOrGroup, layerId) {\n  var style = mapOrGroup.get('mapbox-style');\n  var layerStyle = style.layers.find(function (layer) {\n    return layer.id === layerId;\n  });\n  return layerStyle;\n}\n/**\n * Add a new Mapbox Layer object to the style.\n * @param {Map|LayerGroup} mapOrGroup Map or LayerGroup.\n * @param {Object} mapboxLayer Mapbox Layer object.\n * @param {string} [beforeLayerId] Optional id of the Mapbox Layer before the new layer that will be added.\n */\nfunction addMapboxLayer(mapOrGroup, mapboxLayer, beforeLayerId) {\n  var mapboxLayers = mapOrGroup.get('mapbox-style').layers;\n  var index;\n  if (beforeLayerId !== undefined) {\n    var beforeLayer = getMapboxLayer(mapOrGroup, beforeLayerId);\n    if (beforeLayer === undefined) {\n      throw new Error(\"Layer with id \\\"\" + beforeLayerId + \"\\\" not found.\");\n    }\n    index = mapboxLayers.indexOf(beforeLayer);\n  } else {\n    index = mapboxLayers.length;\n  }\n  if (index === 0) {\n    throw new Error('Cannot add layer before first layer.');\n  }\n  if (mapboxLayers[index - 1].source !== mapboxLayer.source) {\n    throw new Error('Added layer and layer before must use the same source.');\n  }\n  if (mapboxLayers.some(function (layer) {\n    return layer.id === mapboxLayer.id;\n  })) {\n    throw new Error(\"Layer with id \\\"\" + mapboxLayer.id + \"\\\" already exists.\");\n  }\n  mapboxLayers.splice(index, 0, mapboxLayer);\n}\n/**\n * Update a Mapbox Layer object in the style. The map will be re-rendered with the new style.\n * @param {Map|LayerGroup} mapOrGroup Map or LayerGroup.\n * @param {Object} mapboxLayer Updated Mapbox Layer object.\n */\nfunction updateMapboxLayer(mapOrGroup, mapboxLayer) {\n  var glStyle = mapOrGroup.get('mapbox-style');\n  var mapboxLayers = glStyle.layers;\n  var index = mapboxLayers.findIndex(function (layer) {\n    return layer.id === mapboxLayer.id;\n  });\n  if (index === -1) {\n    throw new Error(\"Layer with id \\\"\" + mapboxLayer.id + \"\\\" not found.\");\n  }\n  var oldLayer = mapboxLayers[index];\n  if (oldLayer.source !== mapboxLayer.source) {\n    throw new Error('Updated layer and previous version must use the same source.');\n  }\n  delete getFunctionCache(glStyle)[mapboxLayer.id];\n  delete getFilterCache(glStyle)[mapboxLayer.id];\n  mapboxLayers[index] = mapboxLayer;\n  getLayer(mapOrGroup, mapboxLayer.id).changed();\n}\nexport { addMapboxLayer, apply, applyBackground, applyStyle, apply as default, getFeatureState, getLayer, getLayers, getMapboxLayer, getSource, recordStyleLayer, renderTransparent, setFeatureState, stylefunction, updateMapboxLayer };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}