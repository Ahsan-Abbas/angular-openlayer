{"ast":null,"code":"import _asyncToGenerator from \"D:/PBSGeo (Office Work)/PBSGEO (Angular Job Post)/Test Task 1/angular-openlayers/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport BaseDecoder from './basedecoder.js';\n\n/**\n * class WebImageDecoder\n *\n * This decoder uses the browsers image decoding facilities to read image\n * formats like WebP when supported.\n */\nclass WebImageDecoder extends BaseDecoder {\n  constructor() {\n    super();\n    if (typeof createImageBitmap === 'undefined') {\n      throw new Error('Cannot decode WebImage as `createImageBitmap` is not available');\n    } else if (typeof document === 'undefined' && typeof OffscreenCanvas === 'undefined') {\n      throw new Error('Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available');\n    }\n  }\n  decode(fileDirectory, buffer) {\n    return _asyncToGenerator(function* () {\n      const blob = new Blob([buffer]);\n      const imageBitmap = yield createImageBitmap(blob);\n      let canvas;\n      if (typeof document !== 'undefined') {\n        canvas = document.createElement('canvas');\n        canvas.width = imageBitmap.width;\n        canvas.height = imageBitmap.height;\n      } else {\n        canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);\n      }\n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(imageBitmap, 0, 0);\n\n      // TODO: check how many samples per pixel we have, and return RGB/RGBA accordingly\n      // it seems like GDAL always encodes via RGBA which does not require a translation\n\n      return ctx.getImageData(0, 0, imageBitmap.width, imageBitmap.height).data.buffer;\n    })();\n  }\n}\nexport { WebImageDecoder as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}